{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Csound Plugins Welcome to the csound-plugins wiki! This is a collection of plugins for csound Installation See Installation klib A hashtable for csound dict_new : Create a hashtable dict_free : Free a hashtable dict_get : Get a value from a hashtable dict_set : Set (or remove) a value from a hashtable dict_size : Returns the number of key:value pairs in a dict dict_query : Query different properties of a dict dict_print : Prints the contents of a dict dict_iter : Iterate over the key-value pairs of a dict poly Multiple (parallel or sequential) instances of an opcode poly : poly creates and controls multiple parallel version of an opcode polyseq : polyseq creates and controls multiple sequential version of an opcode sched Schedule an action when note is stopped atstop : Schedule an instrument at the end of the current instrument","title":"Csound Plugins"},{"location":"index.html#csound-plugins","text":"Welcome to the csound-plugins wiki! This is a collection of plugins for csound","title":"Csound Plugins"},{"location":"index.html#installation","text":"See Installation","title":"Installation"},{"location":"index.html#klib","text":"A hashtable for csound dict_new : Create a hashtable dict_free : Free a hashtable dict_get : Get a value from a hashtable dict_set : Set (or remove) a value from a hashtable dict_size : Returns the number of key:value pairs in a dict dict_query : Query different properties of a dict dict_print : Prints the contents of a dict dict_iter : Iterate over the key-value pairs of a dict","title":"klib"},{"location":"index.html#poly","text":"Multiple (parallel or sequential) instances of an opcode poly : poly creates and controls multiple parallel version of an opcode polyseq : polyseq creates and controls multiple sequential version of an opcode","title":"poly"},{"location":"index.html#sched","text":"Schedule an action when note is stopped atstop : Schedule an instrument at the end of the current instrument","title":"sched"},{"location":"Contributing.html","text":"Contributing To submit an opcode clone this repository and make a pull request Organisation An opcode is normally implemented as part of a library, to allow for different versions and related opcodes to share functionality. Each library lives in its own directory. The tree can be structured as follows: mylib/ CMakeLists.txt manifest.json [ README.md ] src/ mylib.c examples/ foo.csd bar.csd docs/ foo.md bar.md For each opcode defined in mylib.c there should be an example opcode.csd and a manual page opcode.md . Optionally it is possible to include a README.md where a short description of the opcodes in this library is given Put your tree under src and you should be able to build your plugin. Build We use cmake as a build tool. For simple opcodes with no extra dependencies, a simple CMakeLists.txt would suffice: make_plugin(mylib src/mylib.c) Installation At the root folder of this repository, do mkdir build cd build cmake .. make sudo make install Manifest A manifest is used to automate documentation of the opcodes (wiki, pdf documentation, etc). The manifest is a .json file. It should have the minimal form: { \"name\" : \"mylib\" , \"opcodes\" : [ \"foo\" , \"bar\" ], \"author\" : \"name\" , \"author_email\" : \"name@email.com\" , \"license\" : \"LGPL\" , \"description\" : \"Description of this package\" , \"url\" : \"http://github.com/...\" } In this case, three opcodes are defined, and these names should correspond to the .csd example living inside of the examples folder, and a .md file living inside the docs folder.","title":"Contributing"},{"location":"Contributing.html#contributing","text":"To submit an opcode clone this repository and make a pull request","title":"Contributing"},{"location":"Contributing.html#organisation","text":"An opcode is normally implemented as part of a library, to allow for different versions and related opcodes to share functionality. Each library lives in its own directory. The tree can be structured as follows: mylib/ CMakeLists.txt manifest.json [ README.md ] src/ mylib.c examples/ foo.csd bar.csd docs/ foo.md bar.md For each opcode defined in mylib.c there should be an example opcode.csd and a manual page opcode.md . Optionally it is possible to include a README.md where a short description of the opcodes in this library is given Put your tree under src and you should be able to build your plugin.","title":"Organisation"},{"location":"Contributing.html#build","text":"We use cmake as a build tool. For simple opcodes with no extra dependencies, a simple CMakeLists.txt would suffice: make_plugin(mylib src/mylib.c)","title":"Build"},{"location":"Contributing.html#installation","text":"At the root folder of this repository, do mkdir build cd build cmake .. make sudo make install","title":"Installation"},{"location":"Contributing.html#manifest","text":"A manifest is used to automate documentation of the opcodes (wiki, pdf documentation, etc). The manifest is a .json file. It should have the minimal form: { \"name\" : \"mylib\" , \"opcodes\" : [ \"foo\" , \"bar\" ], \"author\" : \"name\" , \"author_email\" : \"name@email.com\" , \"license\" : \"LGPL\" , \"description\" : \"Description of this package\" , \"url\" : \"http://github.com/...\" } In this case, three opcodes are defined, and these names should correspond to the .csd example living inside of the examples folder, and a .md file living inside the docs folder.","title":"Manifest"},{"location":"Installation.html","text":"Installation From Source The source lives at https://github.com/csound-plugins/csound-plugins Dependencies a compiler cmake csound >= 6.13 git clone https://github.com/csound-plugins/csound-plugins cd csound-plugins mkdir build cd build cmake .. make sudo make install","title":"Installation"},{"location":"Installation.html#installation","text":"","title":"Installation"},{"location":"Installation.html#from-source","text":"The source lives at https://github.com/csound-plugins/csound-plugins","title":"From Source"},{"location":"Installation.html#dependencies","text":"a compiler cmake csound >= 6.13 git clone https://github.com/csound-plugins/csound-plugins cd csound-plugins mkdir build cd build cmake .. make sudo make install","title":"Dependencies"},{"location":"opcodes/atstop.html","text":"atstop Abstract Schedule an instrument at the end of the current instrument Description atstop can be used to schedule an instrument event as the last action of a given instrument, during the process of being deallocated. This can be used to notify when the note has actually stopped, or to schedule a chain of events, free any table or dict allocated, etc. The advantage over the release opcode is that atstop is guaranteed to be run after the note has stopped, so there is no danger in deallocating resources being used by this note, there are no conflicts with release envelopes, etc. NB : the event is not scheduled at release time (see below \"Release time vs Deinit time\") but at the moment the note is freed. Release time vs deinit time Release time is when the note is within its release phase , which will only happen if the note has an envelope with a release segment (like linsegr ), or if it has setup extra time with xtratim . The opcode release can be used to query if the current note is being released. The instrument keeps running in release phase as long as the release part of the envelope is finished or the extra time allocated via xtratim is through. Deinit time is the moment the note is actually being freed, so the instrument is not running anymore at this point. Syntax atstop instrnum, idelay, idur [, p4, p5, ...] atstop Sinstrname, idelay, idur [, p4, p5, ...] atstop executes only at init time . Arguments instrnum / Sintrname : the number or the name of the instr to be scheduled idelay : the time offset after the stop time of this note to start this instrument idur : the duration of the event p4 , p5 , ...: any other p-arguments, as used with similar opcodes like schedule , event , etc. Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* # This is the example file for the atstop opcode atstop schedules an instrument at the end of the note This might be useful to notify that a note stopped, or to schedule a chain of notes, etc. NB: the scheduled event is NOT triggered at release time, which might be when this note is still playing, if the note has some release envelope, but when the note is being deleted ## Syntax atstop Sinstrname, idelay, idur, ... atstop instrnum, idelay, idur, ... * Sinstrname / instrnum: the name or the instrument number to schedule * idelay: time offset to this note stop * idur: duration of the scheduled event (-1 = forever) */ sr = 44100 ksmps = 64 0dbfs = 1 nchnls = 2 opcode myvco , a , ii i amp , i freq xin a 0 vco2 , i amp , i freq a 0 += vco2 ( i amp , i freq + 2 ) a 0 += vco2 ( i amp , i freq / 2 ) xout a 0 endop ; brownian walk instr 1 i midi = p4 a 0 myvco 0.1 , mtof : i ( i midi ) outs a 0 , a 0 i delta = round (( rnd ( 4 ) - 1 ) * 2 ) / 2 i delta = i delta != 0 ? i delta : - 0.5 i midi2 = i midi + i delta i midi2 = i midi2 < 96 ? i midi2 : 48 i durnext = round ( rnd ( 0.25 ) * 8 ) / 8 a tstop 1 , 0 , i durnext , i midi2 endin ; ping-pong instr 2 i midi = p4 a 0 myvco 0.1 , mtof : i ( i midi ) a 0 *= linsegr ( 0 , 0.05 , 1 , 0.05 , 0 ) outs a 0 , a 0 i midi = i midi < 96 ? i midi : 48 a tstop 3 , 0 , p3 , i midi + 1 endin instr 3 i midi = p4 a 0 oscili 0.5 , mtof : i ( i midi ) a 0 *= linsegr ( 0 , 0.05 , 1 , 0.050 , 0 ) outs a 0 , a 0 i midi = i midi < 96 ? i midi : 48 a tstop 2 , 0 , p3 * 0.75 , i midi + 1 endin instr 100 exitnow endin </ CsInstruments > < CsScore > ; i 1 0 0.25 36 i 2 0 0.25 48 i 100 20 1 </ CsScore > </ CsoundSynthesizer > See also schedule event release xtratim Credits Eduardo Moguillansky, 2019","title":"atstop"},{"location":"opcodes/atstop.html#atstop","text":"","title":"atstop"},{"location":"opcodes/atstop.html#abstract","text":"Schedule an instrument at the end of the current instrument","title":"Abstract"},{"location":"opcodes/atstop.html#description","text":"atstop can be used to schedule an instrument event as the last action of a given instrument, during the process of being deallocated. This can be used to notify when the note has actually stopped, or to schedule a chain of events, free any table or dict allocated, etc. The advantage over the release opcode is that atstop is guaranteed to be run after the note has stopped, so there is no danger in deallocating resources being used by this note, there are no conflicts with release envelopes, etc. NB : the event is not scheduled at release time (see below \"Release time vs Deinit time\") but at the moment the note is freed.","title":"Description"},{"location":"opcodes/atstop.html#release-time-vs-deinit-time","text":"Release time is when the note is within its release phase , which will only happen if the note has an envelope with a release segment (like linsegr ), or if it has setup extra time with xtratim . The opcode release can be used to query if the current note is being released. The instrument keeps running in release phase as long as the release part of the envelope is finished or the extra time allocated via xtratim is through. Deinit time is the moment the note is actually being freed, so the instrument is not running anymore at this point.","title":"Release time vs deinit time"},{"location":"opcodes/atstop.html#syntax","text":"atstop instrnum, idelay, idur [, p4, p5, ...] atstop Sinstrname, idelay, idur [, p4, p5, ...] atstop executes only at init time .","title":"Syntax"},{"location":"opcodes/atstop.html#arguments","text":"instrnum / Sintrname : the number or the name of the instr to be scheduled idelay : the time offset after the stop time of this note to start this instrument idur : the duration of the event p4 , p5 , ...: any other p-arguments, as used with similar opcodes like schedule , event , etc.","title":"Arguments"},{"location":"opcodes/atstop.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* # This is the example file for the atstop opcode atstop schedules an instrument at the end of the note This might be useful to notify that a note stopped, or to schedule a chain of notes, etc. NB: the scheduled event is NOT triggered at release time, which might be when this note is still playing, if the note has some release envelope, but when the note is being deleted ## Syntax atstop Sinstrname, idelay, idur, ... atstop instrnum, idelay, idur, ... * Sinstrname / instrnum: the name or the instrument number to schedule * idelay: time offset to this note stop * idur: duration of the scheduled event (-1 = forever) */ sr = 44100 ksmps = 64 0dbfs = 1 nchnls = 2 opcode myvco , a , ii i amp , i freq xin a 0 vco2 , i amp , i freq a 0 += vco2 ( i amp , i freq + 2 ) a 0 += vco2 ( i amp , i freq / 2 ) xout a 0 endop ; brownian walk instr 1 i midi = p4 a 0 myvco 0.1 , mtof : i ( i midi ) outs a 0 , a 0 i delta = round (( rnd ( 4 ) - 1 ) * 2 ) / 2 i delta = i delta != 0 ? i delta : - 0.5 i midi2 = i midi + i delta i midi2 = i midi2 < 96 ? i midi2 : 48 i durnext = round ( rnd ( 0.25 ) * 8 ) / 8 a tstop 1 , 0 , i durnext , i midi2 endin ; ping-pong instr 2 i midi = p4 a 0 myvco 0.1 , mtof : i ( i midi ) a 0 *= linsegr ( 0 , 0.05 , 1 , 0.05 , 0 ) outs a 0 , a 0 i midi = i midi < 96 ? i midi : 48 a tstop 3 , 0 , p3 , i midi + 1 endin instr 3 i midi = p4 a 0 oscili 0.5 , mtof : i ( i midi ) a 0 *= linsegr ( 0 , 0.05 , 1 , 0.050 , 0 ) outs a 0 , a 0 i midi = i midi < 96 ? i midi : 48 a tstop 2 , 0 , p3 * 0.75 , i midi + 1 endin instr 100 exitnow endin </ CsInstruments > < CsScore > ; i 1 0 0.25 36 i 2 0 0.25 48 i 100 20 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/atstop.html#see-also","text":"schedule event release xtratim","title":"See also"},{"location":"opcodes/atstop.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_free.html","text":"dict_free Abstract Free a hashtable Description frees the hashtable either at init time or at the end of the note (similar to ftfree) A dict can only be freed if it was created as global (see dict_new ). To be able to pass a dict between notes, a note can create a global dict and pass its handle to another note. When the first note is released, the dict lives on (because it is global), and it will be either freed at the end of the performance or explicitely by calling dict_free Syntax dict_free idict [, iwhen=0] dict_free executes only at init time . Arguments idict : the handle of the dict to be freed iwhen : similar to ftfree if iwhen == 0 : free the dict now if iwhen == 1 : free the dict at the end of this note Examples < CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > See also dict_new Credits Eduardo Moguillansky, 2019","title":"dict_free"},{"location":"opcodes/dict_free.html#dict_free","text":"","title":"dict_free"},{"location":"opcodes/dict_free.html#abstract","text":"Free a hashtable","title":"Abstract"},{"location":"opcodes/dict_free.html#description","text":"frees the hashtable either at init time or at the end of the note (similar to ftfree) A dict can only be freed if it was created as global (see dict_new ). To be able to pass a dict between notes, a note can create a global dict and pass its handle to another note. When the first note is released, the dict lives on (because it is global), and it will be either freed at the end of the performance or explicitely by calling dict_free","title":"Description"},{"location":"opcodes/dict_free.html#syntax","text":"dict_free idict [, iwhen=0] dict_free executes only at init time .","title":"Syntax"},{"location":"opcodes/dict_free.html#arguments","text":"idict : the handle of the dict to be freed iwhen : similar to ftfree if iwhen == 0 : free the dict now if iwhen == 1 : free the dict at the end of this note","title":"Arguments"},{"location":"opcodes/dict_free.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_free.html#see-also","text":"dict_new","title":"See also"},{"location":"opcodes/dict_free.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_get.html","text":"dict_get Abstract Get a value from a hashtable Description A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_get returns the value for a given key. If the key is not present, a default value is returned (the empty string for string values, or an user given default for number values) Syntax kvalue dict_get idict, Skeym [idefault=0] kvalue dict_get idict, kkey, [idefault=0] Svalue dict_get idict, Skey Svalue dict_get idict, kkey The type of key and value depend on the type definition of the dict , see dict_new dict_get executes both at i-time and k-time . Arguments \u00ecdict : the handle of the dict, as returned by dict_new Skey / kkey : the key to be queries, as previously set by dict_set idefault : if the key is not present, this value is returned (defaults to 0) Output kvalue / Svalue : the value corresponding to the key, or a default if the key is not found For dicts with a string value, an empty string is returned when the key is not found. For dicts with a numeric value, a user given default is returned (default=0) Examples < CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > See also dict_new dict_set Credits Eduardo Moguillansky, 2019","title":"dict_get"},{"location":"opcodes/dict_get.html#dict_get","text":"","title":"dict_get"},{"location":"opcodes/dict_get.html#abstract","text":"Get a value from a hashtable","title":"Abstract"},{"location":"opcodes/dict_get.html#description","text":"A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_get returns the value for a given key. If the key is not present, a default value is returned (the empty string for string values, or an user given default for number values)","title":"Description"},{"location":"opcodes/dict_get.html#syntax","text":"kvalue dict_get idict, Skeym [idefault=0] kvalue dict_get idict, kkey, [idefault=0] Svalue dict_get idict, Skey Svalue dict_get idict, kkey The type of key and value depend on the type definition of the dict , see dict_new dict_get executes both at i-time and k-time .","title":"Syntax"},{"location":"opcodes/dict_get.html#arguments","text":"\u00ecdict : the handle of the dict, as returned by dict_new Skey / kkey : the key to be queries, as previously set by dict_set idefault : if the key is not present, this value is returned (defaults to 0)","title":"Arguments"},{"location":"opcodes/dict_get.html#output","text":"kvalue / Svalue : the value corresponding to the key, or a default if the key is not found For dicts with a string value, an empty string is returned when the key is not found. For dicts with a numeric value, a user given default is returned (default=0)","title":"Output"},{"location":"opcodes/dict_get.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_get.html#see-also","text":"dict_new dict_set","title":"See also"},{"location":"opcodes/dict_get.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_iter.html","text":"dict_iter Abstract Iterate over the key-value pairs of a dict Description Iterates over the key:value pairs. Whenever kreset is 1, iteration starts over If kreset is -1 (the default), iteration is autotriggered when it reaches the end of the collection. NB : This opcode is meant to be used in a loop at k-time Syntax xkey, xvalue, kidx dict_iter idict [, kreset = -1] dict_loop executes only at performance time . Arguments idict : the handle to the dict as returned by dict_new kreset : the reset policy kreset = 0 : no reset, iteration stops at the end of the collection is can't start over. This makes sure that there will be max. 1 iteration within this note kreset = 1 (default): iteration is started over at every k-cycle kreset = 2 : Reset at the end of iteration Output xkey / xvalue : the key and value for this pair. The types are determined by the type of this dict, as defined via dict_new kidx : the index of this pair. It will be 0 for the first pair, 1 for the second, etc. When no more pairs, kidx will be -1. In this case, xkey and xvalue do not hold valid values Usage There are two ways to use dict_iter , either in a while loop, or using gotos ; iterate in a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"key: %s value: %f \" , k idx , S key , k value od ; iterate with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"key: %s value: %f \" , k idx , S key , k value kgoto loop break : Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* # Example file for dict_iter opcode */ instr 1 /* dict_iter xkey, xvalue, kidx dict_iter ihandle [,kreset=1] kidx: holds the number of pairs yielded since last reset. It is set to -1 when iteration has stopped (in this case, xkey and xvalue are invalid and should not be used) kreset = 0 -> after iterating over all pairs iteration stops In this mode, iteration happens at most once 1 -> iteration starts over every k-cycle 2 -> iteration restarts after stopping */ i dict dict_new \"sf\" , 0 , \"foo\" , 1 , \"bar\" , 2 , \"baz\" , 15 , \"bee\" , 9 ; iterate with a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"while) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value od ; the same but with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"loop) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value kgoto loop break : endin </ CsInstruments > < CsScore > i 3 0 0.05 </ CsScore > </ CsoundSynthesizer > See also dict_new dict_size Credits Eduardo Moguillansky, 2019","title":"dict_iter"},{"location":"opcodes/dict_iter.html#dict_iter","text":"","title":"dict_iter"},{"location":"opcodes/dict_iter.html#abstract","text":"Iterate over the key-value pairs of a dict","title":"Abstract"},{"location":"opcodes/dict_iter.html#description","text":"Iterates over the key:value pairs. Whenever kreset is 1, iteration starts over If kreset is -1 (the default), iteration is autotriggered when it reaches the end of the collection. NB : This opcode is meant to be used in a loop at k-time","title":"Description"},{"location":"opcodes/dict_iter.html#syntax","text":"xkey, xvalue, kidx dict_iter idict [, kreset = -1] dict_loop executes only at performance time .","title":"Syntax"},{"location":"opcodes/dict_iter.html#arguments","text":"idict : the handle to the dict as returned by dict_new kreset : the reset policy kreset = 0 : no reset, iteration stops at the end of the collection is can't start over. This makes sure that there will be max. 1 iteration within this note kreset = 1 (default): iteration is started over at every k-cycle kreset = 2 : Reset at the end of iteration","title":"Arguments"},{"location":"opcodes/dict_iter.html#output","text":"xkey / xvalue : the key and value for this pair. The types are determined by the type of this dict, as defined via dict_new kidx : the index of this pair. It will be 0 for the first pair, 1 for the second, etc. When no more pairs, kidx will be -1. In this case, xkey and xvalue do not hold valid values","title":"Output"},{"location":"opcodes/dict_iter.html#usage","text":"There are two ways to use dict_iter , either in a while loop, or using gotos ; iterate in a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"key: %s value: %f \" , k idx , S key , k value od ; iterate with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"key: %s value: %f \" , k idx , S key , k value kgoto loop break :","title":"Usage"},{"location":"opcodes/dict_iter.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* # Example file for dict_iter opcode */ instr 1 /* dict_iter xkey, xvalue, kidx dict_iter ihandle [,kreset=1] kidx: holds the number of pairs yielded since last reset. It is set to -1 when iteration has stopped (in this case, xkey and xvalue are invalid and should not be used) kreset = 0 -> after iterating over all pairs iteration stops In this mode, iteration happens at most once 1 -> iteration starts over every k-cycle 2 -> iteration restarts after stopping */ i dict dict_new \"sf\" , 0 , \"foo\" , 1 , \"bar\" , 2 , \"baz\" , 15 , \"bee\" , 9 ; iterate with a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"while) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value od ; the same but with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"loop) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value kgoto loop break : endin </ CsInstruments > < CsScore > i 3 0 0.05 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_iter.html#see-also","text":"dict_new dict_size","title":"See also"},{"location":"opcodes/dict_iter.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_new.html","text":"dict_new Abstract Create a hashtable Description A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. A hashtable can be either local, in which case its lifespan is fixed to the lifespan of the note it was created in; or it can be global, in which case it is not deallocated when the note is released and is kept alive until either the end of the performance, or until freed via dict_free Syntax idict dict_new Stype [, isglobal=0] idict dict_new Stype, isglobal, key0, value0, key1, value1, ... dict_new executes only at init time . NB : With the second variant it is possible to create a dict and give it initial values at init-time. Arguments Stype : a string describing the type of the key and the value. Possible values are: sf : string \u2192 float ss : string \u2192 string is : int \u2192 string if : int \u2192 float isglobal : if 1, the dict will outlive the instrument it was created in and will stay active until either the end of the performance or if destroyed via dict_free . Default is 0 (local) key0 , value0 , etc: initial pairs can be set at creation time, matching the types declared with Stype Output idict : identifies this dict with an integer. This integer can be passed around to another instrument and will always resolve to the same dict, as long as this dict is still alive. This can be checked via dict_query idict, \"exists\" Examples < CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > See also dict_free dict_set Credits","title":"dict_new"},{"location":"opcodes/dict_new.html#dict_new","text":"","title":"dict_new"},{"location":"opcodes/dict_new.html#abstract","text":"Create a hashtable","title":"Abstract"},{"location":"opcodes/dict_new.html#description","text":"A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. A hashtable can be either local, in which case its lifespan is fixed to the lifespan of the note it was created in; or it can be global, in which case it is not deallocated when the note is released and is kept alive until either the end of the performance, or until freed via dict_free","title":"Description"},{"location":"opcodes/dict_new.html#syntax","text":"idict dict_new Stype [, isglobal=0] idict dict_new Stype, isglobal, key0, value0, key1, value1, ... dict_new executes only at init time . NB : With the second variant it is possible to create a dict and give it initial values at init-time.","title":"Syntax"},{"location":"opcodes/dict_new.html#arguments","text":"Stype : a string describing the type of the key and the value. Possible values are: sf : string \u2192 float ss : string \u2192 string is : int \u2192 string if : int \u2192 float isglobal : if 1, the dict will outlive the instrument it was created in and will stay active until either the end of the performance or if destroyed via dict_free . Default is 0 (local) key0 , value0 , etc: initial pairs can be set at creation time, matching the types declared with Stype","title":"Arguments"},{"location":"opcodes/dict_new.html#output","text":"idict : identifies this dict with an integer. This integer can be passed around to another instrument and will always resolve to the same dict, as long as this dict is still alive. This can be checked via dict_query idict, \"exists\"","title":"Output"},{"location":"opcodes/dict_new.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_new.html#see-also","text":"dict_free dict_set","title":"See also"},{"location":"opcodes/dict_new.html#credits","text":"","title":"Credits"},{"location":"opcodes/dict_print.html","text":"dict_print Abstract Prints the contents of a dict Description dict_print can be used to print the contents of a dict, mostly for debugging purposes dict_print can print both at i-time or k-time Syntax dict_print idict [, ktrig=1] Arguments \u00ecdict : the handle of the dict, as returned by dict_new ktrig : when to print the dict. Printing will take place whenever ktrig is -1 or if ktrig is a positive and higher than the last trig Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" , \"foo\" , 10 , \"bar\" , 20 , \"baz\" , 30 print_dict i dict , 1 ; print with a metro i dict2 dict_new \"ss\" , \"foo\" , \"foofoo\" , \"bar\" , \"barbar\" , \"baz\" , \"bazbaz\" k trig metro 2 print_dict i dict2 , k trig turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer > See also dict_iter dict_set dict_query Credits Eduardo Moguillansky, 2019","title":"dict_print"},{"location":"opcodes/dict_print.html#dict_print","text":"","title":"dict_print"},{"location":"opcodes/dict_print.html#abstract","text":"Prints the contents of a dict","title":"Abstract"},{"location":"opcodes/dict_print.html#description","text":"dict_print can be used to print the contents of a dict, mostly for debugging purposes dict_print can print both at i-time or k-time","title":"Description"},{"location":"opcodes/dict_print.html#syntax","text":"dict_print idict [, ktrig=1]","title":"Syntax"},{"location":"opcodes/dict_print.html#arguments","text":"\u00ecdict : the handle of the dict, as returned by dict_new ktrig : when to print the dict. Printing will take place whenever ktrig is -1 or if ktrig is a positive and higher than the last trig","title":"Arguments"},{"location":"opcodes/dict_print.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" , \"foo\" , 10 , \"bar\" , 20 , \"baz\" , 30 print_dict i dict , 1 ; print with a metro i dict2 dict_new \"ss\" , \"foo\" , \"foofoo\" , \"bar\" , \"barbar\" , \"baz\" , \"bazbaz\" k trig metro 2 print_dict i dict2 , k trig turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_print.html#see-also","text":"dict_iter dict_set dict_query","title":"See also"},{"location":"opcodes/dict_print.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_query.html","text":"dict_query Abstract Query different properties of a dict Description Properties of a dict which do not need a separate opcode (because they are not used very frequently) are merged togehter in this opcode. Possible properties are: exists : return 1 if the handle points to a valid dict size : returns the size of this dict (similar to dict_size) type : returns an integer identifying the type of this dict 11 : number -> number 12 : number -> string 21 : string -> number 22 : string -> string keys : returns an array with all the keys defined in this dict (the type of the returned array depends on the type of the keys) values : returns an array with all the values (the type of the returned array depends on the type of the values). NB : the order in which keys and values are returned represents the corresponding pairs, so keys[i] and values[i] belong to the same pair. Syntax kexists dict_query idict, \"exists\" ksize dict_query idict, \"size\" ktype dict_query idict, \"type\" SKeys[] dict_query idict, \"keys\" kKeys[] dict_query idict, \"keys\" kValues[] dict_query idict, \"values\" SValues[] dict_query idict, \"values\" NB : the arrays returned from keys and values can have either an S- or a k-type, depending on the type definition of the array dict_query executes at k-time . Arguments idict : the handle of the dict, as returned by dict_new Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for dict_query ... dict_query idict, Scmd where Scmd can be: 'size', 'type', 'exists', 'keys', 'values' */ instr 1 ; get all the keys as an array i dict1 dict_new \"sf\" , 0 , \"keyA\" , 1 , \"keyB\" , 2 , \"keyC\" , 3 ; check that the dict exists k exists dict_query i dict1 , \"exists\" k type dict_query i dict1 , \"type\" printf \"dict exists = %d , type = %d \\n \" , 1 , k exists , k type S Keys [] dict_query i dict1 , \"keys\" printarray S Keys ; now check a bogus handle k exists999 dict_query 999 , \"exists\" printf \"dict 999 exists = %d \\n \" , 1 , k exists999 ; get the keys from a different dict i dict2 dict_new \"if\" , 0 , 1 , 100 , 10 , 1000 , 2 , 200 k Keys [] dict_query i dict2 , \"keys\" printarray k Keys , 1 , \" %.0f \" printf \"idict2 has size= %d \\n \" , 1 , dict_query ( i dict2 , \"size\" ) ; get values as an array i dict3 dict_new \"is\" , 0 , 10 , \"foo\" , 20 , \"bar\" , 30 , \"baz\" S vals [] dict_query i dict3 , \"values\" printarray S vals k Vals [] dict_query i dict2 , \"values\" printarray k Vals ; query the type of the dict k type dict_query i dict2 , \"type\" printf \"the type of dict %d is %d \\n \" , 1 , i dict2 , k type turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 </ CsScore > </ CsoundSynthesizer > See also dict_iter dict_size Credits Eduardo Moguillansky, 2019","title":"dict_query"},{"location":"opcodes/dict_query.html#dict_query","text":"","title":"dict_query"},{"location":"opcodes/dict_query.html#abstract","text":"Query different properties of a dict","title":"Abstract"},{"location":"opcodes/dict_query.html#description","text":"Properties of a dict which do not need a separate opcode (because they are not used very frequently) are merged togehter in this opcode. Possible properties are: exists : return 1 if the handle points to a valid dict size : returns the size of this dict (similar to dict_size) type : returns an integer identifying the type of this dict 11 : number -> number 12 : number -> string 21 : string -> number 22 : string -> string keys : returns an array with all the keys defined in this dict (the type of the returned array depends on the type of the keys) values : returns an array with all the values (the type of the returned array depends on the type of the values). NB : the order in which keys and values are returned represents the corresponding pairs, so keys[i] and values[i] belong to the same pair.","title":"Description"},{"location":"opcodes/dict_query.html#syntax","text":"kexists dict_query idict, \"exists\" ksize dict_query idict, \"size\" ktype dict_query idict, \"type\" SKeys[] dict_query idict, \"keys\" kKeys[] dict_query idict, \"keys\" kValues[] dict_query idict, \"values\" SValues[] dict_query idict, \"values\" NB : the arrays returned from keys and values can have either an S- or a k-type, depending on the type definition of the array dict_query executes at k-time .","title":"Syntax"},{"location":"opcodes/dict_query.html#arguments","text":"idict : the handle of the dict, as returned by dict_new","title":"Arguments"},{"location":"opcodes/dict_query.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for dict_query ... dict_query idict, Scmd where Scmd can be: 'size', 'type', 'exists', 'keys', 'values' */ instr 1 ; get all the keys as an array i dict1 dict_new \"sf\" , 0 , \"keyA\" , 1 , \"keyB\" , 2 , \"keyC\" , 3 ; check that the dict exists k exists dict_query i dict1 , \"exists\" k type dict_query i dict1 , \"type\" printf \"dict exists = %d , type = %d \\n \" , 1 , k exists , k type S Keys [] dict_query i dict1 , \"keys\" printarray S Keys ; now check a bogus handle k exists999 dict_query 999 , \"exists\" printf \"dict 999 exists = %d \\n \" , 1 , k exists999 ; get the keys from a different dict i dict2 dict_new \"if\" , 0 , 1 , 100 , 10 , 1000 , 2 , 200 k Keys [] dict_query i dict2 , \"keys\" printarray k Keys , 1 , \" %.0f \" printf \"idict2 has size= %d \\n \" , 1 , dict_query ( i dict2 , \"size\" ) ; get values as an array i dict3 dict_new \"is\" , 0 , 10 , \"foo\" , 20 , \"bar\" , 30 , \"baz\" S vals [] dict_query i dict3 , \"values\" printarray S vals k Vals [] dict_query i dict2 , \"values\" printarray k Vals ; query the type of the dict k type dict_query i dict2 , \"type\" printf \"the type of dict %d is %d \\n \" , 1 , i dict2 , k type turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_query.html#see-also","text":"dict_iter dict_size","title":"See also"},{"location":"opcodes/dict_query.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_set.html","text":"dict_set Abstract Set (or remove) a value from a hashtable Description A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_set sets the value corresponding to a key if the key is already present, or inserts a key:value pair otherwise. Without a value it deletes the key:value pair from the dict. Syntax dict_set idict, xkey, xvalue dict_set idict, xkey If xvalue is not given, dict_set removes the key from the dict dict_get executes both at i-time and k-time . NB : it is possible to set multiple values at i-time directly with dict_new Arguments idict : the handle of the dict, as returned by dict_new xkey : the key to set. Its type must match the type definition of the dict. (a string or a possitive integer) xvalue : the value to set. Its type must match the type definition of the dict (a str or a numeric value) Examples < CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > See also dict_new dict_get Credits Eduardo Moguillansky, 2019","title":"dict_set"},{"location":"opcodes/dict_set.html#dict_set","text":"","title":"dict_set"},{"location":"opcodes/dict_set.html#abstract","text":"Set (or remove) a value from a hashtable","title":"Abstract"},{"location":"opcodes/dict_set.html#description","text":"A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_set sets the value corresponding to a key if the key is already present, or inserts a key:value pair otherwise. Without a value it deletes the key:value pair from the dict.","title":"Description"},{"location":"opcodes/dict_set.html#syntax","text":"dict_set idict, xkey, xvalue dict_set idict, xkey If xvalue is not given, dict_set removes the key from the dict dict_get executes both at i-time and k-time . NB : it is possible to set multiple values at i-time directly with dict_new","title":"Syntax"},{"location":"opcodes/dict_set.html#arguments","text":"idict : the handle of the dict, as returned by dict_new xkey : the key to set. Its type must match the type definition of the dict. (a string or a possitive integer) xvalue : the value to set. Its type must match the type definition of the dict (a str or a numeric value)","title":"Arguments"},{"location":"opcodes/dict_set.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_set.html#see-also","text":"dict_new dict_get","title":"See also"},{"location":"opcodes/dict_set.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_size.html","text":"dict_size Abstract Returns the number of key:value pairs in a dict Description A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_size returns the number of such key:value pairs inside a dict. If the handle passed does not point to a valid dict, dict_size returns -1. It is thus possible to use it to check that the passed handle is valid (similar to dict_query idict \"exists\" , see dict_query ) dict_size can be used together with dict_iter to iterate over the key:value pairs Syntax ksize dict_size idict dict_size executes both at i-time and k-time . Arguments \u00ecdict : the handle of the dict, as returned by dict_new Output ksize : the number of key:value pairs in the dict Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size dict_set i dict , \"foo\" , 4 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size ; size does not change now dict_set i dict , \"foo\" , 10 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size ; we delete a key, size is reduced dict_set i dict , \"foo\" k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer > See also dict_iter dict_set Credits Eduardo Moguillansky, 2019","title":"dict_size"},{"location":"opcodes/dict_size.html#dict_size","text":"","title":"dict_size"},{"location":"opcodes/dict_size.html#abstract","text":"Returns the number of key:value pairs in a dict","title":"Abstract"},{"location":"opcodes/dict_size.html#description","text":"A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_size returns the number of such key:value pairs inside a dict. If the handle passed does not point to a valid dict, dict_size returns -1. It is thus possible to use it to check that the passed handle is valid (similar to dict_query idict \"exists\" , see dict_query ) dict_size can be used together with dict_iter to iterate over the key:value pairs","title":"Description"},{"location":"opcodes/dict_size.html#syntax","text":"ksize dict_size idict dict_size executes both at i-time and k-time .","title":"Syntax"},{"location":"opcodes/dict_size.html#arguments","text":"\u00ecdict : the handle of the dict, as returned by dict_new","title":"Arguments"},{"location":"opcodes/dict_size.html#output","text":"ksize : the number of key:value pairs in the dict","title":"Output"},{"location":"opcodes/dict_size.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size dict_set i dict , \"foo\" , 4 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size ; size does not change now dict_set i dict , \"foo\" , 10 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size ; we delete a key, size is reduced dict_set i dict , \"foo\" k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_size.html#see-also","text":"dict_iter dict_set","title":"See also"},{"location":"opcodes/dict_size.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/poly.html","text":"poly Abstract poly creates and controls multiple parallel version of an opcode Description poly creates a user given number of instances of an opcode, each with its own state, inputs and outputs. The resulting output is an array where each element holds the output of the corresponding instance. In general, an opcode has a signature, given by the number and types of its output and input arguments. For example, the opcode oscili as used like aout oscili kamp, kfreq has a signature a / kk ( a as output, kk as input). To follow this example, to create 10 parallel versions of this opcode (an oscillator bank) it is possible to use poly like this: k Freqs [] fillarray 100 , 110 , 200 , 220 , 300 , 330 , 400 , 440 , 500 , 550 a Out [] poly 10 , \"oscili\" , 0.1 , k Freqs Notice that it is possible to set one value for each instance, as given by kFreqs , or one value to be shared by all instances, as given by the amplitude 0.1 . By changing the array kFreqs it is possible to modify the frequency of each oscillator. It is of course possible to chain multiple poly s to generate complex effect chains, and poly can also be used with k-values. NB : At the moment poly works only with builtin opcodes . This might change in the future Syntax out1[], [ out2[], ... ] poly inuminstances, Sopcode, xarg0, [xarg1, ...] Arguments inuminstances : the number of instances of Sopcode to instantiate Sopcode : the name of the opcode xargs : any number of arguments, either i-, k- or a-rate, either scalar or arrays, as needed by the given opcode The number and type of the input arguments depend on the arguments passed to the given opcode. The same applies for the output arguments NB : output arguments are always arrays, input arguments can be arrays, in which case they must be at least the size of inuminstances , or scalars, in which case the same value is shared by multiple instances Output The output is one or more arrays of k- or a-type, corresponding to the opcode. For instance, an opcode like aout oscili 0.1, kfreq will output an array of audio channels. An opcode like pan2 will output two audio arrays. Examples LISTEN < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 0dbfs = 1 ; create an array of random values between 0-1 ; inum: number of elements in the array opcode rndarr , i[] , i i num xin i Out [] init i num i 0 = 0 while i 0 < i num do i Out [ i 0 ] = unirand ( 1 ) i 0 += 1 od xout i Out endop ; multiple oscillators, mixed down to mono instr 1 ; number of oscillators i num = 100 ; fundamental k midi = line ( ntom : i ( \"2G\" ), p3 , ntom : i ( \"1C\" )) k f0 = mtof ( k midi ) ; each oscillator is an overtone of f0 k Ratios [] genarray_i 1 , i num ; harmonicity over time k exp line 1 , p3 , 1.32 ; the freq. of each oscillator k Freqs [] = ( k Ratios ^ k exp ) * k f0 ; array of random phases, to avoid synchronous start i Phs [] rndarr i num ; generate the oscillators. a Oscils [] poly i num , \"oscili\" , 1 / i num , k Freqs , - 1 , i Phs a mono sumarray a Oscils a mono *= linsegr : a ( 0 , 0.05 , 1 , 0.05 , 0 ) outs a mono , a mono endin ; poly instances stacked as a processing pipe instr 2 ; amount of polyphony i num = 30 i Freqs [] rndarr i num ; the ratios of the overtones k Ratios [] genarray_i 1 , i num ; a down gliss k m0 linseg ntom : i ( \"2C\" ), p3 * 0.8 , ntom : i ( \"1C\" ) k f0 = mtof ( k m0 ) ; harmonicity curve k p linsegb 1 , p3 * 0.8 , 1.68 ; calculate actual freqs. k Freqs [] = ( k Ratios ^ k p ) * k f0 ; lfo freqs. used for AM and panning k f linsegb 0.1 , p3 * 0.62 , 0.8 , p3 * 0.8 , 0.8 , p3 * 0.96 , 12 , p3 , 60 k LfoFreqs [] = i Freqs * k f ; multiple noise instances, amplitude modulated a A [] poly i num , \"noise\" , 0.5 , 0.3 a Amps [] poly i num , \"oscili\" , 1 , k LfoFreqs * 0.6 a A *= a Amps ; filter noise with bandpass k Q linsegb 0.5 , p3 * 0.5 , 0.02 , p3 , 0.0001 k Bands [] = k Freqs * k Q a B [] poly i num , \"resonr\" , a A , k Freqs , k Bands ; panning. poly works also with k-rate and with ; opcodes producing multiple outputs, like pan2 k PanPos [] poly i num , \"lfo\" , 0.5 , k LfoFreqs k PanPos += 0.5 ; lfo in the range 0-1 for panning a L [], a R [] poly i num , \"pan2\" , a B , k PanPos a left sumarray a L a right sumarray a R ; compress / fade a ref init 1 a sig = 0.707 * ( a left + a right ) a gain compress2 a ref , a sig , - 90 , - 48 , - 24 , 2.5 , 0.05 , 0.2 , 0.05 a left *= a gain a right *= a gain a gain2 compress2 a ref , ( a left + a right ) * 0.707 , - 90 , - 6 , - 3 , 20 , 0.002 , 0.010 , 0.02 a env = a gain2 * cossegr : a ( 0 , 1 , 1 , 0.1 , 0 ) outs a left * a env , a right * a env endin opcode test , a , k k freq xin a out oscili 0.1 , k freq xout a out endop instr 3 ; test udo k freqs [] fillarray 440 , 443 a A [] poly 2 , \"test\" , k freqs a 0 sumarray a A outs a 0 , a 0 endin </ CsInstruments > < CsScore > i 1 0 8 i 2 9 50 ; i 3 0 1 </ CsScore > </ CsoundSynthesizer > See also maparray polyseq Credits Eduardo Moguillansky, 2019","title":"poly"},{"location":"opcodes/poly.html#poly","text":"","title":"poly"},{"location":"opcodes/poly.html#abstract","text":"poly creates and controls multiple parallel version of an opcode","title":"Abstract"},{"location":"opcodes/poly.html#description","text":"poly creates a user given number of instances of an opcode, each with its own state, inputs and outputs. The resulting output is an array where each element holds the output of the corresponding instance. In general, an opcode has a signature, given by the number and types of its output and input arguments. For example, the opcode oscili as used like aout oscili kamp, kfreq has a signature a / kk ( a as output, kk as input). To follow this example, to create 10 parallel versions of this opcode (an oscillator bank) it is possible to use poly like this: k Freqs [] fillarray 100 , 110 , 200 , 220 , 300 , 330 , 400 , 440 , 500 , 550 a Out [] poly 10 , \"oscili\" , 0.1 , k Freqs Notice that it is possible to set one value for each instance, as given by kFreqs , or one value to be shared by all instances, as given by the amplitude 0.1 . By changing the array kFreqs it is possible to modify the frequency of each oscillator. It is of course possible to chain multiple poly s to generate complex effect chains, and poly can also be used with k-values. NB : At the moment poly works only with builtin opcodes . This might change in the future","title":"Description"},{"location":"opcodes/poly.html#syntax","text":"out1[], [ out2[], ... ] poly inuminstances, Sopcode, xarg0, [xarg1, ...]","title":"Syntax"},{"location":"opcodes/poly.html#arguments","text":"inuminstances : the number of instances of Sopcode to instantiate Sopcode : the name of the opcode xargs : any number of arguments, either i-, k- or a-rate, either scalar or arrays, as needed by the given opcode The number and type of the input arguments depend on the arguments passed to the given opcode. The same applies for the output arguments NB : output arguments are always arrays, input arguments can be arrays, in which case they must be at least the size of inuminstances , or scalars, in which case the same value is shared by multiple instances","title":"Arguments"},{"location":"opcodes/poly.html#output","text":"The output is one or more arrays of k- or a-type, corresponding to the opcode. For instance, an opcode like aout oscili 0.1, kfreq will output an array of audio channels. An opcode like pan2 will output two audio arrays.","title":"Output"},{"location":"opcodes/poly.html#examples","text":"LISTEN < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 0dbfs = 1 ; create an array of random values between 0-1 ; inum: number of elements in the array opcode rndarr , i[] , i i num xin i Out [] init i num i 0 = 0 while i 0 < i num do i Out [ i 0 ] = unirand ( 1 ) i 0 += 1 od xout i Out endop ; multiple oscillators, mixed down to mono instr 1 ; number of oscillators i num = 100 ; fundamental k midi = line ( ntom : i ( \"2G\" ), p3 , ntom : i ( \"1C\" )) k f0 = mtof ( k midi ) ; each oscillator is an overtone of f0 k Ratios [] genarray_i 1 , i num ; harmonicity over time k exp line 1 , p3 , 1.32 ; the freq. of each oscillator k Freqs [] = ( k Ratios ^ k exp ) * k f0 ; array of random phases, to avoid synchronous start i Phs [] rndarr i num ; generate the oscillators. a Oscils [] poly i num , \"oscili\" , 1 / i num , k Freqs , - 1 , i Phs a mono sumarray a Oscils a mono *= linsegr : a ( 0 , 0.05 , 1 , 0.05 , 0 ) outs a mono , a mono endin ; poly instances stacked as a processing pipe instr 2 ; amount of polyphony i num = 30 i Freqs [] rndarr i num ; the ratios of the overtones k Ratios [] genarray_i 1 , i num ; a down gliss k m0 linseg ntom : i ( \"2C\" ), p3 * 0.8 , ntom : i ( \"1C\" ) k f0 = mtof ( k m0 ) ; harmonicity curve k p linsegb 1 , p3 * 0.8 , 1.68 ; calculate actual freqs. k Freqs [] = ( k Ratios ^ k p ) * k f0 ; lfo freqs. used for AM and panning k f linsegb 0.1 , p3 * 0.62 , 0.8 , p3 * 0.8 , 0.8 , p3 * 0.96 , 12 , p3 , 60 k LfoFreqs [] = i Freqs * k f ; multiple noise instances, amplitude modulated a A [] poly i num , \"noise\" , 0.5 , 0.3 a Amps [] poly i num , \"oscili\" , 1 , k LfoFreqs * 0.6 a A *= a Amps ; filter noise with bandpass k Q linsegb 0.5 , p3 * 0.5 , 0.02 , p3 , 0.0001 k Bands [] = k Freqs * k Q a B [] poly i num , \"resonr\" , a A , k Freqs , k Bands ; panning. poly works also with k-rate and with ; opcodes producing multiple outputs, like pan2 k PanPos [] poly i num , \"lfo\" , 0.5 , k LfoFreqs k PanPos += 0.5 ; lfo in the range 0-1 for panning a L [], a R [] poly i num , \"pan2\" , a B , k PanPos a left sumarray a L a right sumarray a R ; compress / fade a ref init 1 a sig = 0.707 * ( a left + a right ) a gain compress2 a ref , a sig , - 90 , - 48 , - 24 , 2.5 , 0.05 , 0.2 , 0.05 a left *= a gain a right *= a gain a gain2 compress2 a ref , ( a left + a right ) * 0.707 , - 90 , - 6 , - 3 , 20 , 0.002 , 0.010 , 0.02 a env = a gain2 * cossegr : a ( 0 , 1 , 1 , 0.1 , 0 ) outs a left * a env , a right * a env endin opcode test , a , k k freq xin a out oscili 0.1 , k freq xout a out endop instr 3 ; test udo k freqs [] fillarray 440 , 443 a A [] poly 2 , \"test\" , k freqs a 0 sumarray a A outs a 0 , a 0 endin </ CsInstruments > < CsScore > i 1 0 8 i 2 9 50 ; i 3 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/poly.html#see-also","text":"maparray polyseq","title":"See also"},{"location":"opcodes/poly.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/polyseq.html","text":"polyseq Abstract polyseq creates and controls multiple sequential version of an opcode Description polyseq creates a user given number of instances of an opcode, each with its own state. The output of an instance is routed to the input of the next instance, forming a chain. Each instance can be controlled individually. We differentiate between chained and multiplexed arguments. chained arguments are the ones which are mapped from one opcode instance to the next, so that the output of one instance is routed to the input of the next. multiplexed are passed after the chained arguments and work as they do with poly : if an array is passed, then each instance is delivered one element of this array, and if a scalar value is passed, then all instances share the same argument. Example All this is best explained with an example: ; these two signal chains produce the same result a 0 pinker k Freqs [] fillarray 100 , 150 , 300 , 330 a eq rbjeq a 0 , k Freqs [ 0 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 1 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 2 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 3 ], 2 , 10 , 1 , 8 a seq polyseq 4 , \"rbjeq\" , a 0 , k Freqs , 2 , 10 , 1 , 8 Syntax xouts polyseq numinstances:i, opcodename:s, xins, params ... polyseq can have any number of inputs and outputs, as long as the opcode used has matching inputs and outputs. Arguments inuminstances : the number of instances of Sopcode to instantiate Sopcode : the name of the opcode xins : any number of arguments, either k- or a-rate, which should correspond to the outputs of the opcode The number and type of the input arguments depend on the arguments passed to the given opcode. The same applies for the output arguments Output xouts : any number of arguments of type k or a , as output by the opcode Examples LISTEN < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 0dbfs = 1 ; Example file for polyseq instr 1 ; A simple parametric eq. ; On the left channel, the reference signal, ; on the right, the polyseq implementation. ; These should be the same a 0 pinker a 0 *= ampdb ( - 12 ) k Freqs [] fillarray 400 , 1400 , 3000 , 4400 , 8000 , 12000 k Qs [] fillarray 10 , 20 , 10 , 20 , 10 , 20 k V = ampdb ( 18 ) a ref = a 0 a ref rbjeq a ref , k Freqs [ 0 ], k V , k Qs [ 0 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 1 ], k V , k Qs [ 1 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 2 ], k V , k Qs [ 2 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 3 ], k V , k Qs [ 3 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 4 ], k V , k Qs [ 4 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 5 ], k V , k Qs [ 5 ], 1 , 8 a seq polyseq lenarray ( k Freqs ), \"rbjeq\" , a 0 , k Freqs , k V , k Qs , 1 , 8 outs a ref , a seq endin opcode rndarr , i[] , iii i num , i min , i max xin i Out [] init i num i 0 = 0 i delta = i max - i min while i 0 < i num do i Out [ i 0 ] = i min + unirand ( i delta ) i 0 += 1 od xout i Out endop instr 2 ; two varying eqs a 0 = pinker () * ampdb ( - 8 ) k Freqs0 [] fillarray 50 , 130 , 400 , 500 , 1400 , 3000 , 4400 , 5000 , 8000 i num lenarray k Freqs0 i Freqslfo [] rndarr i num , 0.05 , 0.4 k Lfos [] poly i num , \"lfo\" , 0.1 , i Freqslfo k FreqsL [] = k Freqs0 * ( 1 + k Lfos ) k FreqsR [] = k Freqs0 * ( 1 + k Lfos * 1.62 ) k Qs [] poly i num , \"lfo\" , 5 , i Freqslfo * 1.5 k Qs += 7.5 a eqL polyseq i num , \"rbjeq\" , a 0 , k FreqsL , ampdb ( 10 ), k Qs , 1 , 8 a eqR polyseq i num , \"rbjeq\" , a 0 , k FreqsR , ampdb ( 12 ), k Qs * 1.5 , 1 , 8 ; declick a env = linsegr ( 0 , 0.5 , 1 , 0.5 , 0 ) outs a eqL * a env , a eqR * a env endin </ CsInstruments > < CsScore > i 1 0 5 i 2 5 20 </ CsScore > </ CsoundSynthesizer > See also maparray poly Credits Eduardo Moguillansky, 2019","title":"polyseq"},{"location":"opcodes/polyseq.html#polyseq","text":"","title":"polyseq"},{"location":"opcodes/polyseq.html#abstract","text":"polyseq creates and controls multiple sequential version of an opcode","title":"Abstract"},{"location":"opcodes/polyseq.html#description","text":"polyseq creates a user given number of instances of an opcode, each with its own state. The output of an instance is routed to the input of the next instance, forming a chain. Each instance can be controlled individually. We differentiate between chained and multiplexed arguments. chained arguments are the ones which are mapped from one opcode instance to the next, so that the output of one instance is routed to the input of the next. multiplexed are passed after the chained arguments and work as they do with poly : if an array is passed, then each instance is delivered one element of this array, and if a scalar value is passed, then all instances share the same argument.","title":"Description"},{"location":"opcodes/polyseq.html#example","text":"All this is best explained with an example: ; these two signal chains produce the same result a 0 pinker k Freqs [] fillarray 100 , 150 , 300 , 330 a eq rbjeq a 0 , k Freqs [ 0 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 1 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 2 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 3 ], 2 , 10 , 1 , 8 a seq polyseq 4 , \"rbjeq\" , a 0 , k Freqs , 2 , 10 , 1 , 8","title":"Example"},{"location":"opcodes/polyseq.html#syntax","text":"xouts polyseq numinstances:i, opcodename:s, xins, params ... polyseq can have any number of inputs and outputs, as long as the opcode used has matching inputs and outputs.","title":"Syntax"},{"location":"opcodes/polyseq.html#arguments","text":"inuminstances : the number of instances of Sopcode to instantiate Sopcode : the name of the opcode xins : any number of arguments, either k- or a-rate, which should correspond to the outputs of the opcode The number and type of the input arguments depend on the arguments passed to the given opcode. The same applies for the output arguments","title":"Arguments"},{"location":"opcodes/polyseq.html#output","text":"xouts : any number of arguments of type k or a , as output by the opcode","title":"Output"},{"location":"opcodes/polyseq.html#examples","text":"LISTEN < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 0dbfs = 1 ; Example file for polyseq instr 1 ; A simple parametric eq. ; On the left channel, the reference signal, ; on the right, the polyseq implementation. ; These should be the same a 0 pinker a 0 *= ampdb ( - 12 ) k Freqs [] fillarray 400 , 1400 , 3000 , 4400 , 8000 , 12000 k Qs [] fillarray 10 , 20 , 10 , 20 , 10 , 20 k V = ampdb ( 18 ) a ref = a 0 a ref rbjeq a ref , k Freqs [ 0 ], k V , k Qs [ 0 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 1 ], k V , k Qs [ 1 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 2 ], k V , k Qs [ 2 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 3 ], k V , k Qs [ 3 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 4 ], k V , k Qs [ 4 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 5 ], k V , k Qs [ 5 ], 1 , 8 a seq polyseq lenarray ( k Freqs ), \"rbjeq\" , a 0 , k Freqs , k V , k Qs , 1 , 8 outs a ref , a seq endin opcode rndarr , i[] , iii i num , i min , i max xin i Out [] init i num i 0 = 0 i delta = i max - i min while i 0 < i num do i Out [ i 0 ] = i min + unirand ( i delta ) i 0 += 1 od xout i Out endop instr 2 ; two varying eqs a 0 = pinker () * ampdb ( - 8 ) k Freqs0 [] fillarray 50 , 130 , 400 , 500 , 1400 , 3000 , 4400 , 5000 , 8000 i num lenarray k Freqs0 i Freqslfo [] rndarr i num , 0.05 , 0.4 k Lfos [] poly i num , \"lfo\" , 0.1 , i Freqslfo k FreqsL [] = k Freqs0 * ( 1 + k Lfos ) k FreqsR [] = k Freqs0 * ( 1 + k Lfos * 1.62 ) k Qs [] poly i num , \"lfo\" , 5 , i Freqslfo * 1.5 k Qs += 7.5 a eqL polyseq i num , \"rbjeq\" , a 0 , k FreqsL , ampdb ( 10 ), k Qs , 1 , 8 a eqR polyseq i num , \"rbjeq\" , a 0 , k FreqsR , ampdb ( 12 ), k Qs * 1.5 , 1 , 8 ; declick a env = linsegr ( 0 , 0.5 , 1 , 0.5 , 0 ) outs a eqL * a env , a eqR * a env endin </ CsInstruments > < CsScore > i 1 0 5 i 2 5 20 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/polyseq.html#see-also","text":"maparray poly","title":"See also"},{"location":"opcodes/polyseq.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"}]}