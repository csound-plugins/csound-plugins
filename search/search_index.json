{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Csound Plugins Welcome to the csound-plugins wiki! This is a collection of plugins for csound Installation See Installation klib A hashtable for csound dict_new : Create a hashtable dict_dump : Dumps the contents of this dict as a string dict_free : Free a hashtable dict_get : Get a value from a hashtable dict_geti : Get a string value from a hashtable at init time dict_loadstr : Creates and fills a new dict from a string definition dict_set : Set a value from a hashtable dict_size : Returns the number of key:value pairs in a dict dict_query : Query different properties of a dict dict_exists : Returns 1 if the dict exists, 0 otherwise dict_print : Prints the contents of a dict dict_iter : Iterate over the key-value pairs of a dict dict_del : Remove a key:value pair from a hashtable sref : Insert a string into a global registry and return a reference to it sderef : Retrieves a read-only string from the cache pool_new : Create an empty pool pool_gen : Create a pool and fill it with values pool_pop : Pop (get) an item from a pool pool_push : Push an item into a pool pool_size : Returns the size of a pool pool_capacity : Returns the capacity of a pool pool_at : Returns the item of a pool at a given index pool_isfull : Returns 1 if the pool is full rory Miscellaneous opcodes for channel state save, triggers and others trigLinseg : Trace a series of line segments between specified points. trigExpseg : Trace a series of exponential segments between specified points. channelStateSave : Saves all channel data to file channelStateRecall : Recalls channel data saved to a file via channelStateSave poly Multiple (parallel or sequential) instances of an opcode poly : poly creates and controls multiple parallel version of an opcode polyseq : polyseq creates and controls multiple sequential version of an opcode poly0 : poly0 creates and controls multiple parallel version of an opcode with no outputs defer : Run an opcode at the end of current event jsfx A csound interface to the opensource implementation of jsfx (a jitted language for dsp) jsfx : Instantiates and runs a jsfx script jsfx_new : Instantiates a jsfx script jsfx_play : Processes audio through a jsfx script jsfx_getslider : Gets a slider value of a jsfx instance jsfx_setslider : Sets the slider values of a jsfx script tubeharmonics : A distortion with control for odd/even harmonics else Collection of miscellaneous plugins accum : Simple accumulator of scalar values atstop : Schedule an instrument at the end of the current instrument bisect : Returns the fractional index of a value within a sorted array / tab crackle : generates noise based on a chaotic equation defer : Run an opcode at the end of an event deref : Dereference a previously created reference to a variable diode_ringmod : A ring modulator with optional non-linearities extendarray : Extend one array with the contents of a second array, in place fileexists : Returns 1 if a file exists and can be read findarray : Find an element in an array frac2int : Convert the fractional part of a number into an integer ftfill : create a table and fill it with values (like fillarray but for f-tables) ftfind : Find an element in a table ftnew : creates a new table of a given size ftsetparams : Set metadata parameters of a table, as if it was loaded via GEN1 initerror : Throws an error message at init interp1d : Interpolate between elements of an array/table lfnoise : low frequency, band-limited noise linenv : A triggerable linear envelope with sustain segment loadnpy : Load an array (of any number of dimensions) saved as a .npy file memview : Create a view into a table or another array perlin3 : gradient noise sound generator pread : Read pfield values from any active instrument instance pwrite : Modify pfield values of an active instrument instance ramptrig : A triggerable ramp between 0 and 1 ref : Get a reference to a variable refvalid : Queries if a reference is valid schmitt : A schmitt trigger (a comparator with hysteresis). setslice : Set a slice of an array to a given value sigmdrive : Analog \"soft clipping\" distortion by applying non-linear transfer functions. standardchaos : Standard map chaotic generator throwerror : Throws an error message at performance or init uniqinstance : Return an fractional instrument number which is not in use zeroarray : Zero all elements in an array pathtools Cross-platform path handling findFileInPath : Find a file inside the search paths of the csound environment getEnvVar : Get the value of an environment variable pathAbsolute : Returns the absolute path of a file pathIsAbsolute : Returns 1 if the path of a file is absolute pathJoin : Join two parts of a path according to the current platform pathNative : Convert a path to its native version pathSplit : Split a path into directory and basename pathSplitk : Split a path into directory and basename at perf-time pathSplitExt : Split a path into prefix and extension pathSplitExtk : Split a path into prefix and extension at performance time scriptDir : Get the directory of the loaded orc/csd file sysPlatform : Get a string description of the current system platform strsplit : Split a string at a given separator sfreadmeta : Read metadata from a soundfile","title":"Csound Plugins"},{"location":"index.html#csound-plugins","text":"Welcome to the csound-plugins wiki! This is a collection of plugins for csound","title":"Csound Plugins"},{"location":"index.html#installation","text":"See Installation","title":"Installation"},{"location":"index.html#klib","text":"A hashtable for csound dict_new : Create a hashtable dict_dump : Dumps the contents of this dict as a string dict_free : Free a hashtable dict_get : Get a value from a hashtable dict_geti : Get a string value from a hashtable at init time dict_loadstr : Creates and fills a new dict from a string definition dict_set : Set a value from a hashtable dict_size : Returns the number of key:value pairs in a dict dict_query : Query different properties of a dict dict_exists : Returns 1 if the dict exists, 0 otherwise dict_print : Prints the contents of a dict dict_iter : Iterate over the key-value pairs of a dict dict_del : Remove a key:value pair from a hashtable sref : Insert a string into a global registry and return a reference to it sderef : Retrieves a read-only string from the cache pool_new : Create an empty pool pool_gen : Create a pool and fill it with values pool_pop : Pop (get) an item from a pool pool_push : Push an item into a pool pool_size : Returns the size of a pool pool_capacity : Returns the capacity of a pool pool_at : Returns the item of a pool at a given index pool_isfull : Returns 1 if the pool is full","title":"klib"},{"location":"index.html#rory","text":"Miscellaneous opcodes for channel state save, triggers and others trigLinseg : Trace a series of line segments between specified points. trigExpseg : Trace a series of exponential segments between specified points. channelStateSave : Saves all channel data to file channelStateRecall : Recalls channel data saved to a file via channelStateSave","title":"rory"},{"location":"index.html#poly","text":"Multiple (parallel or sequential) instances of an opcode poly : poly creates and controls multiple parallel version of an opcode polyseq : polyseq creates and controls multiple sequential version of an opcode poly0 : poly0 creates and controls multiple parallel version of an opcode with no outputs defer : Run an opcode at the end of current event","title":"poly"},{"location":"index.html#jsfx","text":"A csound interface to the opensource implementation of jsfx (a jitted language for dsp) jsfx : Instantiates and runs a jsfx script jsfx_new : Instantiates a jsfx script jsfx_play : Processes audio through a jsfx script jsfx_getslider : Gets a slider value of a jsfx instance jsfx_setslider : Sets the slider values of a jsfx script tubeharmonics : A distortion with control for odd/even harmonics","title":"jsfx"},{"location":"index.html#else","text":"Collection of miscellaneous plugins accum : Simple accumulator of scalar values atstop : Schedule an instrument at the end of the current instrument bisect : Returns the fractional index of a value within a sorted array / tab crackle : generates noise based on a chaotic equation defer : Run an opcode at the end of an event deref : Dereference a previously created reference to a variable diode_ringmod : A ring modulator with optional non-linearities extendarray : Extend one array with the contents of a second array, in place fileexists : Returns 1 if a file exists and can be read findarray : Find an element in an array frac2int : Convert the fractional part of a number into an integer ftfill : create a table and fill it with values (like fillarray but for f-tables) ftfind : Find an element in a table ftnew : creates a new table of a given size ftsetparams : Set metadata parameters of a table, as if it was loaded via GEN1 initerror : Throws an error message at init interp1d : Interpolate between elements of an array/table lfnoise : low frequency, band-limited noise linenv : A triggerable linear envelope with sustain segment loadnpy : Load an array (of any number of dimensions) saved as a .npy file memview : Create a view into a table or another array perlin3 : gradient noise sound generator pread : Read pfield values from any active instrument instance pwrite : Modify pfield values of an active instrument instance ramptrig : A triggerable ramp between 0 and 1 ref : Get a reference to a variable refvalid : Queries if a reference is valid schmitt : A schmitt trigger (a comparator with hysteresis). setslice : Set a slice of an array to a given value sigmdrive : Analog \"soft clipping\" distortion by applying non-linear transfer functions. standardchaos : Standard map chaotic generator throwerror : Throws an error message at performance or init uniqinstance : Return an fractional instrument number which is not in use zeroarray : Zero all elements in an array","title":"else"},{"location":"index.html#pathtools","text":"Cross-platform path handling findFileInPath : Find a file inside the search paths of the csound environment getEnvVar : Get the value of an environment variable pathAbsolute : Returns the absolute path of a file pathIsAbsolute : Returns 1 if the path of a file is absolute pathJoin : Join two parts of a path according to the current platform pathNative : Convert a path to its native version pathSplit : Split a path into directory and basename pathSplitk : Split a path into directory and basename at perf-time pathSplitExt : Split a path into prefix and extension pathSplitExtk : Split a path into prefix and extension at performance time scriptDir : Get the directory of the loaded orc/csd file sysPlatform : Get a string description of the current system platform strsplit : Split a string at a given separator sfreadmeta : Read metadata from a soundfile","title":"pathtools"},{"location":"Contributing.html","text":"Contributing To submit an opcode clone this repository and make a pull request Organisation An opcode is normally implemented as part of a library, to allow for different versions and related opcodes to share functionality. Each library lives in its own directory. The tree can be structured as follows: mylib/ CMakeLists.txt manifest.json [ README.md ] src/ mylib.c examples/ foo.csd bar.csd docs/ foo.md bar.md For each opcode defined in mylib.c there should be an example opcode.csd and a manual page opcode.md . Optionally it is possible to include a README.md where a short description of the opcodes in this library is given Put your tree under src and you should be able to build your plugin. Build We use cmake as a build tool. For simple opcodes with no extra dependencies, a simple CMakeLists.txt would suffice: make_plugin(mylib src/mylib.c) Installation At the root folder of this repository, do mkdir build cd build cmake .. make sudo make install Manifest A manifest is used to automate documentation of the opcodes (wiki, pdf documentation, etc). The manifest is a .json file. It should have the minimal form: { \"name\" : \"mylib\" , \"opcodes\" : [ \"foo\" , \"bar\" ], \"author\" : \"name\" , \"author_email\" : \"name@email.com\" , \"license\" : \"LGPL\" , \"description\" : \"Description of this package\" , \"url\" : \"http://github.com/...\" } In this case, three opcodes are defined, and these names should correspond to the .csd example living inside of the examples folder, and a .md file living inside the docs folder.","title":"Contributing"},{"location":"Contributing.html#contributing","text":"To submit an opcode clone this repository and make a pull request","title":"Contributing"},{"location":"Contributing.html#organisation","text":"An opcode is normally implemented as part of a library, to allow for different versions and related opcodes to share functionality. Each library lives in its own directory. The tree can be structured as follows: mylib/ CMakeLists.txt manifest.json [ README.md ] src/ mylib.c examples/ foo.csd bar.csd docs/ foo.md bar.md For each opcode defined in mylib.c there should be an example opcode.csd and a manual page opcode.md . Optionally it is possible to include a README.md where a short description of the opcodes in this library is given Put your tree under src and you should be able to build your plugin.","title":"Organisation"},{"location":"Contributing.html#build","text":"We use cmake as a build tool. For simple opcodes with no extra dependencies, a simple CMakeLists.txt would suffice: make_plugin(mylib src/mylib.c)","title":"Build"},{"location":"Contributing.html#installation","text":"At the root folder of this repository, do mkdir build cd build cmake .. make sudo make install","title":"Installation"},{"location":"Contributing.html#manifest","text":"A manifest is used to automate documentation of the opcodes (wiki, pdf documentation, etc). The manifest is a .json file. It should have the minimal form: { \"name\" : \"mylib\" , \"opcodes\" : [ \"foo\" , \"bar\" ], \"author\" : \"name\" , \"author_email\" : \"name@email.com\" , \"license\" : \"LGPL\" , \"description\" : \"Description of this package\" , \"url\" : \"http://github.com/...\" } In this case, three opcodes are defined, and these names should correspond to the .csd example living inside of the examples folder, and a .md file living inside the docs folder.","title":"Manifest"},{"location":"Installation.html","text":"Installation From Source The source lives at https://github.com/csound-plugins/csound-plugins Dependencies a compiler cmake csound >= 6.13 git clone https://github.com/csound-plugins/csound-plugins cd csound-plugins mkdir build cd build cmake .. make sudo make install","title":"Installation"},{"location":"Installation.html#installation","text":"","title":"Installation"},{"location":"Installation.html#from-source","text":"The source lives at https://github.com/csound-plugins/csound-plugins","title":"From Source"},{"location":"Installation.html#dependencies","text":"a compiler cmake csound >= 6.13 git clone https://github.com/csound-plugins/csound-plugins cd csound-plugins mkdir build cd build cmake .. make sudo make install","title":"Dependencies"},{"location":"opcodes/accum.html","text":"accum Abstract Simple accumulator of scalar values Description accum can be used together with changed , changed2 , metro , etc, to convert a binary trigger to an incremental one. Incremental triggers are used by many opcodes ( printf , for example), so by doing accum(changed(kvar)) it is possible to use binary triggers wherever an incremental trigger is expected. accum outputs its current value and increments it afterwords. Syntax k out a ccum k step , i nitial = 0 , k reset = 0 a out a ccum k step , i nitial = 0 , k reset = 0 Arguments kstep : the step to add. This value will be added at each iteration (at each k-cycle for accum:k and at each sample for accum:a ) initial : initial value of the accumulator kreset : if 1, the accummulator is reset to the initial value Output kout : accumulated value Execution Time Init Examples k out a ccum 1 , 0 ; outputs 0, 1, 2, 3, 4... ; Play a sample with variable speed, stop the event when finished a index a ccum 1 k speed = linseg : k ( 0.5 , i len , 2 ) i len = ftlen ( i ft ) a index *= k speed a sig table3 a index , i ft if a index [ 0 ] >= i len - ( ksmps * k speed ) then turnoff endif i fade = 1 / ksmps out a sig * linsegr ( 0 , i fade , 1 , i fade , 0 ) < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > instr 1 k x linseg 0 , p3 , 1 printf \"kx= %f \\n \" , a ccum ( changed ( k x )), k x ; the same without accum would only print the first time, ; since changed would return always 1 but printf expects an ever ; increasing trigger endin </ CsInstruments > < CsScore > i 1 0 0.1 </ CsScore > </ CsoundSynthesizer > See also metro changed trighold printf Credits Eduardo Moguillansky, 2019","title":"accum"},{"location":"opcodes/accum.html#accum","text":"","title":"accum"},{"location":"opcodes/accum.html#abstract","text":"Simple accumulator of scalar values","title":"Abstract"},{"location":"opcodes/accum.html#description","text":"accum can be used together with changed , changed2 , metro , etc, to convert a binary trigger to an incremental one. Incremental triggers are used by many opcodes ( printf , for example), so by doing accum(changed(kvar)) it is possible to use binary triggers wherever an incremental trigger is expected. accum outputs its current value and increments it afterwords.","title":"Description"},{"location":"opcodes/accum.html#syntax","text":"k out a ccum k step , i nitial = 0 , k reset = 0 a out a ccum k step , i nitial = 0 , k reset = 0","title":"Syntax"},{"location":"opcodes/accum.html#arguments","text":"kstep : the step to add. This value will be added at each iteration (at each k-cycle for accum:k and at each sample for accum:a ) initial : initial value of the accumulator kreset : if 1, the accummulator is reset to the initial value","title":"Arguments"},{"location":"opcodes/accum.html#output","text":"kout : accumulated value","title":"Output"},{"location":"opcodes/accum.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/accum.html#examples","text":"k out a ccum 1 , 0 ; outputs 0, 1, 2, 3, 4... ; Play a sample with variable speed, stop the event when finished a index a ccum 1 k speed = linseg : k ( 0.5 , i len , 2 ) i len = ftlen ( i ft ) a index *= k speed a sig table3 a index , i ft if a index [ 0 ] >= i len - ( ksmps * k speed ) then turnoff endif i fade = 1 / ksmps out a sig * linsegr ( 0 , i fade , 1 , i fade , 0 ) < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > instr 1 k x linseg 0 , p3 , 1 printf \"kx= %f \\n \" , a ccum ( changed ( k x )), k x ; the same without accum would only print the first time, ; since changed would return always 1 but printf expects an ever ; increasing trigger endin </ CsInstruments > < CsScore > i 1 0 0.1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/accum.html#see-also","text":"metro changed trighold printf","title":"See also"},{"location":"opcodes/accum.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/atstop.html","text":"atstop Abstract Schedule an instrument at the end of the current instrument Description atstop can be used to schedule an instrument event as the last action of a given instrument, during the process of being deallocated. This can be used to notify when the note has actually stopped, or to schedule a chain of events, free any table or dict allocated, etc. The advantage over the release opcode is that atstop is guaranteed to be run after the note has stopped, so there is no danger in deallocating resources being used by this note, there are no conflicts with release envelopes, etc. If any k-variables are passed to the scheduled instr these will reflect the changes at the end of the instr. Release time vs deinit time The event is not scheduled at release time (see below \"Release time vs Deinit time\") but at the moment the note is freed. Release time is when the note is within its release phase , which will only happen if the note has an envelope with a release segment (like linsegr ), or if it has setup extra time with xtratim . The opcode release can be used to query if the current note is being released. The instrument keeps running in release phase as long as the release part of the envelope is finished or the extra time allocated via xtratim is through. Deinit time is the moment the note is actually being freed, so the instrument is not running anymore at this point. Syntax a tstop i nstrnum [, i delay = 0 , i dur =- 1 , p4 , p5 , ... ] a tstop S instrname [, i delay = 0 , i dur =- 1 , p4 , p5 , ... ] Arguments instrnum / Sintrname : the number or the name of the instr to be scheduled idelay : the time offset after the stop time of this note to start this instrument idur : the duration of the event p4 , p5 , ...: any other p-arguments, as used with similar opcodes like schedule , event , etc. They can be any i-, k- or S- variable. The scheduled instr will access them, as p-args. Execution Time Init Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* # This is the example file for the atstop opcode atstop schedules an instrument at the end of the note This might be useful to notify that a note stopped, or to schedule a chain of notes, etc. NB: the scheduled event is NOT triggered at release time, which might be when this note is still playing, if the note has some release envelope, but when the note is being deleted ## Syntax atstop Sinstrname, idelay, idur, ... atstop instrnum, idelay, idur, ... * Sinstrname / instrnum: the name or the instrument number to schedule * idelay: time offset to this note stop * idur: duration of the scheduled event (-1 = forever) */ sr = 44100 ksmps = 64 0dbfs = 1 nchnls = 2 opcode myvco , a , ii i amp , i freq xin a 0 vco2 , i amp , i freq a 0 += vco2 ( i amp , i freq + 2 ) a 0 += vco2 ( i amp , i freq / 2 ) xout a 0 endop ; brownian walk instr 1 i midi = p4 a 0 myvco 0.1 , mtof : i ( i midi ) outs a 0 , a 0 i delta = round (( rnd ( 4 ) - 1 ) * 2 ) / 2 i delta = i delta != 0 ? i delta : - 0.5 i midi2 = i midi + i delta i midi2 = i midi2 < 96 ? i midi2 : 48 i durnext = round ( rnd ( 0.25 ) * 8 ) / 8 a tstop 1 , 0 , i durnext , i midi2 endin ; ping-pong instr 2 i midi = p4 i midi = i midi < 96 ? i midi : 48 a 0 myvco 0.1 , mtof : i ( i midi ) a 0 *= linsegr ( 0 , 0.05 , 1 , 0.05 , 0 ) outs a 0 , a 0 a tstop 3 , 0 , p3 * 0.97 , i midi + 1 endin instr 3 i midi = p4 i midi = i midi < 88 ? i midi : 48 a 0 oscili 0.8 , mtof : i ( i midi ) a 0 *= linsegr ( 0 , 0.05 , 1 , 0.050 , 0 ) outs a 0 , a 0 a tstop 2 , 0 , p3 * 0.95 , i midi + 1 endin ; test calling a named instr at stop instr 10 a 0 oscili 0.1 , 440 outs a 0 , a 0 a tstop \"foo\" , 0.5 , 1 , 1000 endin instr foo i freq = p4 a 0 oscili 0.1 , i freq outs a 0 , a 0 endin ; test simple case with optional pargs instr first a tstop \"second\" , 1 , - 1 , 0.5 a tstop \"second\" , 0.5 a tstop 200 endin instr second printf \"second! p4 = %f \\n \" , 1 , p4 turnoff endin instr 200 printf \"200! \\n \" , 1 turnoff endin ; test atstop with k args instr _printCounter i counter = p4 prints \"counter: %d \\n \" , i counter turnoff endin instr kargs k counter init 0 k counter += 1 a tstop \"_printCounter\" , 0 , - 1 , k counter endin instr StopPerformance exitnow endin </ CsInstruments > < CsScore > ; i 1 0 0.25 36 ; i 2 0 0.25 48 ; i 10 0 1 ; i \"StopPerformance\" 10 1 ; i \"first\" 1 0.5 i \"kargs\" 0 1 f 0 5 </ CsScore > </ CsoundSynthesizer > See also defer schedule event release xtratim Credits Eduardo Moguillansky, 2019","title":"atstop"},{"location":"opcodes/atstop.html#atstop","text":"","title":"atstop"},{"location":"opcodes/atstop.html#abstract","text":"Schedule an instrument at the end of the current instrument","title":"Abstract"},{"location":"opcodes/atstop.html#description","text":"atstop can be used to schedule an instrument event as the last action of a given instrument, during the process of being deallocated. This can be used to notify when the note has actually stopped, or to schedule a chain of events, free any table or dict allocated, etc. The advantage over the release opcode is that atstop is guaranteed to be run after the note has stopped, so there is no danger in deallocating resources being used by this note, there are no conflicts with release envelopes, etc. If any k-variables are passed to the scheduled instr these will reflect the changes at the end of the instr. Release time vs deinit time The event is not scheduled at release time (see below \"Release time vs Deinit time\") but at the moment the note is freed. Release time is when the note is within its release phase , which will only happen if the note has an envelope with a release segment (like linsegr ), or if it has setup extra time with xtratim . The opcode release can be used to query if the current note is being released. The instrument keeps running in release phase as long as the release part of the envelope is finished or the extra time allocated via xtratim is through. Deinit time is the moment the note is actually being freed, so the instrument is not running anymore at this point.","title":"Description"},{"location":"opcodes/atstop.html#syntax","text":"a tstop i nstrnum [, i delay = 0 , i dur =- 1 , p4 , p5 , ... ] a tstop S instrname [, i delay = 0 , i dur =- 1 , p4 , p5 , ... ]","title":"Syntax"},{"location":"opcodes/atstop.html#arguments","text":"instrnum / Sintrname : the number or the name of the instr to be scheduled idelay : the time offset after the stop time of this note to start this instrument idur : the duration of the event p4 , p5 , ...: any other p-arguments, as used with similar opcodes like schedule , event , etc. They can be any i-, k- or S- variable. The scheduled instr will access them, as p-args.","title":"Arguments"},{"location":"opcodes/atstop.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/atstop.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* # This is the example file for the atstop opcode atstop schedules an instrument at the end of the note This might be useful to notify that a note stopped, or to schedule a chain of notes, etc. NB: the scheduled event is NOT triggered at release time, which might be when this note is still playing, if the note has some release envelope, but when the note is being deleted ## Syntax atstop Sinstrname, idelay, idur, ... atstop instrnum, idelay, idur, ... * Sinstrname / instrnum: the name or the instrument number to schedule * idelay: time offset to this note stop * idur: duration of the scheduled event (-1 = forever) */ sr = 44100 ksmps = 64 0dbfs = 1 nchnls = 2 opcode myvco , a , ii i amp , i freq xin a 0 vco2 , i amp , i freq a 0 += vco2 ( i amp , i freq + 2 ) a 0 += vco2 ( i amp , i freq / 2 ) xout a 0 endop ; brownian walk instr 1 i midi = p4 a 0 myvco 0.1 , mtof : i ( i midi ) outs a 0 , a 0 i delta = round (( rnd ( 4 ) - 1 ) * 2 ) / 2 i delta = i delta != 0 ? i delta : - 0.5 i midi2 = i midi + i delta i midi2 = i midi2 < 96 ? i midi2 : 48 i durnext = round ( rnd ( 0.25 ) * 8 ) / 8 a tstop 1 , 0 , i durnext , i midi2 endin ; ping-pong instr 2 i midi = p4 i midi = i midi < 96 ? i midi : 48 a 0 myvco 0.1 , mtof : i ( i midi ) a 0 *= linsegr ( 0 , 0.05 , 1 , 0.05 , 0 ) outs a 0 , a 0 a tstop 3 , 0 , p3 * 0.97 , i midi + 1 endin instr 3 i midi = p4 i midi = i midi < 88 ? i midi : 48 a 0 oscili 0.8 , mtof : i ( i midi ) a 0 *= linsegr ( 0 , 0.05 , 1 , 0.050 , 0 ) outs a 0 , a 0 a tstop 2 , 0 , p3 * 0.95 , i midi + 1 endin ; test calling a named instr at stop instr 10 a 0 oscili 0.1 , 440 outs a 0 , a 0 a tstop \"foo\" , 0.5 , 1 , 1000 endin instr foo i freq = p4 a 0 oscili 0.1 , i freq outs a 0 , a 0 endin ; test simple case with optional pargs instr first a tstop \"second\" , 1 , - 1 , 0.5 a tstop \"second\" , 0.5 a tstop 200 endin instr second printf \"second! p4 = %f \\n \" , 1 , p4 turnoff endin instr 200 printf \"200! \\n \" , 1 turnoff endin ; test atstop with k args instr _printCounter i counter = p4 prints \"counter: %d \\n \" , i counter turnoff endin instr kargs k counter init 0 k counter += 1 a tstop \"_printCounter\" , 0 , - 1 , k counter endin instr StopPerformance exitnow endin </ CsInstruments > < CsScore > ; i 1 0 0.25 36 ; i 2 0 0.25 48 ; i 10 0 1 ; i \"StopPerformance\" 10 1 ; i \"first\" 1 0.5 i \"kargs\" 0 1 f 0 5 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/atstop.html#see-also","text":"defer schedule event release xtratim","title":"See also"},{"location":"opcodes/atstop.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/bisect.html","text":"bisect Abstract Returns the fractional index of a value within a sorted array / tab Description Given an array x0, x1, x2, x3,... , bisect determines the fractional index of a value x, indicating where this value would be placed within the given array/table. For example, given an array [0, 10, 14, 20] , the value 12 would receive the index 1.5 since it is to be placed between elements 1 and 2, equidistant from both (the fractional part determines the relative distance to the neighbouring elements). The index is clamped to 0 and size-1 . Note bisect can be used together with interp1d to perform piecewise interpolation. Given an array of x values and an array of corrsponding y values, bisect determines the index within the x array and interp1d maps that index to the y domain via multiple interpolation methods Syntax k idx bisect k val , xarr [] i idx bisect i val , xarr [] a idx bisect a val , xarr [] k idx [] bisect k vals [], xarr [] i idx [] bisect i vals [], xarr [] k idx bisect k val , k tab , k step = 1 , k offset = 0 i idx bisect i val , i tab , i step = 1 , i offset = 0 a idx bisect a val , k tab , k step = 1 , k offset = 0 k idx [] bisect k val [], k tab , k step = 1 , k offset = 0 i idx [] bisect i val [], i tab , i step = 1 , i offset = 0 Arguments kval : the value to quiery within arr arr : the array (1D) holding the data. tab : the table holding the data step : in the case of a table, it is possible to bisect one particular column in the table if, for each row, multiple features are included in the same table offset : the offset determines the precise column to bisect Output out : the index of val inside the array/tab Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* Abstract ======== Determine the fractional index of a value within a sorted array / tab Description =========== Given an array x0, x1, x2, x3,..., determine the fractional index of a value x. For example, given an array [0, 10, 14, 20], the value 12 would receive the index 1.5 since it is to be placed between elements 1 and 2, equidistant from both. The fractional part determines the relative distance to the neighbouring elements. Syntax ====== kidx bisect kval, xarr[] iidx bisect ival, xarr[] aidx bisect aval, xarr[] kidx[] bisect kvals[], xarr[] iidx[] bisect ivals[], xarr[] kidx bisect kval, ktab, kstep=1, koffset=0 iidx bisect ival, itab, istep=1, ioffset=0 aidx bisect aval, ktab, kstep=1, koffset=0 kidx[] bisect kval[], ktab, kstep=1, koffset=0 iidx[] bisect ival[], itab, istep=1, ioffset=0 Args ==== kval: the value to quiery within arr arr: the array (1D) holding the data. tab: the table holding the data step: in the case of a table, it is possible to bisect one particular column in the table if, for each row, multiple features are included in the same table offset: the offset determines the precise column to bisect Output ====== out: the index of val inside the array/tab See Also ======== interp1d, bpf, linlin, getrowlin, linenv */ ksmps = 64 nchnls = 2 0dbfs = 1 instr example1 ; used together with bisect can create multiple piecewise interpolation ; configurations i times [] fillarray 0 , 4 , 5 , 10 i midi1 [] fillarray 64 , 64 , 63.5 , 64.5 i midi2 [] fillarray 64 , 63.4 , 63.4 , 63 i amps [] fillarray 0 , 0.8 , 0.8 , 0 k idx bisect timeinsts (), i times k amp i nterp1d k idx , i amps , \"cos\" a amp interp k amp a 1 oscili a amp , mtof ( i nterp1d ( k idx , i midi1 , \"cubic\" )) a 2 oscili a amp , mtof ( i nterp1d ( k idx , i midi2 )) println \"amp: %f \" , rms : k ( a amp ) outch 1 , a 1 , 2 , a 2 endin instr example2 ; a table can also be used with interp1d / bisect. A table can hold ; both x and y coordinates as pairs i time2midi1 f tfill 0 , 64 , 4 , 62 , 5 , 62 , 6 , 67 i time2midi2 f tfill 0 , 60 , 4 , 60 , 5 , 59 , 6 , 59 ftfree i time2midi1 , 1 ftfree i time2midi2 , 1 ; step=2, bisect the column 0. k t = timeinsts () k idx1 bisect k t , i time2midi1 , 2 k idx2 bisect k t , i time2midi2 , 2 ; -1: cosine interpolation, step size=2, offset=1 k midi1 i nterp1d k idx1 , i time2midi1 , \"cos\" , 2 , 1 k midi2 i nterp1d k idx2 , i time2midi2 , \"cos\" , 2 , 1 a 0 squinewave a ( mtof ( k midi1 )), a ( 0.1 ), a ( 0.1 ) a 1 squinewave a ( mtof ( k midi2 )), a ( 0.2 ), a ( 0.5 ) i gain = 0.1 i fade = 0.2 a env = linseg : a ( 0 , i fade , i gain , p3 - i fade * 2 - 0.1 , i gain , i fade , 0 ) outch 1 , a 0 * a env , 2 , a 1 * a env endin instr test1 i curve f tfill 1 , 60 , 3 , 65 , 4 , 60 k t timeinsts k idx bisect k t , i curve , 2 k midi i nterp1d k idx , k ( i curve ), \"linear\" , 2 , 1 println \"kt: %f , kidx: %f , kmidi: %f \" , k t , k idx , k midi endin </ CsInstruments > < CsScore > ; Uncomment to perform each example ;i \"example1\" 0 10 ;i \"example2\" 0 7 i \"test1\" 0 5 </ CsScore > </ CsoundSynthesizer > See Also interp1d bpf linlin getrowlin linenv","title":"bisect"},{"location":"opcodes/bisect.html#bisect","text":"","title":"bisect"},{"location":"opcodes/bisect.html#abstract","text":"Returns the fractional index of a value within a sorted array / tab","title":"Abstract"},{"location":"opcodes/bisect.html#description","text":"Given an array x0, x1, x2, x3,... , bisect determines the fractional index of a value x, indicating where this value would be placed within the given array/table. For example, given an array [0, 10, 14, 20] , the value 12 would receive the index 1.5 since it is to be placed between elements 1 and 2, equidistant from both (the fractional part determines the relative distance to the neighbouring elements). The index is clamped to 0 and size-1 . Note bisect can be used together with interp1d to perform piecewise interpolation. Given an array of x values and an array of corrsponding y values, bisect determines the index within the x array and interp1d maps that index to the y domain via multiple interpolation methods","title":"Description"},{"location":"opcodes/bisect.html#syntax","text":"k idx bisect k val , xarr [] i idx bisect i val , xarr [] a idx bisect a val , xarr [] k idx [] bisect k vals [], xarr [] i idx [] bisect i vals [], xarr [] k idx bisect k val , k tab , k step = 1 , k offset = 0 i idx bisect i val , i tab , i step = 1 , i offset = 0 a idx bisect a val , k tab , k step = 1 , k offset = 0 k idx [] bisect k val [], k tab , k step = 1 , k offset = 0 i idx [] bisect i val [], i tab , i step = 1 , i offset = 0","title":"Syntax"},{"location":"opcodes/bisect.html#arguments","text":"kval : the value to quiery within arr arr : the array (1D) holding the data. tab : the table holding the data step : in the case of a table, it is possible to bisect one particular column in the table if, for each row, multiple features are included in the same table offset : the offset determines the precise column to bisect","title":"Arguments"},{"location":"opcodes/bisect.html#output","text":"out : the index of val inside the array/tab","title":"Output"},{"location":"opcodes/bisect.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* Abstract ======== Determine the fractional index of a value within a sorted array / tab Description =========== Given an array x0, x1, x2, x3,..., determine the fractional index of a value x. For example, given an array [0, 10, 14, 20], the value 12 would receive the index 1.5 since it is to be placed between elements 1 and 2, equidistant from both. The fractional part determines the relative distance to the neighbouring elements. Syntax ====== kidx bisect kval, xarr[] iidx bisect ival, xarr[] aidx bisect aval, xarr[] kidx[] bisect kvals[], xarr[] iidx[] bisect ivals[], xarr[] kidx bisect kval, ktab, kstep=1, koffset=0 iidx bisect ival, itab, istep=1, ioffset=0 aidx bisect aval, ktab, kstep=1, koffset=0 kidx[] bisect kval[], ktab, kstep=1, koffset=0 iidx[] bisect ival[], itab, istep=1, ioffset=0 Args ==== kval: the value to quiery within arr arr: the array (1D) holding the data. tab: the table holding the data step: in the case of a table, it is possible to bisect one particular column in the table if, for each row, multiple features are included in the same table offset: the offset determines the precise column to bisect Output ====== out: the index of val inside the array/tab See Also ======== interp1d, bpf, linlin, getrowlin, linenv */ ksmps = 64 nchnls = 2 0dbfs = 1 instr example1 ; used together with bisect can create multiple piecewise interpolation ; configurations i times [] fillarray 0 , 4 , 5 , 10 i midi1 [] fillarray 64 , 64 , 63.5 , 64.5 i midi2 [] fillarray 64 , 63.4 , 63.4 , 63 i amps [] fillarray 0 , 0.8 , 0.8 , 0 k idx bisect timeinsts (), i times k amp i nterp1d k idx , i amps , \"cos\" a amp interp k amp a 1 oscili a amp , mtof ( i nterp1d ( k idx , i midi1 , \"cubic\" )) a 2 oscili a amp , mtof ( i nterp1d ( k idx , i midi2 )) println \"amp: %f \" , rms : k ( a amp ) outch 1 , a 1 , 2 , a 2 endin instr example2 ; a table can also be used with interp1d / bisect. A table can hold ; both x and y coordinates as pairs i time2midi1 f tfill 0 , 64 , 4 , 62 , 5 , 62 , 6 , 67 i time2midi2 f tfill 0 , 60 , 4 , 60 , 5 , 59 , 6 , 59 ftfree i time2midi1 , 1 ftfree i time2midi2 , 1 ; step=2, bisect the column 0. k t = timeinsts () k idx1 bisect k t , i time2midi1 , 2 k idx2 bisect k t , i time2midi2 , 2 ; -1: cosine interpolation, step size=2, offset=1 k midi1 i nterp1d k idx1 , i time2midi1 , \"cos\" , 2 , 1 k midi2 i nterp1d k idx2 , i time2midi2 , \"cos\" , 2 , 1 a 0 squinewave a ( mtof ( k midi1 )), a ( 0.1 ), a ( 0.1 ) a 1 squinewave a ( mtof ( k midi2 )), a ( 0.2 ), a ( 0.5 ) i gain = 0.1 i fade = 0.2 a env = linseg : a ( 0 , i fade , i gain , p3 - i fade * 2 - 0.1 , i gain , i fade , 0 ) outch 1 , a 0 * a env , 2 , a 1 * a env endin instr test1 i curve f tfill 1 , 60 , 3 , 65 , 4 , 60 k t timeinsts k idx bisect k t , i curve , 2 k midi i nterp1d k idx , k ( i curve ), \"linear\" , 2 , 1 println \"kt: %f , kidx: %f , kmidi: %f \" , k t , k idx , k midi endin </ CsInstruments > < CsScore > ; Uncomment to perform each example ;i \"example1\" 0 10 ;i \"example2\" 0 7 i \"test1\" 0 5 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/bisect.html#see-also","text":"interp1d bpf linlin getrowlin linenv","title":"See Also"},{"location":"opcodes/channelStateRecall.html","text":"channelStateRecall Abstract Recalls channel data saved to a file via channelStateSave Description This opcode will read a previously saved state JSON file and update all channels accordingly. It can be used to with the channelStateSave opcode to create a robust preset system. Syntax i Res channelStateRecall S Filename k Res channelStateRecall S Filename S IgnoreChannels [] Initialization iRes -- 1 for success, 0 for fail SFilename -- filename Performance kRes -- 1 for success, 0 for fail SFilename -- filename SIgnoreChannels[] -- optional array of channels that should not be overwritten by recall. In some frontends, updating a channel that is use to trigger a state recall will cause an endless loop. In the example below, the channels triggerSave and recallCombo are ignored as they are used to control saving and recalling of presets. Example This example shows channelStateRecall being used to recall a previously written state file. < Cabbage > f orm caption ( \"Presets\" ) size ( 370 , 280 ), colour ( 58 , 110 , 182 ), pluginid ( \"fsad\" ) k eyboard bounds ( 10 , 90 , 345 , 95 ) rslider bounds ( 12 , 8 , 85 , 79 ), channel ( \"att\" ), range ( 0 , 1 , 0.01 ), text ( \"Att.\" ) rslider bounds ( 98 , 8 , 85 , 79 ), channel ( \"dec\" ), range ( 0 , 1 , 0.4 ), text ( \"Dec.\" ) rslider bounds ( 184 , 8 , 85 , 79 ), channel ( \"sus\" ), range ( 0 , 1 , 0.7 ), text ( \"Sus.\" ) rslider bounds ( 270 , 8 , 85 , 79 ), channel ( \"rel\" ), range ( 0 , 1 , 0.8 ), text ( \"Rel.\" ) combobox bounds ( 92 , 192 , 226 , 25 ), populate ( \"*.txt\" , \".\" ), channel ( \"recallCombo\" ), channeltype ( \"string\" ), i dentchannel ( \"recallComboIdent\" ) button bounds ( 10 , 192 , 80 , 40 ), channel ( \"triggerSave\" ), text ( \"Save state\" ) </ Cabbage > < CsoundSynthesizer > < CsOptions > - n - d -+ rtmidi = NULL - M0 -- midi - k ey - cps = 4 -- midi - velocity - a mp = 5 </ CsOptions > < CsInstruments > ; Initialize the global variables. ;sr is set by the host ksmps = 32 nchnls = 2 0dbfs = 1 gk FileNumber init 10 instr 1 k Env madsr chnget : i ( \"att\" ), chnget : i ( \"dec\" ), chnget : i ( \"sus\" ), chnget : i ( \"rel\" ) a Out vco2 k Env * p5 , p4 outs a Out , a Out endin instr 10 S Filename chnget \"recallCombo\" if changed2 : k ( S Filename ) == 1 then S IgnoreChannels [] init 2 S IgnoreChannels [ 0 ] = \"triggerSave\" S IgnoreChannels [ 1 ] = \"recallCombo\" k Ok = channelStateRecall : k ( S Filename , S IgnoreChannels ) endif if changed : k ( chnget : k ( \"triggerSave\" )) == 1 then S Path = chnget : S ( \"CSD_PATH\" ) S Filename = sprintfk : S ( \"PresetTest %d .txt\" , gk FileNumber ) printks \" %s \" , 0 , S Filename k Ok = channelStateSave : k ( S Filename ) gk FileNumber += 1 chnset \"refreshfiles()\" , \"recallComboIdent\" endif endin </ CsInstruments > < CsScore > ;causes Csound to run for about 7000 years... i 10 0 z </ CsScore > </ CsoundSynthesizer > See Also channelStateSave Credits Author: Rory Walsh 2019","title":"channelStateRecall"},{"location":"opcodes/channelStateRecall.html#channelstaterecall","text":"","title":"channelStateRecall"},{"location":"opcodes/channelStateRecall.html#abstract","text":"Recalls channel data saved to a file via channelStateSave","title":"Abstract"},{"location":"opcodes/channelStateRecall.html#description","text":"This opcode will read a previously saved state JSON file and update all channels accordingly. It can be used to with the channelStateSave opcode to create a robust preset system.","title":"Description"},{"location":"opcodes/channelStateRecall.html#syntax","text":"i Res channelStateRecall S Filename k Res channelStateRecall S Filename S IgnoreChannels []","title":"Syntax"},{"location":"opcodes/channelStateRecall.html#initialization","text":"iRes -- 1 for success, 0 for fail SFilename -- filename","title":"Initialization"},{"location":"opcodes/channelStateRecall.html#performance","text":"kRes -- 1 for success, 0 for fail SFilename -- filename SIgnoreChannels[] -- optional array of channels that should not be overwritten by recall. In some frontends, updating a channel that is use to trigger a state recall will cause an endless loop. In the example below, the channels triggerSave and recallCombo are ignored as they are used to control saving and recalling of presets.","title":"Performance"},{"location":"opcodes/channelStateRecall.html#example","text":"This example shows channelStateRecall being used to recall a previously written state file. < Cabbage > f orm caption ( \"Presets\" ) size ( 370 , 280 ), colour ( 58 , 110 , 182 ), pluginid ( \"fsad\" ) k eyboard bounds ( 10 , 90 , 345 , 95 ) rslider bounds ( 12 , 8 , 85 , 79 ), channel ( \"att\" ), range ( 0 , 1 , 0.01 ), text ( \"Att.\" ) rslider bounds ( 98 , 8 , 85 , 79 ), channel ( \"dec\" ), range ( 0 , 1 , 0.4 ), text ( \"Dec.\" ) rslider bounds ( 184 , 8 , 85 , 79 ), channel ( \"sus\" ), range ( 0 , 1 , 0.7 ), text ( \"Sus.\" ) rslider bounds ( 270 , 8 , 85 , 79 ), channel ( \"rel\" ), range ( 0 , 1 , 0.8 ), text ( \"Rel.\" ) combobox bounds ( 92 , 192 , 226 , 25 ), populate ( \"*.txt\" , \".\" ), channel ( \"recallCombo\" ), channeltype ( \"string\" ), i dentchannel ( \"recallComboIdent\" ) button bounds ( 10 , 192 , 80 , 40 ), channel ( \"triggerSave\" ), text ( \"Save state\" ) </ Cabbage > < CsoundSynthesizer > < CsOptions > - n - d -+ rtmidi = NULL - M0 -- midi - k ey - cps = 4 -- midi - velocity - a mp = 5 </ CsOptions > < CsInstruments > ; Initialize the global variables. ;sr is set by the host ksmps = 32 nchnls = 2 0dbfs = 1 gk FileNumber init 10 instr 1 k Env madsr chnget : i ( \"att\" ), chnget : i ( \"dec\" ), chnget : i ( \"sus\" ), chnget : i ( \"rel\" ) a Out vco2 k Env * p5 , p4 outs a Out , a Out endin instr 10 S Filename chnget \"recallCombo\" if changed2 : k ( S Filename ) == 1 then S IgnoreChannels [] init 2 S IgnoreChannels [ 0 ] = \"triggerSave\" S IgnoreChannels [ 1 ] = \"recallCombo\" k Ok = channelStateRecall : k ( S Filename , S IgnoreChannels ) endif if changed : k ( chnget : k ( \"triggerSave\" )) == 1 then S Path = chnget : S ( \"CSD_PATH\" ) S Filename = sprintfk : S ( \"PresetTest %d .txt\" , gk FileNumber ) printks \" %s \" , 0 , S Filename k Ok = channelStateSave : k ( S Filename ) gk FileNumber += 1 chnset \"refreshfiles()\" , \"recallComboIdent\" endif endin </ CsInstruments > < CsScore > ;causes Csound to run for about 7000 years... i 10 0 z </ CsScore > </ CsoundSynthesizer >","title":"Example"},{"location":"opcodes/channelStateRecall.html#see-also","text":"channelStateSave","title":"See Also"},{"location":"opcodes/channelStateRecall.html#credits","text":"Author: Rory Walsh 2019","title":"Credits"},{"location":"opcodes/channelStateSave.html","text":"channelStateSave Abstract Saves all channel data to file Description This opcode will save the value of each channel declared in a Csound orchestra to a JSON file on disk. It can be used with the channelStateRecall opcode to create a robust preset system. Syntax i Res channelStateSave S Filename k Res channelStateSave S Filename Initialization iRes -- 1 for success, 0 for fail SFilename -- filename Performance kRes -- 1 for success, 0 for fail SFilename -- filename Example This example shows channelStateSave being used to save the current states of a all Cabbage widgets to disk. The states can be recalled using the channelStateRecall opcode. < Cabbage > f orm caption ( \"Presets\" ) size ( 370 , 280 ), colour ( 58 , 110 , 182 ), pluginid ( \"fsad\" ) k eyboard bounds ( 10 , 90 , 345 , 95 ) rslider bounds ( 12 , 8 , 85 , 79 ), channel ( \"att\" ), range ( 0 , 1 , 0.01 ), text ( \"Att.\" ) rslider bounds ( 98 , 8 , 85 , 79 ), channel ( \"dec\" ), range ( 0 , 1 , 0.4 ), text ( \"Dec.\" ) rslider bounds ( 184 , 8 , 85 , 79 ), channel ( \"sus\" ), range ( 0 , 1 , 0.7 ), text ( \"Sus.\" ) rslider bounds ( 270 , 8 , 85 , 79 ), channel ( \"rel\" ), range ( 0 , 1 , 0.8 ), text ( \"Rel.\" ) combobox bounds ( 92 , 192 , 226 , 25 ), populate ( \"*.txt\" , \".\" ), channel ( \"recallCombo\" ), channeltype ( \"string\" ), i dentchannel ( \"recallComboIdent\" ) button bounds ( 10 , 192 , 80 , 40 ), channel ( \"triggerSave\" ), text ( \"Save state\" ) </ Cabbage > < CsoundSynthesizer > < CsOptions > - n - d -+ rtmidi = NULL - M0 -- midi - k ey - cps = 4 -- midi - velocity - a mp = 5 </ CsOptions > < CsInstruments > ; Initialize the global variables. ;sr is set by the host ksmps = 32 nchnls = 2 0dbfs = 1 gk FileNumber init 10 instr 1 k Env madsr chnget : i ( \"att\" ), chnget : i ( \"dec\" ), chnget : i ( \"sus\" ), chnget : i ( \"rel\" ) a Out vco2 k Env * p5 , p4 outs a Out , a Out endin instr 10 S Filename chnget \"recallCombo\" if changed2 : k ( S Filename ) == 1 then S IgnoreChannels [] init 2 S IgnoreChannels [ 0 ] = \"triggerSave\" S IgnoreChannels [ 1 ] = \"recallCombo\" k Ok = channelStateRecall : k ( S Filename , S IgnoreChannels ) endif if changed : k ( chnget : k ( \"triggerSave\" )) == 1 then S Path = chnget : S ( \"CSD_PATH\" ) S Filename = sprintfk : S ( \"PresetTest %d .txt\" , gk FileNumber ) printks \" %s \" , 0 , S Filename k Ok = channelStateSave : k ( S Filename ) gk FileNumber += 1 chnset \"refreshfiles()\" , \"recallComboIdent\" endif endin </ CsInstruments > < CsScore > ;causes Csound to run for about 7000 years... i 10 0 z </ CsScore > </ CsoundSynthesizer > See Also channelStateRecall Credits Author: Rory Walsh 2019","title":"channelStateSave"},{"location":"opcodes/channelStateSave.html#channelstatesave","text":"","title":"channelStateSave"},{"location":"opcodes/channelStateSave.html#abstract","text":"Saves all channel data to file","title":"Abstract"},{"location":"opcodes/channelStateSave.html#description","text":"This opcode will save the value of each channel declared in a Csound orchestra to a JSON file on disk. It can be used with the channelStateRecall opcode to create a robust preset system.","title":"Description"},{"location":"opcodes/channelStateSave.html#syntax","text":"i Res channelStateSave S Filename k Res channelStateSave S Filename","title":"Syntax"},{"location":"opcodes/channelStateSave.html#initialization","text":"iRes -- 1 for success, 0 for fail SFilename -- filename","title":"Initialization"},{"location":"opcodes/channelStateSave.html#performance","text":"kRes -- 1 for success, 0 for fail SFilename -- filename","title":"Performance"},{"location":"opcodes/channelStateSave.html#example","text":"This example shows channelStateSave being used to save the current states of a all Cabbage widgets to disk. The states can be recalled using the channelStateRecall opcode. < Cabbage > f orm caption ( \"Presets\" ) size ( 370 , 280 ), colour ( 58 , 110 , 182 ), pluginid ( \"fsad\" ) k eyboard bounds ( 10 , 90 , 345 , 95 ) rslider bounds ( 12 , 8 , 85 , 79 ), channel ( \"att\" ), range ( 0 , 1 , 0.01 ), text ( \"Att.\" ) rslider bounds ( 98 , 8 , 85 , 79 ), channel ( \"dec\" ), range ( 0 , 1 , 0.4 ), text ( \"Dec.\" ) rslider bounds ( 184 , 8 , 85 , 79 ), channel ( \"sus\" ), range ( 0 , 1 , 0.7 ), text ( \"Sus.\" ) rslider bounds ( 270 , 8 , 85 , 79 ), channel ( \"rel\" ), range ( 0 , 1 , 0.8 ), text ( \"Rel.\" ) combobox bounds ( 92 , 192 , 226 , 25 ), populate ( \"*.txt\" , \".\" ), channel ( \"recallCombo\" ), channeltype ( \"string\" ), i dentchannel ( \"recallComboIdent\" ) button bounds ( 10 , 192 , 80 , 40 ), channel ( \"triggerSave\" ), text ( \"Save state\" ) </ Cabbage > < CsoundSynthesizer > < CsOptions > - n - d -+ rtmidi = NULL - M0 -- midi - k ey - cps = 4 -- midi - velocity - a mp = 5 </ CsOptions > < CsInstruments > ; Initialize the global variables. ;sr is set by the host ksmps = 32 nchnls = 2 0dbfs = 1 gk FileNumber init 10 instr 1 k Env madsr chnget : i ( \"att\" ), chnget : i ( \"dec\" ), chnget : i ( \"sus\" ), chnget : i ( \"rel\" ) a Out vco2 k Env * p5 , p4 outs a Out , a Out endin instr 10 S Filename chnget \"recallCombo\" if changed2 : k ( S Filename ) == 1 then S IgnoreChannels [] init 2 S IgnoreChannels [ 0 ] = \"triggerSave\" S IgnoreChannels [ 1 ] = \"recallCombo\" k Ok = channelStateRecall : k ( S Filename , S IgnoreChannels ) endif if changed : k ( chnget : k ( \"triggerSave\" )) == 1 then S Path = chnget : S ( \"CSD_PATH\" ) S Filename = sprintfk : S ( \"PresetTest %d .txt\" , gk FileNumber ) printks \" %s \" , 0 , S Filename k Ok = channelStateSave : k ( S Filename ) gk FileNumber += 1 chnset \"refreshfiles()\" , \"recallComboIdent\" endif endin </ CsInstruments > < CsScore > ;causes Csound to run for about 7000 years... i 10 0 z </ CsScore > </ CsoundSynthesizer >","title":"Example"},{"location":"opcodes/channelStateSave.html#see-also","text":"channelStateRecall","title":"See Also"},{"location":"opcodes/channelStateSave.html#credits","text":"Author: Rory Walsh 2019","title":"Credits"},{"location":"opcodes/crackle.html","text":"crackle Abstract generates noise based on a chaotic equation Description crackle is a chaotic generator, the sound is generated with the following equation y[n] = p * y[n-1]- y[n-2] - 0.05 Port of supercollider's Crackle Syntax a out crackle k p Arguments kp : the p parameter in the equation, a value between 1.0 and 2.0 Output aout : audio output of the chaotic generator Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* # This is the example file for the crackle opcode crackle is a port of supercollider's crackle (taken from pd/else) crackle is a chaotic noise generator based on the equation: y[n] = p * y[n-1] - y[n-2] - 0.05 ## Syntax aout crackle kp=0.5 * kp: value for p in the equation (default = 0.5) * aout: noise signal */ sr = 44100 ksmps = 64 0dbfs = 1 nchnls = 2 instr 1 k P [] fillarray 1.0 , 1.2 , 1.3 , 1.35 , 1.4 , 1.5 , 1.8 , 1.9 , 1.97 , 2.0 k idx = int ( line ( 0 , p3 , lenarray ( k P ))) k p = k P [ k idx ] printk2 k p a out crackle k p a out *= 0.5 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 15 </ CsScore > </ CsoundSynthesizer > See also standardchaos chuap dust2 Credits Eduardo Moguillansky, 2019","title":"crackle"},{"location":"opcodes/crackle.html#crackle","text":"","title":"crackle"},{"location":"opcodes/crackle.html#abstract","text":"generates noise based on a chaotic equation","title":"Abstract"},{"location":"opcodes/crackle.html#description","text":"crackle is a chaotic generator, the sound is generated with the following equation y[n] = p * y[n-1]- y[n-2] - 0.05 Port of supercollider's Crackle","title":"Description"},{"location":"opcodes/crackle.html#syntax","text":"a out crackle k p","title":"Syntax"},{"location":"opcodes/crackle.html#arguments","text":"kp : the p parameter in the equation, a value between 1.0 and 2.0","title":"Arguments"},{"location":"opcodes/crackle.html#output","text":"aout : audio output of the chaotic generator","title":"Output"},{"location":"opcodes/crackle.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/crackle.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* # This is the example file for the crackle opcode crackle is a port of supercollider's crackle (taken from pd/else) crackle is a chaotic noise generator based on the equation: y[n] = p * y[n-1] - y[n-2] - 0.05 ## Syntax aout crackle kp=0.5 * kp: value for p in the equation (default = 0.5) * aout: noise signal */ sr = 44100 ksmps = 64 0dbfs = 1 nchnls = 2 instr 1 k P [] fillarray 1.0 , 1.2 , 1.3 , 1.35 , 1.4 , 1.5 , 1.8 , 1.9 , 1.97 , 2.0 k idx = int ( line ( 0 , p3 , lenarray ( k P ))) k p = k P [ k idx ] printk2 k p a out crackle k p a out *= 0.5 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 15 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/crackle.html#see-also","text":"standardchaos chuap dust2","title":"See also"},{"location":"opcodes/crackle.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/defer.html","text":"defer Abstract Run an opcode at the end of an event Description defer can be used to execute the init pass of an opcode at the end of an event. This can be used to perform some cleanup, schedule an event, print something, etc. Release time vs deinit time The event is not scheduled at release time (see below \"Release time vs Deinit time\") but at the moment the note is freed. Release time is when the note is within its release phase , which will only happen if the note has an envelope with a release segment (like linsegr ), or if it has setup extra time with xtratim . The opcode release can be used to query if the current note is being released. The instrument keeps running in release phase as long as the release part of the envelope is finished or the extra time allocated via xtratim is through. Deinit time is the moment the note is actually being freed, so the instrument is not running anymore at this point. Syntax defer S opcode * a rgs Arguments Sopcode : the name of the opcode to run at deinit time args : arguments passed to the opcode itself Execution Time Deinit time Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 0dbfs = 1 nchnls = 2 instr 1 k t timeinsts prints \"Instr 1 started \\n \" defer \"prints\" , \"Instr 1 stopped after %.3f seconds \\n \" , k t endin </ CsInstruments > < CsScore > i 1 0 1 f 0 4 </ CsScore > </ CsoundSynthesizer > See also defer schedule event release xtratim Credits Eduardo Moguillansky, 2019","title":"defer"},{"location":"opcodes/defer.html#defer","text":"","title":"defer"},{"location":"opcodes/defer.html#abstract","text":"Run an opcode at the end of an event","title":"Abstract"},{"location":"opcodes/defer.html#description","text":"defer can be used to execute the init pass of an opcode at the end of an event. This can be used to perform some cleanup, schedule an event, print something, etc. Release time vs deinit time The event is not scheduled at release time (see below \"Release time vs Deinit time\") but at the moment the note is freed. Release time is when the note is within its release phase , which will only happen if the note has an envelope with a release segment (like linsegr ), or if it has setup extra time with xtratim . The opcode release can be used to query if the current note is being released. The instrument keeps running in release phase as long as the release part of the envelope is finished or the extra time allocated via xtratim is through. Deinit time is the moment the note is actually being freed, so the instrument is not running anymore at this point.","title":"Description"},{"location":"opcodes/defer.html#syntax","text":"defer S opcode * a rgs","title":"Syntax"},{"location":"opcodes/defer.html#arguments","text":"Sopcode : the name of the opcode to run at deinit time args : arguments passed to the opcode itself","title":"Arguments"},{"location":"opcodes/defer.html#execution-time","text":"Deinit time","title":"Execution Time"},{"location":"opcodes/defer.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 0dbfs = 1 nchnls = 2 instr 1 k t timeinsts prints \"Instr 1 started \\n \" defer \"prints\" , \"Instr 1 stopped after %.3f seconds \\n \" , k t endin </ CsInstruments > < CsScore > i 1 0 1 f 0 4 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/defer.html#see-also","text":"defer schedule event release xtratim","title":"See also"},{"location":"opcodes/defer.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/deref.html","text":"deref Abstract Dereference a previously created reference to a variable Description ref and deref implement a mechanism to pass a reference to any object, allowing to share a variable across instruments, with opcodes, etc. A ref is reference counted and deallocates itself when it falls out of scope without being referenced by any object. It makes it possible to pass arrays by reference to user defined opcodes, allowing to modify an array inplace, skip copying memory, etc. Syntax xArray deref iref, iextrarefs=0 Arguments iref : a reference index as created via ref iextrarefs : extra references used, matching any extra reference allocated via ref (see ref for more information) Output xArray / xvar : are created as a view of the object originally passed to ref Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > ;; Example file for ref - deref sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gi A [] fillarray 0 , 1000 , 2000 , 3000 ; Example 1: take a ref from an array, deref it to create a second view of it instr 1 ; a source array i X [] fillarray 0 , 10 , 20 , 30 , 40 ; create a ref of iXs, return the index i ref ref i X ; now iYs points to iXs i Y [] deref i ref printarray i Y , \"\" , \"instrument 1, iY\" i Z [] fillarray 0 , 1 , 3 , 5 , 7 ; create a ref, pass it to instr. 2 schedule 2 , 0 , 1 , ref ( i Z ) ; create another ref of iZ. In this case the event is scheduled ; in the future, so the source will not exist anymore when instr. 2 ; is scheduled. This should fail. schedule 2 , 1 , 1 , ref ( i Z ) turnoff endin instr 2 i ref = p4 if refvalid ( i ref ) == 1 then i Zs [] deref i ref printarray i Zs , \"\" , \"p1=2, iZs\" else prints \" \\n The reference has become invalid \\n \" endif turnoff endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; Example 2: extra references to keep array alive instr 3 ; create a source array k Xs [] fillarray 1 , 1 , 2 , 3 , 5 , 8 , 13 ; In order to bridge the time gap between the end of life of the source ; of a ref and the scheduled event where a deref is taken, it is possible ; to create a forward reference, a \"promise\" that one deref has been scheduled ; in the future. ; short lived event, ends before this event schedule 4 , 0 , 0.1 , ref ( k Xs ), 0 ; starts before we end, but survives us schedule 4 , p3 - 0.1 , 0.2 , ref ( k Xs ), 0 ; starts after we end, we need an extra reference schedule 4 , p3 + 1 , 0.1 , ref ( k Xs , 1 ), 1 defer \"prints\" , \" --- instr. 3 finished --- \\n \" endin instr 4 prints \"instr. 4 \\n \" k View [] deref p4 , p5 printarray k View defer \"prints\" , \" --- instr. 4 finished --- \\n \" ; At deinition time the memory of the `iView` array is marked as deallocated. ; The handle (a global structure created by the `ref` opcode) which owns the memory, ; is signaled that no other clients of this data are alive. It deallocates the ; original memory and frees itself endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; test: multiple derefs instr 5 i Xs [] fillarray 0 , 1 , 4 , 9 i ref ref i Xs i Ys [] deref i ref i Zs [] deref i ref printarray i Ys printarray i Zs i Xs [ 0 ] = 100 printarray i Zs turnoff endin ; test performance of pass-by-value vs pass-by-reference opcode arrayadd , i[] , i[]i ; pass by value in and out i In [], i x xin i Out [] = i In + i x xout i Out endop opcode arrayaddref , i[] , ii ; pass by ref in, by value out i ref , i x xin i In [] deref i ref i Out [] = i In + i x xout i Out endop opcode arrayadd_inplace , 0 , ii ; in place i ref , i x xin i In [] deref i ref i In += i x endop opcode arrayadd_byref_inout , 0 , iii ; pass by ref in and out i refin , i refout , i x xin i In [] deref i refin i Out [] deref i refout if lenarray ( i Out ) >= lenarray ( i In ) then i Out = i In + i x endif endop instr testUdoPerformance1 ; Here we test the performance gain of passing arrays by reference. ; Passing the input array by reference seems to produce a speedup of ~25%, i num = 10000 i Xs [] genarray 0 , i num i i = 0 i t0 rtclock while i i < 20 do i Ys [] arrayadd i Xs , 2.0 i i += 1 od i t1 rtclock prints \"Dur UDO pass by value = %.8f \\n \" , i t1 - i t0 i ref = ref ( i Xs ) i t0 rtclock i Y0 [] arrayaddref i ref , 0.1 i Y0 arrayaddref i ref , 0.2 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i t1 rtclock prints \"Dur UDO pass by ref input = %.8f \\n \" , i t1 - i t0 i Zs [] genarray 0 , i num i Out [] init lenarray ( i Zs ) i t0 rtclock i refZ = ref ( i Zs ) i refOut = ref ( i Out ) arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 i t1 rtclock prints \"Dur UDO pass by ref in and out= %.8f \\n \" , i t1 - i t0 ; printarray iOut endin instr 7 i In [] genarray 0 , 1000 i Out [] init lenarray ( i In ) arrayadd_byref_inout ref ( i In ), ref ( i Out ), 0.5 turnoff endin instr 8 ; test k arrays ; 1. A way to convert a i-array to a k-array by taking a reference i Xs [] genarray 0 , 99 k Xs [] deref ref ( i Xs ) k Xs [ 0 ] = timeinsts () printarray k Xs , metro ( 8 ) endin instr 9 ; we need genarray_i because otherwise kXs is not initialized at i-time k Xs [] genarray 0 , 9 i Xs [] deref ref ( k Xs ) i Xs += 10 printarray i Xs printarray k Xs turnoff endin ; schedule 1, 0, 1 ; schedule 3, 0, 1 ; schedule 5, 0, 0.1 schedule \"testUdoPerformance1\" , 0 , 0.1 ; schedule 8, 0, 4 </ CsInstruments > < CsScore > e 10 </ CsScore > </ CsoundSynthesizer > See also ref defer schedule event release Credits Eduardo Moguillansky, 2019","title":"deref"},{"location":"opcodes/deref.html#deref","text":"","title":"deref"},{"location":"opcodes/deref.html#abstract","text":"Dereference a previously created reference to a variable","title":"Abstract"},{"location":"opcodes/deref.html#description","text":"ref and deref implement a mechanism to pass a reference to any object, allowing to share a variable across instruments, with opcodes, etc. A ref is reference counted and deallocates itself when it falls out of scope without being referenced by any object. It makes it possible to pass arrays by reference to user defined opcodes, allowing to modify an array inplace, skip copying memory, etc.","title":"Description"},{"location":"opcodes/deref.html#syntax","text":"xArray deref iref, iextrarefs=0","title":"Syntax"},{"location":"opcodes/deref.html#arguments","text":"iref : a reference index as created via ref iextrarefs : extra references used, matching any extra reference allocated via ref (see ref for more information)","title":"Arguments"},{"location":"opcodes/deref.html#output","text":"xArray / xvar : are created as a view of the object originally passed to ref","title":"Output"},{"location":"opcodes/deref.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/deref.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > ;; Example file for ref - deref sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gi A [] fillarray 0 , 1000 , 2000 , 3000 ; Example 1: take a ref from an array, deref it to create a second view of it instr 1 ; a source array i X [] fillarray 0 , 10 , 20 , 30 , 40 ; create a ref of iXs, return the index i ref ref i X ; now iYs points to iXs i Y [] deref i ref printarray i Y , \"\" , \"instrument 1, iY\" i Z [] fillarray 0 , 1 , 3 , 5 , 7 ; create a ref, pass it to instr. 2 schedule 2 , 0 , 1 , ref ( i Z ) ; create another ref of iZ. In this case the event is scheduled ; in the future, so the source will not exist anymore when instr. 2 ; is scheduled. This should fail. schedule 2 , 1 , 1 , ref ( i Z ) turnoff endin instr 2 i ref = p4 if refvalid ( i ref ) == 1 then i Zs [] deref i ref printarray i Zs , \"\" , \"p1=2, iZs\" else prints \" \\n The reference has become invalid \\n \" endif turnoff endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; Example 2: extra references to keep array alive instr 3 ; create a source array k Xs [] fillarray 1 , 1 , 2 , 3 , 5 , 8 , 13 ; In order to bridge the time gap between the end of life of the source ; of a ref and the scheduled event where a deref is taken, it is possible ; to create a forward reference, a \"promise\" that one deref has been scheduled ; in the future. ; short lived event, ends before this event schedule 4 , 0 , 0.1 , ref ( k Xs ), 0 ; starts before we end, but survives us schedule 4 , p3 - 0.1 , 0.2 , ref ( k Xs ), 0 ; starts after we end, we need an extra reference schedule 4 , p3 + 1 , 0.1 , ref ( k Xs , 1 ), 1 defer \"prints\" , \" --- instr. 3 finished --- \\n \" endin instr 4 prints \"instr. 4 \\n \" k View [] deref p4 , p5 printarray k View defer \"prints\" , \" --- instr. 4 finished --- \\n \" ; At deinition time the memory of the `iView` array is marked as deallocated. ; The handle (a global structure created by the `ref` opcode) which owns the memory, ; is signaled that no other clients of this data are alive. It deallocates the ; original memory and frees itself endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; test: multiple derefs instr 5 i Xs [] fillarray 0 , 1 , 4 , 9 i ref ref i Xs i Ys [] deref i ref i Zs [] deref i ref printarray i Ys printarray i Zs i Xs [ 0 ] = 100 printarray i Zs turnoff endin ; test performance of pass-by-value vs pass-by-reference opcode arrayadd , i[] , i[]i ; pass by value in and out i In [], i x xin i Out [] = i In + i x xout i Out endop opcode arrayaddref , i[] , ii ; pass by ref in, by value out i ref , i x xin i In [] deref i ref i Out [] = i In + i x xout i Out endop opcode arrayadd_inplace , 0 , ii ; in place i ref , i x xin i In [] deref i ref i In += i x endop opcode arrayadd_byref_inout , 0 , iii ; pass by ref in and out i refin , i refout , i x xin i In [] deref i refin i Out [] deref i refout if lenarray ( i Out ) >= lenarray ( i In ) then i Out = i In + i x endif endop instr testUdoPerformance1 ; Here we test the performance gain of passing arrays by reference. ; Passing the input array by reference seems to produce a speedup of ~25%, i num = 10000 i Xs [] genarray 0 , i num i i = 0 i t0 rtclock while i i < 20 do i Ys [] arrayadd i Xs , 2.0 i i += 1 od i t1 rtclock prints \"Dur UDO pass by value = %.8f \\n \" , i t1 - i t0 i ref = ref ( i Xs ) i t0 rtclock i Y0 [] arrayaddref i ref , 0.1 i Y0 arrayaddref i ref , 0.2 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i t1 rtclock prints \"Dur UDO pass by ref input = %.8f \\n \" , i t1 - i t0 i Zs [] genarray 0 , i num i Out [] init lenarray ( i Zs ) i t0 rtclock i refZ = ref ( i Zs ) i refOut = ref ( i Out ) arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 i t1 rtclock prints \"Dur UDO pass by ref in and out= %.8f \\n \" , i t1 - i t0 ; printarray iOut endin instr 7 i In [] genarray 0 , 1000 i Out [] init lenarray ( i In ) arrayadd_byref_inout ref ( i In ), ref ( i Out ), 0.5 turnoff endin instr 8 ; test k arrays ; 1. A way to convert a i-array to a k-array by taking a reference i Xs [] genarray 0 , 99 k Xs [] deref ref ( i Xs ) k Xs [ 0 ] = timeinsts () printarray k Xs , metro ( 8 ) endin instr 9 ; we need genarray_i because otherwise kXs is not initialized at i-time k Xs [] genarray 0 , 9 i Xs [] deref ref ( k Xs ) i Xs += 10 printarray i Xs printarray k Xs turnoff endin ; schedule 1, 0, 1 ; schedule 3, 0, 1 ; schedule 5, 0, 0.1 schedule \"testUdoPerformance1\" , 0 , 0.1 ; schedule 8, 0, 4 </ CsInstruments > < CsScore > e 10 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/deref.html#see-also","text":"ref defer schedule event release","title":"See also"},{"location":"opcodes/deref.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_del.html","text":"dict_del Abstract Remove a key:value pair from a hashtable Description A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_del removes a key:value pair from the hashtable. If both dict and key are i- variables, dict_del executes only at i-time. Otherwise it executes at every k- cycle. Use an if guard to prevent this, if so needed . To delete a key at the end of an event, use defer Syntax dict_del idict, ikey ; execution at i- time dict_del idict, kkey ; execution at k- time dict_del idict, Skey ; execution at k- time Arguments idict : the handle of the dict, as returned by dict_new ikey / kkey / Skey : the key to remove Execution Time Init Performance Example < CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" dict_free i dict ; set key a key:value pair dict_set i dict , \"bar\" , 123 dict_print i dict dict_del i dict , \"bar\" dict_print i dict turnoff endin </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > See also dict_new dict_get dict_set defer dict_free Credits Eduardo Moguillansky, 2019 Last update: 2021","title":"dict_del"},{"location":"opcodes/dict_del.html#dict_del","text":"","title":"dict_del"},{"location":"opcodes/dict_del.html#abstract","text":"Remove a key:value pair from a hashtable","title":"Abstract"},{"location":"opcodes/dict_del.html#description","text":"A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_del removes a key:value pair from the hashtable. If both dict and key are i- variables, dict_del executes only at i-time. Otherwise it executes at every k- cycle. Use an if guard to prevent this, if so needed . To delete a key at the end of an event, use defer","title":"Description"},{"location":"opcodes/dict_del.html#syntax","text":"dict_del idict, ikey ; execution at i- time dict_del idict, kkey ; execution at k- time dict_del idict, Skey ; execution at k- time","title":"Syntax"},{"location":"opcodes/dict_del.html#arguments","text":"idict : the handle of the dict, as returned by dict_new ikey / kkey / Skey : the key to remove","title":"Arguments"},{"location":"opcodes/dict_del.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/dict_del.html#example","text":"< CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" dict_free i dict ; set key a key:value pair dict_set i dict , \"bar\" , 123 dict_print i dict dict_del i dict , \"bar\" dict_print i dict turnoff endin </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer >","title":"Example"},{"location":"opcodes/dict_del.html#see-also","text":"dict_new dict_get dict_set defer dict_free","title":"See also"},{"location":"opcodes/dict_del.html#credits","text":"Eduardo Moguillansky, 2019 Last update: 2021","title":"Credits"},{"location":"opcodes/dict_dump.html","text":"dict_dump Abstract Dumps the contents of this dict as a string Description dict_dump serializes the contents of a dict to a string which can be used to reconstruct such dict. Here is an example of such a string definition: \"keyA: 10, keyB: string value, keyC: 'quoted string'\" This string can be used to load the contents of a dict via dict_loadstr . At the moment only dicts with string keys can be dumped. The motivation behind this opcode is to be able to save a dict to a string, for example in a textfile or in the metadata of a soundfile, and be able to retrieve that as a dict later, in csound or in anothe software. Syntax Sdump dict_dump idict Arguments idict : the dict handle Sdump : the string defining the key:value pairs Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* # Example file for dict_dump ## dict_dump Sdump dict_dump idict Dump the contents of the dict to a string, in the following format: \"keyA: valueA, keyB: valueB, ...\" This string can be used to load the contents of a dict via dict_loadstr. At the moment only dicts with string keys can be dumped. The motivation behind this opcode is to be able to save a dict to a string, for example in a textfile or in the metadata of a soundfile, and be able to retrieve that as a dict later, in csound or in anothe software. */ instr example1 ; Uncomment to test with different dict types ; idict dict_new \"str:float\", \"foo\", 10.1, \"bar\", 0.5, \"baz\", 0.12345678 i dict dict_new \"str:any\" , \"foo\" , 10.1 , \"baz\" , 0.12345678 , \"bar\" , \"barvalue\" ; idict dict_new \"str:str\", \"foo\", \"fooval\", \"bar\", \"barval\" S dump dict_dump i dict prints \" \\n dump: < \\n %s \\n > \\n\\n \" , S dump prints \" \\n --- idict --- \\n \" dict_print i dict i dict2 dict_loadstr S dump prints \" \\n --- idict2 --- \\n \" dict_print i dict2 prints \" \\n \" turnoff endin </ CsInstruments > < CsScore > i \"example1\" 0 0.1 </ CsScore > </ CsoundSynthesizer > See also dict_loadstr dict_new dict_set sfreadmeta Credits Eduardo Moguillansky, 2021","title":"dict_dump"},{"location":"opcodes/dict_dump.html#dict_dump","text":"","title":"dict_dump"},{"location":"opcodes/dict_dump.html#abstract","text":"Dumps the contents of this dict as a string","title":"Abstract"},{"location":"opcodes/dict_dump.html#description","text":"dict_dump serializes the contents of a dict to a string which can be used to reconstruct such dict. Here is an example of such a string definition: \"keyA: 10, keyB: string value, keyC: 'quoted string'\" This string can be used to load the contents of a dict via dict_loadstr . At the moment only dicts with string keys can be dumped. The motivation behind this opcode is to be able to save a dict to a string, for example in a textfile or in the metadata of a soundfile, and be able to retrieve that as a dict later, in csound or in anothe software.","title":"Description"},{"location":"opcodes/dict_dump.html#syntax","text":"Sdump dict_dump idict","title":"Syntax"},{"location":"opcodes/dict_dump.html#arguments","text":"idict : the dict handle Sdump : the string defining the key:value pairs","title":"Arguments"},{"location":"opcodes/dict_dump.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/dict_dump.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* # Example file for dict_dump ## dict_dump Sdump dict_dump idict Dump the contents of the dict to a string, in the following format: \"keyA: valueA, keyB: valueB, ...\" This string can be used to load the contents of a dict via dict_loadstr. At the moment only dicts with string keys can be dumped. The motivation behind this opcode is to be able to save a dict to a string, for example in a textfile or in the metadata of a soundfile, and be able to retrieve that as a dict later, in csound or in anothe software. */ instr example1 ; Uncomment to test with different dict types ; idict dict_new \"str:float\", \"foo\", 10.1, \"bar\", 0.5, \"baz\", 0.12345678 i dict dict_new \"str:any\" , \"foo\" , 10.1 , \"baz\" , 0.12345678 , \"bar\" , \"barvalue\" ; idict dict_new \"str:str\", \"foo\", \"fooval\", \"bar\", \"barval\" S dump dict_dump i dict prints \" \\n dump: < \\n %s \\n > \\n\\n \" , S dump prints \" \\n --- idict --- \\n \" dict_print i dict i dict2 dict_loadstr S dump prints \" \\n --- idict2 --- \\n \" dict_print i dict2 prints \" \\n \" turnoff endin </ CsInstruments > < CsScore > i \"example1\" 0 0.1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_dump.html#see-also","text":"dict_loadstr dict_new dict_set sfreadmeta","title":"See also"},{"location":"opcodes/dict_dump.html#credits","text":"Eduardo Moguillansky, 2021","title":"Credits"},{"location":"opcodes/dict_exists.html","text":"dict_exists Abstract Returns 1 if the dict exists, 0 otherwise Description dict_exists checks if the index passed refers to an existing dict and returns 1 if it does, 0 otherwise. It works at i-time only Syntax iexists dict_exists idict Arguments \u00ecdict : the handle of the dict, as returned by dict_new Output iexists : 1 of the dict exists, 0 otherwise Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for dict_exists iexists dict_exists idict */ opcode accum , k , ko k step , i val xin k now init i val xout k now k now += k step endop instr 1 i dict = p4 print i dict if ( dict_exists ( i dict ) == 1 ) then k foo dict_get i dict , \"foo\" k bar dict_get i dict , \"bar\" ; dict_free idict, 1 else k foo init 10 k bar init 20 endif printf \"$$$ foo= %f bar= %f \\n \" , accum ( changed ( k foo , k bar )), k foo , k bar endin instr 2 i dict dict_new \"str:float\" , \"foo\" , 1 , \"bar\" , 2 schedule 1 , 0 , p3 , i dict dict_set i dict , \"foo\" , linseg : k ( 1 , p3 , 2 ) dict_set i dict , \"bar\" , linseg : k ( 2 , p3 , 3 ) endin instr 3 schedule 1 , 0 , p3 , - 1 endin </ CsInstruments > < CsScore > i 2 0 1 i 3 4 4 </ CsScore > </ CsoundSynthesizer > See also dict_iter dict_size dict_query Credits Eduardo Moguillansky, 2019","title":"dict_exists"},{"location":"opcodes/dict_exists.html#dict_exists","text":"","title":"dict_exists"},{"location":"opcodes/dict_exists.html#abstract","text":"Returns 1 if the dict exists, 0 otherwise","title":"Abstract"},{"location":"opcodes/dict_exists.html#description","text":"dict_exists checks if the index passed refers to an existing dict and returns 1 if it does, 0 otherwise. It works at i-time only","title":"Description"},{"location":"opcodes/dict_exists.html#syntax","text":"iexists dict_exists idict","title":"Syntax"},{"location":"opcodes/dict_exists.html#arguments","text":"\u00ecdict : the handle of the dict, as returned by dict_new","title":"Arguments"},{"location":"opcodes/dict_exists.html#output","text":"iexists : 1 of the dict exists, 0 otherwise","title":"Output"},{"location":"opcodes/dict_exists.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/dict_exists.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for dict_exists iexists dict_exists idict */ opcode accum , k , ko k step , i val xin k now init i val xout k now k now += k step endop instr 1 i dict = p4 print i dict if ( dict_exists ( i dict ) == 1 ) then k foo dict_get i dict , \"foo\" k bar dict_get i dict , \"bar\" ; dict_free idict, 1 else k foo init 10 k bar init 20 endif printf \"$$$ foo= %f bar= %f \\n \" , accum ( changed ( k foo , k bar )), k foo , k bar endin instr 2 i dict dict_new \"str:float\" , \"foo\" , 1 , \"bar\" , 2 schedule 1 , 0 , p3 , i dict dict_set i dict , \"foo\" , linseg : k ( 1 , p3 , 2 ) dict_set i dict , \"bar\" , linseg : k ( 2 , p3 , 3 ) endin instr 3 schedule 1 , 0 , p3 , - 1 endin </ CsInstruments > < CsScore > i 2 0 1 i 3 4 4 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_exists.html#see-also","text":"dict_iter dict_size dict_query","title":"See also"},{"location":"opcodes/dict_exists.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_free.html","text":"dict_free Abstract Free a hashtable Description frees the hashtable either at init time or at the end of the note (similar to ftfree) To be able to pass a dict between notes, a note can create a global dict and pass its handle to another note. When the first note is released, the dict lives on (because it is global), and it will be either freed at the end of the performance or explicitely by calling dict_free dict_free executes only at init time . Syntax dict_free idict [, iwhen=1] Arguments idict : the handle of the dict to be freed iwhen : similar to ftfree if iwhen == 0 : free the dict now if iwhen == 1 : free the dict at the end of this note (the default) Execution Time Init Examples < CsoundSynthesizer > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > See also dict_new Credits Eduardo Moguillansky, 2019","title":"dict_free"},{"location":"opcodes/dict_free.html#dict_free","text":"","title":"dict_free"},{"location":"opcodes/dict_free.html#abstract","text":"Free a hashtable","title":"Abstract"},{"location":"opcodes/dict_free.html#description","text":"frees the hashtable either at init time or at the end of the note (similar to ftfree) To be able to pass a dict between notes, a note can create a global dict and pass its handle to another note. When the first note is released, the dict lives on (because it is global), and it will be either freed at the end of the performance or explicitely by calling dict_free dict_free executes only at init time .","title":"Description"},{"location":"opcodes/dict_free.html#syntax","text":"dict_free idict [, iwhen=1]","title":"Syntax"},{"location":"opcodes/dict_free.html#arguments","text":"idict : the handle of the dict to be freed iwhen : similar to ftfree if iwhen == 0 : free the dict now if iwhen == 1 : free the dict at the end of this note (the default)","title":"Arguments"},{"location":"opcodes/dict_free.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/dict_free.html#examples","text":"< CsoundSynthesizer > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_free.html#see-also","text":"dict_new","title":"See also"},{"location":"opcodes/dict_free.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_get.html","text":"dict_get Abstract Get a value from a hashtable Description A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_get returns the value for a given key. If the key is not present, a default value is returned (the empty string for string values, or an user given default for number values) Syntax kvalue dict_get idict, Skey, idefault=0 ivalue dict_get idict, Skey, idefault=0 kvalue dict_get idict, kkey, idefault=0 ivalue dict_get idict, ikey, idefault=0 Svalue dict_get idict, Skey Svalue dict_geti idict, Skey ; (init time version) Svalue dict_get idict, kkey The type of key and value depend on the type definition of the dict , see dict_new dict_get executes at i-time and k-time depending on the output value. In the case of a dict of type \"str:str\" dict_get runs at k-time. Use dict_geti for an init time version Note In the case of a dict of type \"str:str\", dict_get returns an empty string if the key is not found Arguments \u00ecdict : the handle of the dict, as returned by dict_new Skey / kkey : the key to be queries, as previously set by dict_set idefault : if the key is not present, this value is returned (defaults to 0) Output kvalue / Svalue : the value corresponding to the key, or a default if the key is not found For dicts with a string value, an empty string is returned when the key is not found. For dicts with a numeric value, a user given default is returned (default=0) Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > < CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > /* # Example file for dict_get ## dict_get kvalue dict_get idict, \"key\" [, kdefault=0] Get the value at a given key. For string values, an empty string is returned when the key is not found. For int values, a default value given by the user is returned when the key is not found. */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" dict_free i dict ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve teh value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, mapping strings to strings i dict2 dict_new \"ss\" dict_set i dict2 , \"baz\" , \"bazvalue\" dict_set i dict2 , \"hoo\" , \"hoovalue\" S baz dict_get i dict2 , \"baz\" S hoo dict_get i dict2 , \"hoo\" printf \">>>> baz: %s , hoo: %s \\n \" , 1 , S baz , S hoo turnoff endin instr 2 ;; set and get if timeinstk () > 1 kgoto perf ;; this starts at 1 i maxcnt = 100 i dict dict_new \"ss\" k cnt = 0 while k cnt < i maxcnt do S key sprintfk \"key_ %d \" , k cnt S value sprintfk \"value_ %d \" , k cnt dict_set i dict , S key , S value k cnt += 1 od perf : k cnt = 0 while k cnt < i maxcnt do S key sprintfk \"key_ %d \" , k cnt ; the same for get, the key can change at k-time S value dict_get i dict , S key printf \"key: %s , value: %s \\n \" , k cnt , S key , S value k cnt += 1 od endin instr 3 /* dict_iter xkey, xvalue, kidx dict_iter ihandle [,kreset=1] kidx: holds the number of pairs yielded since last reset. It is set to -1 when iteration has stopped (in this case, xkey and xvalue are invalid and should not be used) kreset = 0 -> after iterating over all pairs iteration stops In this mode, iteration happens at most once 1 -> iteration starts over every k-cycle 2 -> iteration restarts after stopping */ k t timeinstk if k t > 1 kgoto perf i dict dict_new \"sf\" dict_set i dict , \"foo\" , 1 dict_set i dict , \"bar\" , 2 dict_set i dict , \"baz\" , 15 dict_set i dict , \"bee\" , 9 perf : ; iterate with a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"while) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value od ; the same but with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"loop) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value kgoto loop break : endin instr 4 ; test deleting a key ; ~~~~~~~~~~~~~~~~~~~ i dict dict_new \"ss\" ; set a key:value pair dict_set i dict , \"foo\" , \"foovalue\" ; get the value, print it S foo dict_get i dict , \"foo\" printf \"key: foo value: %s \\n \" , 1 , S foo ; dict_set without value deletes the key:value pair dict_set i dict , \"foo\" ; now check that the pair is gone S foo dict_get i dict , \"foo\" if ( strlen ( S foo ) == 0 ) then printf \"key does not exist \\n \" , 1 endif turnoff endin instr 5 ; dicts can be passed between instruments ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ if timeinstk () > 1 goto perf ; create a dict which survives this note i dict1 dict_new \"sf\" , 1 ; set some initial values once dict_set i dict1 , \"foo\" , 1 dict_set i dict1 , \"bar\" , 2 ; launch instr 6, which will outlive this note, pass idict as p4 event \"i\" , \"midifydict\" , 0 , p3 + 1 , i dict1 perf : k foo dict_get i dict1 , \"foo\" printk2 k foo endin instr modifydict ; here we modify instr 5's dictionary ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; the dict was created by instr 5 i dict = p4 k foo line 0 , p3 - 1 , 10 dict_set i dict , \"foo\" , k foo dict_free i dict , 1 ; 1 = free dict when note ends endin instr 7 ; it is possible to create a new dict and set initial ; values at once. This is only executed at i-time i dict dict_new \"sf\" , 0 , \"foo\" , 10 , \"bar\" , 20 , \"baz\" , 30 k baz dict_get i dict , \"baz\" k bar dict_get i dict , \"bar\" k xx dict_get i dict , \"xx\" , 99 printf \"baz: %f bar: %f xx: %f \\n \" , 1 , k baz , k bar , k xx turnoff endin instr 8 ; get all the keys as an array i dict1 dict_new \"sf\" , 0 , \"keyA\" , 1 , \"keyB\" , 2 , \"keyC\" , 3 S Keys [] dict_query i dict1 , \"keys\" printarray S Keys i dict2 dict_new \"if\" , 0 , 1 , 100 , 10 , 1000 , 2 , 200 k Keys [] dict_query i dict2 , \"keys\" printarray k Keys , 1 , \" %.0f \" ; get values as an array i dict3 dict_new \"is\" , 0 , 10 , \"foo\" , 20 , \"bar\" , 30 , \"baz\" S vals [] dict_query i dict3 , \"values\" printarray S vals k Vals [] dict_query i dict2 , \"values\" printarray k Vals turnoff endin ; One convenient use of dicts is to pass arguments to an instr instr 100 ; create our communication dict, set initial values i dict dict_new \"sf\" , \"amp\" , 0.1 , \"freq\" , 1000 ; the launched instr will last longer, so will have to deal with ; this dict ceasing to exist event_i \"i\" , 101 , 0 , p3 + 1 , i dict ; now we can control the synth with the dict dict_set i dict , \"freq\" , linseg : k ( 440 , p3 , 455 ) a 0 oscili 0.1 , 440 outch 1 , a 0 endin ; a variation on dict_get where we either get the value corresponding to a key, ; or the last value, if the dict does not exist opcode dict_receive , k , iSi i dict , S key , i val0 xin k last init i val0 if ( dict_size ( i dict ) > 0 ) then k val dict_get i dict , S key , i val0 k last = k val else k val = k last endif xout k val endop instr 101 i dict = p4 ; get the value for a given key. when the dict does not exist, just ; outputs the last value k amp dict_receive i dict , \"amp\" , 0.1 k freq dict_receive i dict , \"freq\" , 1000 a 0 oscili k amp , k freq outch 2 , a 0 endin instr 200 i dict dict_new \"str:any\" , \"foo\" , \"fooval\" , \"bar\" , 10 dict_print i dict S foo dict_get i dict , \"foo\" k bar dict_get i dict , \"bar\" printf \"foo= %s , bar= %f \\n \" , 1 , S foo , k bar dict_set i dict , \"baz\" , 0.5 i baz dict_get i dict , \"baz\" S moo = \"moo!\" dict_set i dict , \"moo\" , S moo printf \"baz= %f , moo= %s \\n \" , 1 , i baz , S moo turnoff endin </ CsInstruments > < CsScore > ; i 1 0 0.01 ; i 2 0 0.01 ; i 8 0 0.1 ; i 100 0 10 i 200 0 1 f 0 1 </ CsScore > </ CsoundSynthesizer > See also dict_new dict_set dict_geti dict_get Credits Eduardo Moguillansky, 2019","title":"dict_get"},{"location":"opcodes/dict_get.html#dict_get","text":"","title":"dict_get"},{"location":"opcodes/dict_get.html#abstract","text":"Get a value from a hashtable","title":"Abstract"},{"location":"opcodes/dict_get.html#description","text":"A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_get returns the value for a given key. If the key is not present, a default value is returned (the empty string for string values, or an user given default for number values)","title":"Description"},{"location":"opcodes/dict_get.html#syntax","text":"kvalue dict_get idict, Skey, idefault=0 ivalue dict_get idict, Skey, idefault=0 kvalue dict_get idict, kkey, idefault=0 ivalue dict_get idict, ikey, idefault=0 Svalue dict_get idict, Skey Svalue dict_geti idict, Skey ; (init time version) Svalue dict_get idict, kkey The type of key and value depend on the type definition of the dict , see dict_new dict_get executes at i-time and k-time depending on the output value. In the case of a dict of type \"str:str\" dict_get runs at k-time. Use dict_geti for an init time version Note In the case of a dict of type \"str:str\", dict_get returns an empty string if the key is not found","title":"Syntax"},{"location":"opcodes/dict_get.html#arguments","text":"\u00ecdict : the handle of the dict, as returned by dict_new Skey / kkey : the key to be queries, as previously set by dict_set idefault : if the key is not present, this value is returned (defaults to 0)","title":"Arguments"},{"location":"opcodes/dict_get.html#output","text":"kvalue / Svalue : the value corresponding to the key, or a default if the key is not found For dicts with a string value, an empty string is returned when the key is not found. For dicts with a numeric value, a user given default is returned (default=0)","title":"Output"},{"location":"opcodes/dict_get.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/dict_get.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > < CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > /* # Example file for dict_get ## dict_get kvalue dict_get idict, \"key\" [, kdefault=0] Get the value at a given key. For string values, an empty string is returned when the key is not found. For int values, a default value given by the user is returned when the key is not found. */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" dict_free i dict ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve teh value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, mapping strings to strings i dict2 dict_new \"ss\" dict_set i dict2 , \"baz\" , \"bazvalue\" dict_set i dict2 , \"hoo\" , \"hoovalue\" S baz dict_get i dict2 , \"baz\" S hoo dict_get i dict2 , \"hoo\" printf \">>>> baz: %s , hoo: %s \\n \" , 1 , S baz , S hoo turnoff endin instr 2 ;; set and get if timeinstk () > 1 kgoto perf ;; this starts at 1 i maxcnt = 100 i dict dict_new \"ss\" k cnt = 0 while k cnt < i maxcnt do S key sprintfk \"key_ %d \" , k cnt S value sprintfk \"value_ %d \" , k cnt dict_set i dict , S key , S value k cnt += 1 od perf : k cnt = 0 while k cnt < i maxcnt do S key sprintfk \"key_ %d \" , k cnt ; the same for get, the key can change at k-time S value dict_get i dict , S key printf \"key: %s , value: %s \\n \" , k cnt , S key , S value k cnt += 1 od endin instr 3 /* dict_iter xkey, xvalue, kidx dict_iter ihandle [,kreset=1] kidx: holds the number of pairs yielded since last reset. It is set to -1 when iteration has stopped (in this case, xkey and xvalue are invalid and should not be used) kreset = 0 -> after iterating over all pairs iteration stops In this mode, iteration happens at most once 1 -> iteration starts over every k-cycle 2 -> iteration restarts after stopping */ k t timeinstk if k t > 1 kgoto perf i dict dict_new \"sf\" dict_set i dict , \"foo\" , 1 dict_set i dict , \"bar\" , 2 dict_set i dict , \"baz\" , 15 dict_set i dict , \"bee\" , 9 perf : ; iterate with a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"while) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value od ; the same but with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"loop) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value kgoto loop break : endin instr 4 ; test deleting a key ; ~~~~~~~~~~~~~~~~~~~ i dict dict_new \"ss\" ; set a key:value pair dict_set i dict , \"foo\" , \"foovalue\" ; get the value, print it S foo dict_get i dict , \"foo\" printf \"key: foo value: %s \\n \" , 1 , S foo ; dict_set without value deletes the key:value pair dict_set i dict , \"foo\" ; now check that the pair is gone S foo dict_get i dict , \"foo\" if ( strlen ( S foo ) == 0 ) then printf \"key does not exist \\n \" , 1 endif turnoff endin instr 5 ; dicts can be passed between instruments ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ if timeinstk () > 1 goto perf ; create a dict which survives this note i dict1 dict_new \"sf\" , 1 ; set some initial values once dict_set i dict1 , \"foo\" , 1 dict_set i dict1 , \"bar\" , 2 ; launch instr 6, which will outlive this note, pass idict as p4 event \"i\" , \"midifydict\" , 0 , p3 + 1 , i dict1 perf : k foo dict_get i dict1 , \"foo\" printk2 k foo endin instr modifydict ; here we modify instr 5's dictionary ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; the dict was created by instr 5 i dict = p4 k foo line 0 , p3 - 1 , 10 dict_set i dict , \"foo\" , k foo dict_free i dict , 1 ; 1 = free dict when note ends endin instr 7 ; it is possible to create a new dict and set initial ; values at once. This is only executed at i-time i dict dict_new \"sf\" , 0 , \"foo\" , 10 , \"bar\" , 20 , \"baz\" , 30 k baz dict_get i dict , \"baz\" k bar dict_get i dict , \"bar\" k xx dict_get i dict , \"xx\" , 99 printf \"baz: %f bar: %f xx: %f \\n \" , 1 , k baz , k bar , k xx turnoff endin instr 8 ; get all the keys as an array i dict1 dict_new \"sf\" , 0 , \"keyA\" , 1 , \"keyB\" , 2 , \"keyC\" , 3 S Keys [] dict_query i dict1 , \"keys\" printarray S Keys i dict2 dict_new \"if\" , 0 , 1 , 100 , 10 , 1000 , 2 , 200 k Keys [] dict_query i dict2 , \"keys\" printarray k Keys , 1 , \" %.0f \" ; get values as an array i dict3 dict_new \"is\" , 0 , 10 , \"foo\" , 20 , \"bar\" , 30 , \"baz\" S vals [] dict_query i dict3 , \"values\" printarray S vals k Vals [] dict_query i dict2 , \"values\" printarray k Vals turnoff endin ; One convenient use of dicts is to pass arguments to an instr instr 100 ; create our communication dict, set initial values i dict dict_new \"sf\" , \"amp\" , 0.1 , \"freq\" , 1000 ; the launched instr will last longer, so will have to deal with ; this dict ceasing to exist event_i \"i\" , 101 , 0 , p3 + 1 , i dict ; now we can control the synth with the dict dict_set i dict , \"freq\" , linseg : k ( 440 , p3 , 455 ) a 0 oscili 0.1 , 440 outch 1 , a 0 endin ; a variation on dict_get where we either get the value corresponding to a key, ; or the last value, if the dict does not exist opcode dict_receive , k , iSi i dict , S key , i val0 xin k last init i val0 if ( dict_size ( i dict ) > 0 ) then k val dict_get i dict , S key , i val0 k last = k val else k val = k last endif xout k val endop instr 101 i dict = p4 ; get the value for a given key. when the dict does not exist, just ; outputs the last value k amp dict_receive i dict , \"amp\" , 0.1 k freq dict_receive i dict , \"freq\" , 1000 a 0 oscili k amp , k freq outch 2 , a 0 endin instr 200 i dict dict_new \"str:any\" , \"foo\" , \"fooval\" , \"bar\" , 10 dict_print i dict S foo dict_get i dict , \"foo\" k bar dict_get i dict , \"bar\" printf \"foo= %s , bar= %f \\n \" , 1 , S foo , k bar dict_set i dict , \"baz\" , 0.5 i baz dict_get i dict , \"baz\" S moo = \"moo!\" dict_set i dict , \"moo\" , S moo printf \"baz= %f , moo= %s \\n \" , 1 , i baz , S moo turnoff endin </ CsInstruments > < CsScore > ; i 1 0 0.01 ; i 2 0 0.01 ; i 8 0 0.1 ; i 100 0 10 i 200 0 1 f 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_get.html#see-also","text":"dict_new dict_set dict_geti dict_get","title":"See also"},{"location":"opcodes/dict_get.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_geti.html","text":"dict_geti Abstract Get a string value from a hashtable at init time Description For dicts of type str:str or str:any, this version of dict_get runs at init-time only. See dict_get for any further details Syntax Svalue dict_geti idict, Skey Arguments \u00ecdict : the handle of the dict, as returned by dict_new Skey / kkey : the key to be queries, as previously set by dict_set Output Svalue : the value corresponding to the key Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* # Example file for dict_geti ## dict_geti Svalue dict_geti idict, Skey Get the value at a given key at init time. An empty string is returned when the key is not found. */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sa\" , \"foo\" , \"foovalue\" , \"bar\" , 10 S foo dict_geti i dict , \"foo\" prints \"Soo: %s \\n \" , S foo turnoff endin </ CsInstruments > < CsScore > i 1 0 0.01 f 0 1 </ CsScore > </ CsoundSynthesizer > See also dict_new dict_set dict_get Credits Eduardo Moguillansky, 2020","title":"dict_geti"},{"location":"opcodes/dict_geti.html#dict_geti","text":"","title":"dict_geti"},{"location":"opcodes/dict_geti.html#abstract","text":"Get a string value from a hashtable at init time","title":"Abstract"},{"location":"opcodes/dict_geti.html#description","text":"For dicts of type str:str or str:any, this version of dict_get runs at init-time only. See dict_get for any further details","title":"Description"},{"location":"opcodes/dict_geti.html#syntax","text":"Svalue dict_geti idict, Skey","title":"Syntax"},{"location":"opcodes/dict_geti.html#arguments","text":"\u00ecdict : the handle of the dict, as returned by dict_new Skey / kkey : the key to be queries, as previously set by dict_set","title":"Arguments"},{"location":"opcodes/dict_geti.html#output","text":"Svalue : the value corresponding to the key","title":"Output"},{"location":"opcodes/dict_geti.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/dict_geti.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* # Example file for dict_geti ## dict_geti Svalue dict_geti idict, Skey Get the value at a given key at init time. An empty string is returned when the key is not found. */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sa\" , \"foo\" , \"foovalue\" , \"bar\" , 10 S foo dict_geti i dict , \"foo\" prints \"Soo: %s \\n \" , S foo turnoff endin </ CsInstruments > < CsScore > i 1 0 0.01 f 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_geti.html#see-also","text":"dict_new dict_set dict_get","title":"See also"},{"location":"opcodes/dict_geti.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/dict_iter.html","text":"dict_iter Abstract Iterate over the key-value pairs of a dict Description Iterates over the key:value pairs. Whenever kreset is 1, iteration starts over If kreset is -1 (the default), iteration is autotriggered when it reaches the end of the collection. dict_loop executes only at Performance Time . Note dict_iter is meant to be used in a loop at k-time Syntax xkey, xvalue, kidx dict_iter idict [, kreset = -1] Arguments idict : the handle to the dict as returned by dict_new kreset : the reset policy kreset effect 0 no reset, iteration stops at the end of the collection. There will be at most 1 iteration 1 (default) Iteration starts over at every k-cycle 2 Reset at the end of iteration (independent of k-cycle) Output xkey / xvalue : the key and value for this pair. The types are determined by the type of this dict, as defined via dict_new kidx : the index of this pair. It will be 0 for the first pair, 1 for the second, etc. When no more pairs, kidx will be -1. In this case, xkey and xvalue do not hold valid values Execution time Performance Usage There are two ways to use dict_iter , either in a while loop, or using gotos ; iterate in a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"key: %s value: %f \" , k idx , S key , k value od ; iterate with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"key: %s value: %f \" , k idx , S key , k value kgoto loop break : Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* # Example file for dict_iter opcode */ instr 1 /* dict_iter xkey, xvalue, kidx dict_iter ihandle [,kreset=1] kidx: holds the number of pairs yielded since last reset. It is set to -1 when iteration has stopped (in this case, xkey and xvalue are invalid and should not be used) kreset = 0 -> after iterating over all pairs iteration stops In this mode, iteration happens at most once 1 -> iteration starts over every k-cycle 2 -> iteration restarts after stopping */ i dict dict_new \"str:float\" , 0 , \"foo\" , 1 , \"bar\" , 2 , \"baz\" , 15 , \"bee\" , 9 k t timeinstk ; iterate with a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"while) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value od ; the same but with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"loop) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value kgoto loop break : endin </ CsInstruments > < CsScore > i 1 0 0.05 </ CsScore > </ CsoundSynthesizer > See also dict_new dict_size Credits Eduardo Moguillansky, 2019","title":"dict_iter"},{"location":"opcodes/dict_iter.html#dict_iter","text":"","title":"dict_iter"},{"location":"opcodes/dict_iter.html#abstract","text":"Iterate over the key-value pairs of a dict","title":"Abstract"},{"location":"opcodes/dict_iter.html#description","text":"Iterates over the key:value pairs. Whenever kreset is 1, iteration starts over If kreset is -1 (the default), iteration is autotriggered when it reaches the end of the collection. dict_loop executes only at Performance Time . Note dict_iter is meant to be used in a loop at k-time","title":"Description"},{"location":"opcodes/dict_iter.html#syntax","text":"xkey, xvalue, kidx dict_iter idict [, kreset = -1]","title":"Syntax"},{"location":"opcodes/dict_iter.html#arguments","text":"idict : the handle to the dict as returned by dict_new kreset : the reset policy kreset effect 0 no reset, iteration stops at the end of the collection. There will be at most 1 iteration 1 (default) Iteration starts over at every k-cycle 2 Reset at the end of iteration (independent of k-cycle)","title":"Arguments"},{"location":"opcodes/dict_iter.html#output","text":"xkey / xvalue : the key and value for this pair. The types are determined by the type of this dict, as defined via dict_new kidx : the index of this pair. It will be 0 for the first pair, 1 for the second, etc. When no more pairs, kidx will be -1. In this case, xkey and xvalue do not hold valid values","title":"Output"},{"location":"opcodes/dict_iter.html#execution-time","text":"Performance","title":"Execution time"},{"location":"opcodes/dict_iter.html#usage","text":"There are two ways to use dict_iter , either in a while loop, or using gotos ; iterate in a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"key: %s value: %f \" , k idx , S key , k value od ; iterate with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"key: %s value: %f \" , k idx , S key , k value kgoto loop break :","title":"Usage"},{"location":"opcodes/dict_iter.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* # Example file for dict_iter opcode */ instr 1 /* dict_iter xkey, xvalue, kidx dict_iter ihandle [,kreset=1] kidx: holds the number of pairs yielded since last reset. It is set to -1 when iteration has stopped (in this case, xkey and xvalue are invalid and should not be used) kreset = 0 -> after iterating over all pairs iteration stops In this mode, iteration happens at most once 1 -> iteration starts over every k-cycle 2 -> iteration restarts after stopping */ i dict dict_new \"str:float\" , 0 , \"foo\" , 1 , \"bar\" , 2 , \"baz\" , 15 , \"bee\" , 9 k t timeinstk ; iterate with a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"while) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value od ; the same but with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"loop) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value kgoto loop break : endin </ CsInstruments > < CsScore > i 1 0 0.05 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_iter.html#see-also","text":"dict_new dict_size","title":"See also"},{"location":"opcodes/dict_iter.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_loadstr.html","text":"dict_loadstr Abstract Creates and fills a new dict from a string definition Description dict_loadstr creates a new dict and fills it from a string definition. Here is an example of such a string definition: \"keyA: 10, keyB: string value, keyC: 'quoted string'\" The dict created has the type str:any . The keys are always strings and the values can be either numbers or strings. Keys do not need to be quoted. Values only need to be quoted if a string value consists of only numbers or includes itself quotation marks. Quotations must be single quotations: ' The motivation behind this opcode is to be able to save a dictionary to a string, for example in the metadata of a soundfile, and be able to retrieve that as a dictionary inside csound Syntax idict dict_loadstr Sdefinition Arguments Sdefinition : the string defining the key:value pairs idict : the dict handle Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* # Example file for dict_loadstr ## dict_loadstr idict dict_loadstr Sdictdef Create a new dict from a string definition of the form \"keyA: valueA, keyB: valueB, ...\" The dict creates has the type str:any, which means that the keys are always strings and the values can be either numbers or strings. Keys do not need to be quoted. Values only need to be quoted if a string value consists of only numbers or includes itself quotation marks. Quotations must be single quotations: `'` The motivation behind this opcode is to be able to save a dictionary to a string, for example in the metadata of a soundfile, and be able to retrieve that as a dictionary inside csound */ 0dbfs = 1 instr example1 i dict dict_loadstr \"foo: 10, bar :'barvalue', \\n baz: unquoted string\" dict_print i dict turnoff endin instr example2 ; Read the metadata of a .mtx first S comment sfreadmeta \"test.mtx\" , \"comment\" if strlen ( S comment ) == 0 then i niterror \"The .mtx file has no metadata\" endif ; Parse the metadata as a dict i dict dict_loadstr S comment dict_print i dict ; Now we load the data itself. The mtx format consists of a flat array of floats ; where the first numbers include the dimensions of the matrix saved. ; As the columns metadata should show, the mtx file has a header: ; HeaderSize NumRows NumColumns [optionally other values] <The matrix as a flat array> ; The same header is duplicated in the metadata itself, so we can use that directly ; to make the code more self-documenting. i tab ftgen 0 , 0 , 0 , - 1 , \"test.mtx\" , 0 , 0 , 0 ; If the data is needed as an array it is possible to create an alias via memview. ; Otherwise use tab2array to create a copy i Arr [] memview i tab , dict_get : i ( i dict , \"HeaderSize\" ) ; iArr[] tab2array itab, dict_get:i(idict, \"HeaderSize\") ; Now reshape the array to recreate the original matrix reshapearray i Arr , dict_get : i ( i dict , \"NumRows\" ), dict_get : i ( i dict , \"NumColumns\" ) printarray i Arr turnoff endin </ CsInstruments > < CsScore > i \"example2\" 0 0.1 </ CsScore > </ CsoundSynthesizer > See also dict_dump dict_new dict_set sfreadmeta Credits Eduardo Moguillansky, 2021","title":"dict_loadstr"},{"location":"opcodes/dict_loadstr.html#dict_loadstr","text":"","title":"dict_loadstr"},{"location":"opcodes/dict_loadstr.html#abstract","text":"Creates and fills a new dict from a string definition","title":"Abstract"},{"location":"opcodes/dict_loadstr.html#description","text":"dict_loadstr creates a new dict and fills it from a string definition. Here is an example of such a string definition: \"keyA: 10, keyB: string value, keyC: 'quoted string'\" The dict created has the type str:any . The keys are always strings and the values can be either numbers or strings. Keys do not need to be quoted. Values only need to be quoted if a string value consists of only numbers or includes itself quotation marks. Quotations must be single quotations: ' The motivation behind this opcode is to be able to save a dictionary to a string, for example in the metadata of a soundfile, and be able to retrieve that as a dictionary inside csound","title":"Description"},{"location":"opcodes/dict_loadstr.html#syntax","text":"idict dict_loadstr Sdefinition","title":"Syntax"},{"location":"opcodes/dict_loadstr.html#arguments","text":"Sdefinition : the string defining the key:value pairs idict : the dict handle","title":"Arguments"},{"location":"opcodes/dict_loadstr.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/dict_loadstr.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* # Example file for dict_loadstr ## dict_loadstr idict dict_loadstr Sdictdef Create a new dict from a string definition of the form \"keyA: valueA, keyB: valueB, ...\" The dict creates has the type str:any, which means that the keys are always strings and the values can be either numbers or strings. Keys do not need to be quoted. Values only need to be quoted if a string value consists of only numbers or includes itself quotation marks. Quotations must be single quotations: `'` The motivation behind this opcode is to be able to save a dictionary to a string, for example in the metadata of a soundfile, and be able to retrieve that as a dictionary inside csound */ 0dbfs = 1 instr example1 i dict dict_loadstr \"foo: 10, bar :'barvalue', \\n baz: unquoted string\" dict_print i dict turnoff endin instr example2 ; Read the metadata of a .mtx first S comment sfreadmeta \"test.mtx\" , \"comment\" if strlen ( S comment ) == 0 then i niterror \"The .mtx file has no metadata\" endif ; Parse the metadata as a dict i dict dict_loadstr S comment dict_print i dict ; Now we load the data itself. The mtx format consists of a flat array of floats ; where the first numbers include the dimensions of the matrix saved. ; As the columns metadata should show, the mtx file has a header: ; HeaderSize NumRows NumColumns [optionally other values] <The matrix as a flat array> ; The same header is duplicated in the metadata itself, so we can use that directly ; to make the code more self-documenting. i tab ftgen 0 , 0 , 0 , - 1 , \"test.mtx\" , 0 , 0 , 0 ; If the data is needed as an array it is possible to create an alias via memview. ; Otherwise use tab2array to create a copy i Arr [] memview i tab , dict_get : i ( i dict , \"HeaderSize\" ) ; iArr[] tab2array itab, dict_get:i(idict, \"HeaderSize\") ; Now reshape the array to recreate the original matrix reshapearray i Arr , dict_get : i ( i dict , \"NumRows\" ), dict_get : i ( i dict , \"NumColumns\" ) printarray i Arr turnoff endin </ CsInstruments > < CsScore > i \"example2\" 0 0.1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_loadstr.html#see-also","text":"dict_dump dict_new dict_set sfreadmeta","title":"See also"},{"location":"opcodes/dict_loadstr.html#credits","text":"Eduardo Moguillansky, 2021","title":"Credits"},{"location":"opcodes/dict_new.html","text":"dict_new Abstract Create a hashtable Description A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. A hashtable, similar to a table, is always global , even if it is assigned to a local variable. A dict is kept alive until either the end of the performance, or until freed via dict_free Syntax idict dict_new Stype, icapacity=-1 idict dict_new Stype, key0, value0, key1, value1, ... kdict dict_new Stype, key0, value0, key1, value1, ... Note With the second variant it is possible to create a dict and give it initial values at the same time. Args Stype : the type of the dictionary, see below icapacity : the initial capacity of the dictionary (how much it can grow without needing to reallocate memory). If not given a sensible default is used. Dictionaries can grow as they are filled, but since this requires memory allocation, it can be unsafe during performance key0, value0, ... : initial key:value pairs Types The types of a dict are fixed at creation time and are specified via the Stype argument. type short key value str:float sf string float str:str ss string string int:float if int float int:str is int string str:any sa string any (float or string The \"any type A dict of the form str:any accepts strings as keys and can have both strings and numbers as values. This can be used to pass arguments to an instrument like i args dict_new \"str:any\" , \"name\" , \"foo\" , \"freq\" , 1000 , \"amp\" , 0.5 schedule \"myinstr\" , 0 , - 1 , i args ; then, inside myinstr instr myinstr i args = p4 S name dict_get i args , \"name\" k freq dict_get i args , \"freq\" k amp dict_get i args , \"amp\" ; ... do something with this dict_free i args endin Arguments Stype : a string describing the type of the key and the value. See the table above. keyx , valuex**: initial pairs can be set at creation time, matching the types declared with Stype Output idict : identifies this dict with an integer. This integer can be passed around to another instrument and will always resolve to the same dict, as long as this dict is still alive. This can be checked via iexists dict_exists idict ( dict_exists Execution Time Init (the normal case) Performance (use this form when using dicts for passing named arguments to an event created at k-time) Examples < CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; a dict mapping strings to floats i dict dict_new \"sf\" ; free the dict at the end of this note dict_free i dict ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict to be passed to another instr i dict2 dict_new \"str:str\" , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > See also dict_free dict_set Credits Eduardo Moguillansky, 2019","title":"dict_new"},{"location":"opcodes/dict_new.html#dict_new","text":"","title":"dict_new"},{"location":"opcodes/dict_new.html#abstract","text":"Create a hashtable","title":"Abstract"},{"location":"opcodes/dict_new.html#description","text":"A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. A hashtable, similar to a table, is always global , even if it is assigned to a local variable. A dict is kept alive until either the end of the performance, or until freed via dict_free","title":"Description"},{"location":"opcodes/dict_new.html#syntax","text":"idict dict_new Stype, icapacity=-1 idict dict_new Stype, key0, value0, key1, value1, ... kdict dict_new Stype, key0, value0, key1, value1, ... Note With the second variant it is possible to create a dict and give it initial values at the same time.","title":"Syntax"},{"location":"opcodes/dict_new.html#args","text":"Stype : the type of the dictionary, see below icapacity : the initial capacity of the dictionary (how much it can grow without needing to reallocate memory). If not given a sensible default is used. Dictionaries can grow as they are filled, but since this requires memory allocation, it can be unsafe during performance key0, value0, ... : initial key:value pairs","title":"Args"},{"location":"opcodes/dict_new.html#types","text":"The types of a dict are fixed at creation time and are specified via the Stype argument. type short key value str:float sf string float str:str ss string string int:float if int float int:str is int string str:any sa string any (float or string","title":"Types"},{"location":"opcodes/dict_new.html#the-any-type","text":"A dict of the form str:any accepts strings as keys and can have both strings and numbers as values. This can be used to pass arguments to an instrument like i args dict_new \"str:any\" , \"name\" , \"foo\" , \"freq\" , 1000 , \"amp\" , 0.5 schedule \"myinstr\" , 0 , - 1 , i args ; then, inside myinstr instr myinstr i args = p4 S name dict_get i args , \"name\" k freq dict_get i args , \"freq\" k amp dict_get i args , \"amp\" ; ... do something with this dict_free i args endin","title":"The \"any type"},{"location":"opcodes/dict_new.html#arguments","text":"Stype : a string describing the type of the key and the value. See the table above. keyx , valuex**: initial pairs can be set at creation time, matching the types declared with Stype","title":"Arguments"},{"location":"opcodes/dict_new.html#output","text":"idict : identifies this dict with an integer. This integer can be passed around to another instrument and will always resolve to the same dict, as long as this dict is still alive. This can be checked via iexists dict_exists idict ( dict_exists","title":"Output"},{"location":"opcodes/dict_new.html#execution-time","text":"Init (the normal case) Performance (use this form when using dicts for passing named arguments to an event created at k-time)","title":"Execution Time"},{"location":"opcodes/dict_new.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; a dict mapping strings to floats i dict dict_new \"sf\" ; free the dict at the end of this note dict_free i dict ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict to be passed to another instr i dict2 dict_new \"str:str\" , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_new.html#see-also","text":"dict_free dict_set","title":"See also"},{"location":"opcodes/dict_new.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_print.html","text":"dict_print Abstract Prints the contents of a dict Description dict_print can be used to print the contents of a dict, mostly for debugging purposes dict_print can print both at i-time or k-time Syntax dict_print idict [, ktrig=1] Arguments \u00ecdict : the handle of the dict, as returned by dict_new ktrig : when to print the dict. Printing will take place whenever ktrig is -1 or if ktrig is a positive and higher than the last trig Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" , \"foo\" , 10 , \"bar\" , 20 , \"baz\" , 30 print_dict i dict , 1 ; print with a metro i dict2 dict_new \"ss\" , \"foo\" , \"foofoo\" , \"bar\" , \"barbar\" , \"baz\" , \"bazbaz\" k trig metro 2 print_dict i dict2 , k trig turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer > See also dict_iter dict_set dict_query Credits Eduardo Moguillansky, 2019","title":"dict_print"},{"location":"opcodes/dict_print.html#dict_print","text":"","title":"dict_print"},{"location":"opcodes/dict_print.html#abstract","text":"Prints the contents of a dict","title":"Abstract"},{"location":"opcodes/dict_print.html#description","text":"dict_print can be used to print the contents of a dict, mostly for debugging purposes dict_print can print both at i-time or k-time","title":"Description"},{"location":"opcodes/dict_print.html#syntax","text":"dict_print idict [, ktrig=1]","title":"Syntax"},{"location":"opcodes/dict_print.html#arguments","text":"\u00ecdict : the handle of the dict, as returned by dict_new ktrig : when to print the dict. Printing will take place whenever ktrig is -1 or if ktrig is a positive and higher than the last trig","title":"Arguments"},{"location":"opcodes/dict_print.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/dict_print.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" , \"foo\" , 10 , \"bar\" , 20 , \"baz\" , 30 print_dict i dict , 1 ; print with a metro i dict2 dict_new \"ss\" , \"foo\" , \"foofoo\" , \"bar\" , \"barbar\" , \"baz\" , \"bazbaz\" k trig metro 2 print_dict i dict2 , k trig turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_print.html#see-also","text":"dict_iter dict_set dict_query","title":"See also"},{"location":"opcodes/dict_print.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_query.html","text":"dict_query Abstract Query different properties of a dict Description Properties of a dict which do not need a separate opcode (because they are not used very frequently) are merged togehter in this opcode. Possible properties are: exists : return 1 if the handle points to a valid dict size : returns the size of this dict (similar to dict_size) type : returns an integer identifying the type of this dict 11 : number -> number 12 : number -> string 21 : string -> number 22 : string -> string keys : returns an array with all the keys defined in this dict (the type of the returned array depends on the type of the keys) values : returns an array with all the values (the type of the returned array depends on the type of the values). NB : the order in which keys and values are returned represents the corresponding pairs, so keys[i] and values[i] belong to the same pair. dict_query executes at k-time . Syntax kexists dict_query idict, \"exists\" ksize dict_query idict, \"size\" ktype dict_query idict, \"type\" SKeys[] dict_query idict, \"keys\" kKeys[] dict_query idict, \"keys\" kValues[] dict_query idict, \"values\" SValues[] dict_query idict, \"values\" Arguments idict : the handle of the dict, as returned by dict_new Output NB : the arrays returned from keys and values can have either an S- or a k-type, depending on the type definition of the array Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for dict_query ... dict_query idict, Scmd where Scmd can be: 'size', 'type', 'exists', 'keys', 'values' */ instr 1 ; get all the keys as an array i dict1 dict_new \"sf\" , 0 , \"keyA\" , 1 , \"keyB\" , 2 , \"keyC\" , 3 ; check that the dict exists k exists dict_query i dict1 , \"exists\" k type dict_query i dict1 , \"type\" printf \"dict exists = %d , type = %d \\n \" , 1 , k exists , k type S Keys [] dict_query i dict1 , \"keys\" printarray S Keys ; now check a bogus handle k exists999 dict_query 999 , \"exists\" printf \"dict 999 exists = %d \\n \" , 1 , k exists999 ; get the keys from a different dict i dict2 dict_new \"if\" , 0 , 1 , 100 , 10 , 1000 , 2 , 200 k Keys [] dict_query i dict2 , \"keys\" printarray k Keys , 1 , \" %.0f \" printf \"idict2 has size= %d \\n \" , 1 , dict_query ( i dict2 , \"size\" ) ; get values as an array i dict3 dict_new \"is\" , 0 , 10 , \"foo\" , 20 , \"bar\" , 30 , \"baz\" S vals [] dict_query i dict3 , \"values\" printarray S vals k Vals [] dict_query i dict2 , \"values\" printarray k Vals ; query the type of the dict k type dict_query i dict2 , \"type\" printf \"the type of dict %d is %d \\n \" , 1 , i dict2 , k type turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 </ CsScore > </ CsoundSynthesizer > See also dict_iter dict_size Credits Eduardo Moguillansky, 2019","title":"dict_query"},{"location":"opcodes/dict_query.html#dict_query","text":"","title":"dict_query"},{"location":"opcodes/dict_query.html#abstract","text":"Query different properties of a dict","title":"Abstract"},{"location":"opcodes/dict_query.html#description","text":"Properties of a dict which do not need a separate opcode (because they are not used very frequently) are merged togehter in this opcode. Possible properties are: exists : return 1 if the handle points to a valid dict size : returns the size of this dict (similar to dict_size) type : returns an integer identifying the type of this dict 11 : number -> number 12 : number -> string 21 : string -> number 22 : string -> string keys : returns an array with all the keys defined in this dict (the type of the returned array depends on the type of the keys) values : returns an array with all the values (the type of the returned array depends on the type of the values). NB : the order in which keys and values are returned represents the corresponding pairs, so keys[i] and values[i] belong to the same pair. dict_query executes at k-time .","title":"Description"},{"location":"opcodes/dict_query.html#syntax","text":"kexists dict_query idict, \"exists\" ksize dict_query idict, \"size\" ktype dict_query idict, \"type\" SKeys[] dict_query idict, \"keys\" kKeys[] dict_query idict, \"keys\" kValues[] dict_query idict, \"values\" SValues[] dict_query idict, \"values\"","title":"Syntax"},{"location":"opcodes/dict_query.html#arguments","text":"idict : the handle of the dict, as returned by dict_new","title":"Arguments"},{"location":"opcodes/dict_query.html#output","text":"NB : the arrays returned from keys and values can have either an S- or a k-type, depending on the type definition of the array","title":"Output"},{"location":"opcodes/dict_query.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/dict_query.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for dict_query ... dict_query idict, Scmd where Scmd can be: 'size', 'type', 'exists', 'keys', 'values' */ instr 1 ; get all the keys as an array i dict1 dict_new \"sf\" , 0 , \"keyA\" , 1 , \"keyB\" , 2 , \"keyC\" , 3 ; check that the dict exists k exists dict_query i dict1 , \"exists\" k type dict_query i dict1 , \"type\" printf \"dict exists = %d , type = %d \\n \" , 1 , k exists , k type S Keys [] dict_query i dict1 , \"keys\" printarray S Keys ; now check a bogus handle k exists999 dict_query 999 , \"exists\" printf \"dict 999 exists = %d \\n \" , 1 , k exists999 ; get the keys from a different dict i dict2 dict_new \"if\" , 0 , 1 , 100 , 10 , 1000 , 2 , 200 k Keys [] dict_query i dict2 , \"keys\" printarray k Keys , 1 , \" %.0f \" printf \"idict2 has size= %d \\n \" , 1 , dict_query ( i dict2 , \"size\" ) ; get values as an array i dict3 dict_new \"is\" , 0 , 10 , \"foo\" , 20 , \"bar\" , 30 , \"baz\" S vals [] dict_query i dict3 , \"values\" printarray S vals k Vals [] dict_query i dict2 , \"values\" printarray k Vals ; query the type of the dict k type dict_query i dict2 , \"type\" printf \"the type of dict %d is %d \\n \" , 1 , i dict2 , k type turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_query.html#see-also","text":"dict_iter dict_size","title":"See also"},{"location":"opcodes/dict_query.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_set.html","text":"dict_set Abstract Set a value from a hashtable Description A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_set sets the value corresponding to a key if the key is already present, or inserts a key:value pair otherwise. NB : To remove a key-value pair use dict_del Tip It is possible to set multiple values at i-time directly with dict_new Syntax dict_set idict, xkey, xvalue Arguments idict : the handle of the dict, as returned by dict_new xkey : the key to set. Its type must match the type definition of the dict. (a string or a possitive integer) xvalue : the value to set. Its type must match the type definition of the dict (a str or a numeric value) Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" dict_free i dict ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"str:str\" , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 print_dict i dict S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > < CsoundSynthesizer > < CsOptions > - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gi dict dict_new \"sf\" opcode argset , 0 , iSk i p1 , S param , k value xin S key sprintf \" %.4f : %s \" , i p1 , S param dict_set gi dict , S key , k value endop opcode argget , k , Si S param , i default xin S key sprintf \" %.4f : %s \" , p1 , S param k out dict_get gi dict , S key , i default xout k out ;; delete key at end of event defer \"dict_set\" , gi dict , S param endop instr exit prints \"Exiting csound \\n \" exitnow endin instr 1 i num uniqinstance 2 k freq = linseg ( random ( 4000 , 2000 ), p3 , random ( 300 , 350 )) argset i num , \"freq\" , k freq schedule i num , 0 , 3 k size dict_size gi dict printk2 k size a tstop p1 , 0 , p3 endin instr 2 k freq argget \"freq\" , 1000 a 0 oscili 0.02 , k freq a 0 *= linsegr : a ( 0 , 0.1 , 1 , 0.1 , 0 ) outs a 0 , a 0 endin instr example_dict schedule 1 , 0 , 0.01 schedule \"exit\" , 10 , 0.1 turnoff endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ instr 10 i num uniqinstance 11 , 10000 k freq = linseg ( 4000 , p3 , random ( 300 , 350 )) S chan = sprintf ( \" %f _freq\" , i num ) dict_set gi dict , S chan , k freq schedule i num , 0 , p3 endin instr 11 S key sprintf \" %f _freq\" , p1 printf \"p1= %.6f \\n \" , 1 , p1 k freq dict_get gi dict , S key , 1000 ;; delete key at end of event defer \"dict_set\" , gi dict , S key a 0 oscili 0.02 , k freq a 0 *= linsegr : a ( 0 , p3 * 0.1 , 1 , p3 * 0.9 , 0 ) outs a 0 , a 0 endin instr dictsize i size = dict_size : i ( gi dict ) print i size turnoff endin instr example2 i 0 = 0 i step = 0.01 i dur = 0.3 while i 0 < 10000 do schedule 10 , i 0 * i step , i dur i 0 += 1 print i 0 od i endtime = ( i 0 + 2 ) * i step + i dur schedule \"dictsize\" , i endtime - 0.005 , - 1 schedule \"exit\" , i endtime , - 1 turnoff endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ instr 20 i num uniqinstance 21 , 10000 k freq = linseg ( 4000 , p3 , random ( 300 , 350 )) S chan = sprintf ( \" %f _freq\" , i num ) ; printf \"%s \\n\", 1, Schan chnset k freq , S chan schedule i num , 0 , p3 endin instr 21 S key sprintf \" %f _freq\" , p1 printf \"p1= %.6f \\n \" , 1 , p1 k freq chnget S key a 0 oscili 0.02 , k freq a 0 *= linsegr : a ( 0 , p3 * 0.1 , 1 , p3 * 0.9 , 0 ) outs a 0 , a 0 endin instr example3 ; the same as example2 but with channels i 0 = 0 i step = 0.01 i dur = 0.3 while i 0 < 10000 do schedule 20 , i 0 * i step , i dur i 0 += 1 print i 0 od schedule \"exit\" , ( i 0 + 1 ) * i step + i dur , - 1 turnoff endin ; schedule \"example_dict\", 0, 1 schedule \"example2\" , 0 , 1 ; schedule \"example3\", 0, 1 </ CsInstruments > e 10 < CsScore > </ CsScore > </ CsoundSynthesizer > See also dict_new dict_get dict_del defer dict_free Credits Eduardo Moguillansky, 2019 Last update: 2021","title":"dict_set"},{"location":"opcodes/dict_set.html#dict_set","text":"","title":"dict_set"},{"location":"opcodes/dict_set.html#abstract","text":"Set a value from a hashtable","title":"Abstract"},{"location":"opcodes/dict_set.html#description","text":"A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_set sets the value corresponding to a key if the key is already present, or inserts a key:value pair otherwise. NB : To remove a key-value pair use dict_del Tip It is possible to set multiple values at i-time directly with dict_new","title":"Description"},{"location":"opcodes/dict_set.html#syntax","text":"dict_set idict, xkey, xvalue","title":"Syntax"},{"location":"opcodes/dict_set.html#arguments","text":"idict : the handle of the dict, as returned by dict_new xkey : the key to set. Its type must match the type definition of the dict. (a string or a possitive integer) xvalue : the value to set. Its type must match the type definition of the dict (a str or a numeric value)","title":"Arguments"},{"location":"opcodes/dict_set.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/dict_set.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" dict_free i dict ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"str:str\" , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 print_dict i dict S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > < CsoundSynthesizer > < CsOptions > - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gi dict dict_new \"sf\" opcode argset , 0 , iSk i p1 , S param , k value xin S key sprintf \" %.4f : %s \" , i p1 , S param dict_set gi dict , S key , k value endop opcode argget , k , Si S param , i default xin S key sprintf \" %.4f : %s \" , p1 , S param k out dict_get gi dict , S key , i default xout k out ;; delete key at end of event defer \"dict_set\" , gi dict , S param endop instr exit prints \"Exiting csound \\n \" exitnow endin instr 1 i num uniqinstance 2 k freq = linseg ( random ( 4000 , 2000 ), p3 , random ( 300 , 350 )) argset i num , \"freq\" , k freq schedule i num , 0 , 3 k size dict_size gi dict printk2 k size a tstop p1 , 0 , p3 endin instr 2 k freq argget \"freq\" , 1000 a 0 oscili 0.02 , k freq a 0 *= linsegr : a ( 0 , 0.1 , 1 , 0.1 , 0 ) outs a 0 , a 0 endin instr example_dict schedule 1 , 0 , 0.01 schedule \"exit\" , 10 , 0.1 turnoff endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ instr 10 i num uniqinstance 11 , 10000 k freq = linseg ( 4000 , p3 , random ( 300 , 350 )) S chan = sprintf ( \" %f _freq\" , i num ) dict_set gi dict , S chan , k freq schedule i num , 0 , p3 endin instr 11 S key sprintf \" %f _freq\" , p1 printf \"p1= %.6f \\n \" , 1 , p1 k freq dict_get gi dict , S key , 1000 ;; delete key at end of event defer \"dict_set\" , gi dict , S key a 0 oscili 0.02 , k freq a 0 *= linsegr : a ( 0 , p3 * 0.1 , 1 , p3 * 0.9 , 0 ) outs a 0 , a 0 endin instr dictsize i size = dict_size : i ( gi dict ) print i size turnoff endin instr example2 i 0 = 0 i step = 0.01 i dur = 0.3 while i 0 < 10000 do schedule 10 , i 0 * i step , i dur i 0 += 1 print i 0 od i endtime = ( i 0 + 2 ) * i step + i dur schedule \"dictsize\" , i endtime - 0.005 , - 1 schedule \"exit\" , i endtime , - 1 turnoff endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ instr 20 i num uniqinstance 21 , 10000 k freq = linseg ( 4000 , p3 , random ( 300 , 350 )) S chan = sprintf ( \" %f _freq\" , i num ) ; printf \"%s \\n\", 1, Schan chnset k freq , S chan schedule i num , 0 , p3 endin instr 21 S key sprintf \" %f _freq\" , p1 printf \"p1= %.6f \\n \" , 1 , p1 k freq chnget S key a 0 oscili 0.02 , k freq a 0 *= linsegr : a ( 0 , p3 * 0.1 , 1 , p3 * 0.9 , 0 ) outs a 0 , a 0 endin instr example3 ; the same as example2 but with channels i 0 = 0 i step = 0.01 i dur = 0.3 while i 0 < 10000 do schedule 20 , i 0 * i step , i dur i 0 += 1 print i 0 od schedule \"exit\" , ( i 0 + 1 ) * i step + i dur , - 1 turnoff endin ; schedule \"example_dict\", 0, 1 schedule \"example2\" , 0 , 1 ; schedule \"example3\", 0, 1 </ CsInstruments > e 10 < CsScore > </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_set.html#see-also","text":"dict_new dict_get dict_del defer dict_free","title":"See also"},{"location":"opcodes/dict_set.html#credits","text":"Eduardo Moguillansky, 2019 Last update: 2021","title":"Credits"},{"location":"opcodes/dict_size.html","text":"dict_size Abstract Returns the number of key:value pairs in a dict Description A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_size returns the number of such key:value pairs inside a dict. If the handle passed does not point to a valid dict, dict_size returns -1. It is thus possible to use it to check that the passed handle is valid (similar to dict_query idict \"exists\" , see dict_query ) dict_size can be used together with dict_iter to iterate over the key:value pairs Syntax isize dict_size idict ksize dict_size idict dict_size executes both at i-time and k-time . Arguments \u00ecdict : the handle of the dict, as returned by dict_new Output ksize : the number of key:value pairs in the dict Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size dict_set i dict , \"foo\" , 4 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size ; size does not change now dict_set i dict , \"foo\" , 10 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size ; we delete a key, size is reduced dict_set i dict , \"foo\" k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer > See also dict_iter dict_set Credits Eduardo Moguillansky, 2019","title":"dict_size"},{"location":"opcodes/dict_size.html#dict_size","text":"","title":"dict_size"},{"location":"opcodes/dict_size.html#abstract","text":"Returns the number of key:value pairs in a dict","title":"Abstract"},{"location":"opcodes/dict_size.html#description","text":"A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_size returns the number of such key:value pairs inside a dict. If the handle passed does not point to a valid dict, dict_size returns -1. It is thus possible to use it to check that the passed handle is valid (similar to dict_query idict \"exists\" , see dict_query ) dict_size can be used together with dict_iter to iterate over the key:value pairs","title":"Description"},{"location":"opcodes/dict_size.html#syntax","text":"isize dict_size idict ksize dict_size idict dict_size executes both at i-time and k-time .","title":"Syntax"},{"location":"opcodes/dict_size.html#arguments","text":"\u00ecdict : the handle of the dict, as returned by dict_new","title":"Arguments"},{"location":"opcodes/dict_size.html#output","text":"ksize : the number of key:value pairs in the dict","title":"Output"},{"location":"opcodes/dict_size.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/dict_size.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size dict_set i dict , \"foo\" , 4 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size ; size does not change now dict_set i dict , \"foo\" , 10 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size ; we delete a key, size is reduced dict_set i dict , \"foo\" k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_size.html#see-also","text":"dict_iter dict_set","title":"See also"},{"location":"opcodes/dict_size.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/diode_ringmod.html","text":"diode_ringmod Abstract A ring modulator with optional non-linearities Description diode_ringmod is a ring modulator with optional non-linearities. It implements a built-in sinusoidal carrier signal. The carrier is passed through a diode simulation prior to being multiplied with the input. This signal passes through a feedback stage. Sinewave : Diode Rect (abs(x)*2-0.2) : _ * Input : Feedback knonlinearities controls the amount of jitter in the carrier's freq and feedback amount. diode_ringmod is a port of Loser's ringmodulator jsfx plugin distributed with REAPER Syntax a out diode_ringmod a in , k freq , k diode = 0 , k feedback = 0 , k nonlinear = 0 , k oversample = 0 Arguments ain : the input signal kfreq : the carrier's frequency (a sine wave) kdiode : if 1, the carrier is passed through a diode rectification stage kfeedback : the amount of feedback (between 0 and 1, 0=no feedback) knonlinear : the amount of non linearities (between 0 and 1, 0=no non linearities) koversample : if 1, oversampling x 2 is performed Output aout : audio output of the ring modulator Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac - d - m0 -+ rtmidi = virtual - M0 </ CsOptions > < CsInstruments > /* This is the example file for diode_ringmod NB: diode_ringmod is a port of the jsfx plugin Loser/ringmodulator, which implements diode rectification and non linear behavior in the feedback path. aout diode_ringmode a1, kmodfreq, kdiode=1, kfeedback=0, knonlin=0.2, koversample=0 kmodfreq: frequency of the mod. signal kdiode: if 1, a diode rectification stage is applied to the mod. signal kfeedback: range is 0 to 1. knonlin: range 0 to 1, implements non-linearities in feedback and mod. freq (for the first case only, which used the builtin oscillator) koversample: if 1, 2x oversampling is used. */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ga Outs [] init 2 FLpanel \"dioderingmod\" , 443 , 360 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i __w , i __h , i __line = 300 , 30 , 60 i y , i __marginx = 30 , 30 i _v1 FLvalue \"\" , 50 , 30 , 333 , i y gk ModFrequency , i _s1 FLslider \"Mod Frequency (Hz)\" , 20.0 , 3000.0 , 0 , 3 , \\ i _v1 , i __w , i __h , i __marginx , i y i y += i __line i _v2 FLvalue \"\" , 50 , 30 , 333 , i y gk Diode , i _s2 FLslider \"Diode\" , 0.0 , 1.0 , 0 , 3 , \\ i _v2 , i __w , i __h , i __marginx , i y i y += i __line i _v3 FLvalue \"\" , 50 , 30 , 333 , i y gk Feedback , i _s3 FLslider \"Feedback\" , 0.0 , 1.0 , 0 , 3 , \\ i _v3 , i __w , i __h , i __marginx , i y i y += i __line i _v4 FLvalue \"\" , 50 , 30 , 333 , i y gk Nonlinearities , i _s4 FLslider \"Non-Linearities\" , 0.0 , 1.0 , 0 , 3 , \\ i _v4 , i __w , i __h , i __marginx , i y i y += i __line i _v5 FLvalue \"\" , 50 , 30 , 333 , i y gk Oversample , i _s5 FLslider \"Oversample (x2)\" , 0.0 , 1.0 , 0 , 3 , \\ i _v5 , i __w , i __h , i __marginx , i y FLpanelEnd FLrun FLsetVal_i 440.0 , i _s1 ; Mod Frequency (Hz) FLsetVal_i 0.0 , i _s2 ; Diode FLsetVal_i 0.0 , i _s3 ; Feedback FLsetVal_i 0.1 , i _s4 ; Non-Linearities FLsetVal_i 0.0 , i _s5 ; Oversample (x2); --- end ui massign 1 , 1 instr 1 i midinote notnum i freq mtof i midinote i vel1 ampmidi 127 i db bpf i vel1 , 0 , - 120 , 64 , - 20 , 90 , - 12 , 127 , 0 i amp = ampdb ( i db ) * 0.2 a sig vco2 i amp , i freq ; asig oscili iamp, ifreq a env adsr 0.01 , 0.1 , 0.8 , 0.2 a sig *= a env ga Outs [ 0 ] = ga Outs [ 0 ] + a sig endin instr 100 a 1 = ga Outs [ 0 ] a 2 diode_ringmod a 1 , gk ModFrequency , gk Diode , gk Feedback , gk Nonlinearities , gk Oversample outs a 2 , a 2 ga Outs [ 0 ] = 0 endin </ CsInstruments > < CsScore > i 100 0 3600 </ CsScore > </ CsoundSynthesizer > < bsbPanel > < label > Widgets </ label > < objectName /> < x > 100 </ x > < y > 100 </ y > < w idth > 320 </ w idth > < height > 240 </ height > < visible > true </ visible > < uuid /> < bgcolor mode = \"nobackground\" > < r > 255 </ r > < g > 255 </ g > < b > 255 </ b > </ bgcolor > </ bsbPanel > < bsbPresets > </ bsbPresets > See also hilbert Reference https://en.wikipedia.org/wiki/Ring_modulation Credits Eduardo Moguillansky, 2019","title":"diode_ringmod"},{"location":"opcodes/diode_ringmod.html#diode_ringmod","text":"","title":"diode_ringmod"},{"location":"opcodes/diode_ringmod.html#abstract","text":"A ring modulator with optional non-linearities","title":"Abstract"},{"location":"opcodes/diode_ringmod.html#description","text":"diode_ringmod is a ring modulator with optional non-linearities. It implements a built-in sinusoidal carrier signal. The carrier is passed through a diode simulation prior to being multiplied with the input. This signal passes through a feedback stage. Sinewave : Diode Rect (abs(x)*2-0.2) : _ * Input : Feedback knonlinearities controls the amount of jitter in the carrier's freq and feedback amount. diode_ringmod is a port of Loser's ringmodulator jsfx plugin distributed with REAPER","title":"Description"},{"location":"opcodes/diode_ringmod.html#syntax","text":"a out diode_ringmod a in , k freq , k diode = 0 , k feedback = 0 , k nonlinear = 0 , k oversample = 0","title":"Syntax"},{"location":"opcodes/diode_ringmod.html#arguments","text":"ain : the input signal kfreq : the carrier's frequency (a sine wave) kdiode : if 1, the carrier is passed through a diode rectification stage kfeedback : the amount of feedback (between 0 and 1, 0=no feedback) knonlinear : the amount of non linearities (between 0 and 1, 0=no non linearities) koversample : if 1, oversampling x 2 is performed","title":"Arguments"},{"location":"opcodes/diode_ringmod.html#output","text":"aout : audio output of the ring modulator","title":"Output"},{"location":"opcodes/diode_ringmod.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/diode_ringmod.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac - d - m0 -+ rtmidi = virtual - M0 </ CsOptions > < CsInstruments > /* This is the example file for diode_ringmod NB: diode_ringmod is a port of the jsfx plugin Loser/ringmodulator, which implements diode rectification and non linear behavior in the feedback path. aout diode_ringmode a1, kmodfreq, kdiode=1, kfeedback=0, knonlin=0.2, koversample=0 kmodfreq: frequency of the mod. signal kdiode: if 1, a diode rectification stage is applied to the mod. signal kfeedback: range is 0 to 1. knonlin: range 0 to 1, implements non-linearities in feedback and mod. freq (for the first case only, which used the builtin oscillator) koversample: if 1, 2x oversampling is used. */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ga Outs [] init 2 FLpanel \"dioderingmod\" , 443 , 360 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i __w , i __h , i __line = 300 , 30 , 60 i y , i __marginx = 30 , 30 i _v1 FLvalue \"\" , 50 , 30 , 333 , i y gk ModFrequency , i _s1 FLslider \"Mod Frequency (Hz)\" , 20.0 , 3000.0 , 0 , 3 , \\ i _v1 , i __w , i __h , i __marginx , i y i y += i __line i _v2 FLvalue \"\" , 50 , 30 , 333 , i y gk Diode , i _s2 FLslider \"Diode\" , 0.0 , 1.0 , 0 , 3 , \\ i _v2 , i __w , i __h , i __marginx , i y i y += i __line i _v3 FLvalue \"\" , 50 , 30 , 333 , i y gk Feedback , i _s3 FLslider \"Feedback\" , 0.0 , 1.0 , 0 , 3 , \\ i _v3 , i __w , i __h , i __marginx , i y i y += i __line i _v4 FLvalue \"\" , 50 , 30 , 333 , i y gk Nonlinearities , i _s4 FLslider \"Non-Linearities\" , 0.0 , 1.0 , 0 , 3 , \\ i _v4 , i __w , i __h , i __marginx , i y i y += i __line i _v5 FLvalue \"\" , 50 , 30 , 333 , i y gk Oversample , i _s5 FLslider \"Oversample (x2)\" , 0.0 , 1.0 , 0 , 3 , \\ i _v5 , i __w , i __h , i __marginx , i y FLpanelEnd FLrun FLsetVal_i 440.0 , i _s1 ; Mod Frequency (Hz) FLsetVal_i 0.0 , i _s2 ; Diode FLsetVal_i 0.0 , i _s3 ; Feedback FLsetVal_i 0.1 , i _s4 ; Non-Linearities FLsetVal_i 0.0 , i _s5 ; Oversample (x2); --- end ui massign 1 , 1 instr 1 i midinote notnum i freq mtof i midinote i vel1 ampmidi 127 i db bpf i vel1 , 0 , - 120 , 64 , - 20 , 90 , - 12 , 127 , 0 i amp = ampdb ( i db ) * 0.2 a sig vco2 i amp , i freq ; asig oscili iamp, ifreq a env adsr 0.01 , 0.1 , 0.8 , 0.2 a sig *= a env ga Outs [ 0 ] = ga Outs [ 0 ] + a sig endin instr 100 a 1 = ga Outs [ 0 ] a 2 diode_ringmod a 1 , gk ModFrequency , gk Diode , gk Feedback , gk Nonlinearities , gk Oversample outs a 2 , a 2 ga Outs [ 0 ] = 0 endin </ CsInstruments > < CsScore > i 100 0 3600 </ CsScore > </ CsoundSynthesizer > < bsbPanel > < label > Widgets </ label > < objectName /> < x > 100 </ x > < y > 100 </ y > < w idth > 320 </ w idth > < height > 240 </ height > < visible > true </ visible > < uuid /> < bgcolor mode = \"nobackground\" > < r > 255 </ r > < g > 255 </ g > < b > 255 </ b > </ bgcolor > </ bsbPanel > < bsbPresets > </ bsbPresets >","title":"Examples"},{"location":"opcodes/diode_ringmod.html#see-also","text":"hilbert","title":"See also"},{"location":"opcodes/diode_ringmod.html#reference","text":"https://en.wikipedia.org/wiki/Ring_modulation","title":"Reference"},{"location":"opcodes/diode_ringmod.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/extendarray.html","text":"extendarray Abstract Extend one array with the contents of a second array, in place Description extendarray concatenates two arrays, placing the results in the first array. It works either at init or performance time, depending on the arrays passed. Syntax extendarray i Array1 [], i Array2 extendarray k Array1 [], k Array2 extendarray k Array1 [], i Array2 extendarray S Array1 [], S Array2 Arguments xArray1 : the first array and the array where the result is placed xArray2 : the second array Output Execution Time Init (if all arguments are of i type) Performance (for k or S types) Examples i Arr1 [] fillarray 0 , 1 , 2 i Arr2 [] fillarray 3 , 4 , 5 extendarray i Arr1 , i Arr2 ; iArr1 is now [0, 1, 2, 3, 4, 5] See also setslice setrow slicearray ) ftset ftslice Credits Eduardo Moguillansky, 2020","title":"extendarray"},{"location":"opcodes/extendarray.html#extendarray","text":"","title":"extendarray"},{"location":"opcodes/extendarray.html#abstract","text":"Extend one array with the contents of a second array, in place","title":"Abstract"},{"location":"opcodes/extendarray.html#description","text":"extendarray concatenates two arrays, placing the results in the first array. It works either at init or performance time, depending on the arrays passed.","title":"Description"},{"location":"opcodes/extendarray.html#syntax","text":"extendarray i Array1 [], i Array2 extendarray k Array1 [], k Array2 extendarray k Array1 [], i Array2 extendarray S Array1 [], S Array2","title":"Syntax"},{"location":"opcodes/extendarray.html#arguments","text":"xArray1 : the first array and the array where the result is placed xArray2 : the second array","title":"Arguments"},{"location":"opcodes/extendarray.html#output","text":"","title":"Output"},{"location":"opcodes/extendarray.html#execution-time","text":"Init (if all arguments are of i type) Performance (for k or S types)","title":"Execution Time"},{"location":"opcodes/extendarray.html#examples","text":"i Arr1 [] fillarray 0 , 1 , 2 i Arr2 [] fillarray 3 , 4 , 5 extendarray i Arr1 , i Arr2 ; iArr1 is now [0, 1, 2, 3, 4, 5]","title":"Examples"},{"location":"opcodes/extendarray.html#see-also","text":"setslice setrow slicearray ) ftset ftslice","title":"See also"},{"location":"opcodes/extendarray.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/fileexists.html","text":"file_exists Abstract Returns 1 if a file exists and can be read Description file_exists checks if a given file path exists and returns 1 if it does, 0 otherwise. It doesn't check any search path of csound and does not expand any variables (like \"~\" in unix). Syntax i exists f ile_exists S path Arguments Spath : the path to check Output iexists : 1 if the file exists, 0 otherwise Execution Time Init Examples < CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > /* Example file for file_exists file_exists returns 1 if a given path refers to an existing file */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 i exists f ile_exists \"file_exists.csd\" print i exists turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer > See also filevalid system Credits Eduardo Moguillansky, 2019","title":"file_exists"},{"location":"opcodes/fileexists.html#file_exists","text":"","title":"file_exists"},{"location":"opcodes/fileexists.html#abstract","text":"Returns 1 if a file exists and can be read","title":"Abstract"},{"location":"opcodes/fileexists.html#description","text":"file_exists checks if a given file path exists and returns 1 if it does, 0 otherwise. It doesn't check any search path of csound and does not expand any variables (like \"~\" in unix).","title":"Description"},{"location":"opcodes/fileexists.html#syntax","text":"i exists f ile_exists S path","title":"Syntax"},{"location":"opcodes/fileexists.html#arguments","text":"Spath : the path to check","title":"Arguments"},{"location":"opcodes/fileexists.html#output","text":"iexists : 1 if the file exists, 0 otherwise","title":"Output"},{"location":"opcodes/fileexists.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/fileexists.html#examples","text":"< CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > /* Example file for file_exists file_exists returns 1 if a given path refers to an existing file */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 i exists f ile_exists \"file_exists.csd\" print i exists turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/fileexists.html#see-also","text":"filevalid system","title":"See also"},{"location":"opcodes/fileexists.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/findFileInPath.html","text":"findFileInPath Abstract Find a file inside the search paths of the csound environment Description Search for an existing file as csound would search when ,for example, loading a sample. Returns the absolute path Syntax Spath fileFind Sfile Arguments Sfile : a relative path to an existing file Output Sout : the absolute path, or \"\" if not found Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Sabspath fileFind Sfile Searched for Sfile, first in the current directory, then in the directories specified in SSDIR. Returns the absolute path or an empty string to signal that the file was not found. */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 ; find the directory of this script S path f indFile \"fileFind.csd\" S dir , S base pathSplit S path prints \"Folder: %s \\n \" , S dir S value getEnvVar \"SSDIR\" prints \"SSDIR: %s \\n \" , S value S scriptdir scriptDir prints \"Directory of current script: %s \\n \" , S scriptdir turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also scriptDir Credits Eduardo Moguillansky, 2020","title":"findFileInPath"},{"location":"opcodes/findFileInPath.html#findfileinpath","text":"","title":"findFileInPath"},{"location":"opcodes/findFileInPath.html#abstract","text":"Find a file inside the search paths of the csound environment","title":"Abstract"},{"location":"opcodes/findFileInPath.html#description","text":"Search for an existing file as csound would search when ,for example, loading a sample. Returns the absolute path","title":"Description"},{"location":"opcodes/findFileInPath.html#syntax","text":"Spath fileFind Sfile","title":"Syntax"},{"location":"opcodes/findFileInPath.html#arguments","text":"Sfile : a relative path to an existing file","title":"Arguments"},{"location":"opcodes/findFileInPath.html#output","text":"Sout : the absolute path, or \"\" if not found","title":"Output"},{"location":"opcodes/findFileInPath.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/findFileInPath.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Sabspath fileFind Sfile Searched for Sfile, first in the current directory, then in the directories specified in SSDIR. Returns the absolute path or an empty string to signal that the file was not found. */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 ; find the directory of this script S path f indFile \"fileFind.csd\" S dir , S base pathSplit S path prints \"Folder: %s \\n \" , S dir S value getEnvVar \"SSDIR\" prints \"SSDIR: %s \\n \" , S value S scriptdir scriptDir prints \"Directory of current script: %s \\n \" , S scriptdir turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/findFileInPath.html#see-also","text":"scriptDir","title":"See also"},{"location":"opcodes/findFileInPath.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/findarray.html","text":"findarray Abstract Find an element in an array Description findarray finds the index of an element in an array. If the element is not found it returns -1 Syntax i index f indarray i arr , i val , i tolerance = 1e-12 k index f indarray k arr , k val , i tolerance = 1e-12 Arguments iarr / karr : A 1D scalar array itolerance : A tolerance value. When using floats it is not recommended to check for equality but to check if two values are close enough Output iindex / kindex : the index of the value inside the array, or -1 if the value is not found Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound ; -odac </ CsOptions > < CsInstruments > /* Description =========== findarray return the index of the first element which is equal to the given number. If the number is not found, the return value is -1 Syntax ====== kidx findarray karray[], kvalue/ivalue [, iepsilon=1e-12] kidx findarray iarray[], kvalue [, iepsilon=1e-12] idx findarray iarray[], ivalue [, iepsilon=1e-12] */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 10 k arr [] fillarray 0 , 0.5 , 0.3 , 10 , 0.8 k idx f indarray k arr , 0.3 println \"kidx: %d \" , k idx k arr2 [] genarray_i 0 , 100 , 0.1 k idx2 f indarray k arr2 , 70.8 println \"kidx2: %d \" , k idx2 turnoff endin </ CsInstruments > < CsScore > i 10 0 0.1 </ CsScore > </ CsoundSynthesizer > See also ftfind Credits Eduardo Moguillansky, 2021","title":"findarray"},{"location":"opcodes/findarray.html#findarray","text":"","title":"findarray"},{"location":"opcodes/findarray.html#abstract","text":"Find an element in an array","title":"Abstract"},{"location":"opcodes/findarray.html#description","text":"findarray finds the index of an element in an array. If the element is not found it returns -1","title":"Description"},{"location":"opcodes/findarray.html#syntax","text":"i index f indarray i arr , i val , i tolerance = 1e-12 k index f indarray k arr , k val , i tolerance = 1e-12","title":"Syntax"},{"location":"opcodes/findarray.html#arguments","text":"iarr / karr : A 1D scalar array itolerance : A tolerance value. When using floats it is not recommended to check for equality but to check if two values are close enough","title":"Arguments"},{"location":"opcodes/findarray.html#output","text":"iindex / kindex : the index of the value inside the array, or -1 if the value is not found","title":"Output"},{"location":"opcodes/findarray.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/findarray.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound ; -odac </ CsOptions > < CsInstruments > /* Description =========== findarray return the index of the first element which is equal to the given number. If the number is not found, the return value is -1 Syntax ====== kidx findarray karray[], kvalue/ivalue [, iepsilon=1e-12] kidx findarray iarray[], kvalue [, iepsilon=1e-12] idx findarray iarray[], ivalue [, iepsilon=1e-12] */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 10 k arr [] fillarray 0 , 0.5 , 0.3 , 10 , 0.8 k idx f indarray k arr , 0.3 println \"kidx: %d \" , k idx k arr2 [] genarray_i 0 , 100 , 0.1 k idx2 f indarray k arr2 , 70.8 println \"kidx2: %d \" , k idx2 turnoff endin </ CsInstruments > < CsScore > i 10 0 0.1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/findarray.html#see-also","text":"ftfind","title":"See also"},{"location":"opcodes/findarray.html#credits","text":"Eduardo Moguillansky, 2021","title":"Credits"},{"location":"opcodes/frac2int.html","text":"frac2int Abstract Convert the fractional part of a number into an integer Description frac2int can be used to convert the fractional part of a number (as passed, for example, as p1 ) back to an integer. Syntax i Int f rac2int i Float , i Mul k Int f rac2int k Float , k Mul Arguments iFloat / kFloat : a number with a fractional part (for example, a fractional p1 ) iMul / kMul : the factor used to convert the initial integer into a fraction (see example) Output iInt / kInt : the integer value corresponding to the fractional part Note The integral part of the passed value is discarded i val = 10 + 123 / 1000 ; => 10.123 i val2 f rac2int i val , 1000 ; => 123 Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > instr 1 i num f rac2int 1.45 , 100 print i num turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also frac Credits Eduardo Moguillansky, 2019","title":"frac2int"},{"location":"opcodes/frac2int.html#frac2int","text":"","title":"frac2int"},{"location":"opcodes/frac2int.html#abstract","text":"Convert the fractional part of a number into an integer","title":"Abstract"},{"location":"opcodes/frac2int.html#description","text":"frac2int can be used to convert the fractional part of a number (as passed, for example, as p1 ) back to an integer.","title":"Description"},{"location":"opcodes/frac2int.html#syntax","text":"i Int f rac2int i Float , i Mul k Int f rac2int k Float , k Mul","title":"Syntax"},{"location":"opcodes/frac2int.html#arguments","text":"iFloat / kFloat : a number with a fractional part (for example, a fractional p1 ) iMul / kMul : the factor used to convert the initial integer into a fraction (see example)","title":"Arguments"},{"location":"opcodes/frac2int.html#output","text":"iInt / kInt : the integer value corresponding to the fractional part Note The integral part of the passed value is discarded i val = 10 + 123 / 1000 ; => 10.123 i val2 f rac2int i val , 1000 ; => 123","title":"Output"},{"location":"opcodes/frac2int.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/frac2int.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > instr 1 i num f rac2int 1.45 , 100 print i num turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/frac2int.html#see-also","text":"frac","title":"See also"},{"location":"opcodes/frac2int.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/ftfill.html","text":"ftfill Abstract create a table and fill it with values (like fillarray but for f-tables) Description ftfill is a shortcut opcode to create a table and fill it with values. It explicitely disallows the user to set the table-number manually. Syntax i tabnum f tfill i 0 , [ i 1 , i 2 , ... ] Arguments ix : The value(s) to place in the f-table Output itabnum : the number of the generated f-table Execution Time Init Examples < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > /* Description =========== ftfill creates a table and fills it with values. Like fillarray, but for f-tables. Syntax ====== itabnum ftfill x0, [x1, x2, ...] **NB**: this is the same as ``itabnum ftgen 0, 0, 0, -2, x0, x1, x2, ...`` */ ksmps = 32 nchnls = 2 0dbfs = 1 instr example1 i time2midi1 f tfill 0 , 64 , 4 , 62 , 5 , 62 , 6 , 67 i time2midi2 f tfill 0 , 60 , 4 , 60 , 5 , 59 , 6 , 59 ftprint i time2midi1 ftfree i time2midi1 , 1 ftfree i time2midi2 , 1 ; step=2, bisect the column 0. k t = timeinsts () k idx1 bisect k t , i time2midi1 , 2 k idx2 bisect k t , i time2midi2 , 2 ; -1: cosine interpolation, step size=2, offset=1 k midi1 i nterp1d k idx1 , i time2midi1 , \"cos\" , 2 , 1 k midi2 i nterp1d k idx2 , i time2midi2 , \"cos\" , 2 , 1 a 0 squinewave a ( mtof ( k midi1 )), a ( 0.1 ), a ( 0.1 ) a 1 squinewave a ( mtof ( k midi2 )), a ( 0.2 ), a ( 0.5 ) i gain = 0.1 i fade = 0.2 a env = linseg : a ( 0 , i fade , i gain , p3 - i fade * 2 - 0.1 , i gain , i fade , 0 ) outch 1 , a 0 * a env , 2 , a 1 * a env endin </ CsInstruments > < CsScore > i \"example1\" 0 1 </ CsScore > </ CsoundSynthesizer > See also ftgen fillarray ftnew ftfree Credits Eduardo Moguillansky, 2019","title":"ftfill"},{"location":"opcodes/ftfill.html#ftfill","text":"","title":"ftfill"},{"location":"opcodes/ftfill.html#abstract","text":"create a table and fill it with values (like fillarray but for f-tables)","title":"Abstract"},{"location":"opcodes/ftfill.html#description","text":"ftfill is a shortcut opcode to create a table and fill it with values. It explicitely disallows the user to set the table-number manually.","title":"Description"},{"location":"opcodes/ftfill.html#syntax","text":"i tabnum f tfill i 0 , [ i 1 , i 2 , ... ]","title":"Syntax"},{"location":"opcodes/ftfill.html#arguments","text":"ix : The value(s) to place in the f-table","title":"Arguments"},{"location":"opcodes/ftfill.html#output","text":"itabnum : the number of the generated f-table","title":"Output"},{"location":"opcodes/ftfill.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/ftfill.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > /* Description =========== ftfill creates a table and fills it with values. Like fillarray, but for f-tables. Syntax ====== itabnum ftfill x0, [x1, x2, ...] **NB**: this is the same as ``itabnum ftgen 0, 0, 0, -2, x0, x1, x2, ...`` */ ksmps = 32 nchnls = 2 0dbfs = 1 instr example1 i time2midi1 f tfill 0 , 64 , 4 , 62 , 5 , 62 , 6 , 67 i time2midi2 f tfill 0 , 60 , 4 , 60 , 5 , 59 , 6 , 59 ftprint i time2midi1 ftfree i time2midi1 , 1 ftfree i time2midi2 , 1 ; step=2, bisect the column 0. k t = timeinsts () k idx1 bisect k t , i time2midi1 , 2 k idx2 bisect k t , i time2midi2 , 2 ; -1: cosine interpolation, step size=2, offset=1 k midi1 i nterp1d k idx1 , i time2midi1 , \"cos\" , 2 , 1 k midi2 i nterp1d k idx2 , i time2midi2 , \"cos\" , 2 , 1 a 0 squinewave a ( mtof ( k midi1 )), a ( 0.1 ), a ( 0.1 ) a 1 squinewave a ( mtof ( k midi2 )), a ( 0.2 ), a ( 0.5 ) i gain = 0.1 i fade = 0.2 a env = linseg : a ( 0 , i fade , i gain , p3 - i fade * 2 - 0.1 , i gain , i fade , 0 ) outch 1 , a 0 * a env , 2 , a 1 * a env endin </ CsInstruments > < CsScore > i \"example1\" 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/ftfill.html#see-also","text":"ftgen fillarray ftnew ftfree","title":"See also"},{"location":"opcodes/ftfill.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/ftfind.html","text":"ftfind Abstract Find an element in a table Description ftfind finds the index of an element in table. If the element is not found it returns -1 Syntax i index f tfind i tab , i val , i tolerance = 1e-12 k index f tfind k tab , k val , i tolerance = 1e-12 Arguments itab / ktab : A table ival / kval : The value to find itolerance : A tolerance value. When using floats it is not recommended to check for equality but to check if two values are close enough Output iindex / kindex : the index of the value inside the table, or -1 if the value is not found Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound ; -odac </ CsOptions > < CsInstruments > /* Description =========== ftfind return the index of the first element in a table which is equal to the given number. If the number is not found, the return value is -1 Syntax ====== kidx ftfind ktabnum, kvalue, iepsilon=1e-12 iidx ftfind itabnum, ivalue, iepsilon=1e-12 */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 10 i tabnum f tfill 0 , 0.5 , 0.3 , 10 , 0.8 i idx f tfind i tabnum , 0.3 prints \"iidx: %d \\n \" , i idx turnoff endin </ CsInstruments > < CsScore > i 10 0 0.1 </ CsScore > </ CsoundSynthesizer > See also findarray Credits Eduardo Moguillansky, 2021","title":"ftfind"},{"location":"opcodes/ftfind.html#ftfind","text":"","title":"ftfind"},{"location":"opcodes/ftfind.html#abstract","text":"Find an element in a table","title":"Abstract"},{"location":"opcodes/ftfind.html#description","text":"ftfind finds the index of an element in table. If the element is not found it returns -1","title":"Description"},{"location":"opcodes/ftfind.html#syntax","text":"i index f tfind i tab , i val , i tolerance = 1e-12 k index f tfind k tab , k val , i tolerance = 1e-12","title":"Syntax"},{"location":"opcodes/ftfind.html#arguments","text":"itab / ktab : A table ival / kval : The value to find itolerance : A tolerance value. When using floats it is not recommended to check for equality but to check if two values are close enough","title":"Arguments"},{"location":"opcodes/ftfind.html#output","text":"iindex / kindex : the index of the value inside the table, or -1 if the value is not found","title":"Output"},{"location":"opcodes/ftfind.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/ftfind.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound ; -odac </ CsOptions > < CsInstruments > /* Description =========== ftfind return the index of the first element in a table which is equal to the given number. If the number is not found, the return value is -1 Syntax ====== kidx ftfind ktabnum, kvalue, iepsilon=1e-12 iidx ftfind itabnum, ivalue, iepsilon=1e-12 */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 10 i tabnum f tfill 0 , 0.5 , 0.3 , 10 , 0.8 i idx f tfind i tabnum , 0.3 prints \"iidx: %d \\n \" , i idx turnoff endin </ CsInstruments > < CsScore > i 10 0 0.1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/ftfind.html#see-also","text":"findarray","title":"See also"},{"location":"opcodes/ftfind.html#credits","text":"Eduardo Moguillansky, 2021","title":"Credits"},{"location":"opcodes/ftnew.html","text":"ftnew Abstract creates a new table of a given size Description ftnew is a shortcut opcode to create a new table of a given size. It is possible to set the elements to an initial value (default=0). It explicitely disallows the user to set the table-number manually. Syntax i tabnum f tnew i size , [ i default = 0 ] Arguments isize : The size of the table. idefault : The initial value for all items in the table (default=0) Output itabnum : the number of the generated f-table Execution Time Init Examples ; create a table from an array of any size i xs [] fillarray 0 , 1 , 2 , 3 , 4 , 5 i tab f tnew lenarray ( i xs ) copya2ftab i xs , i tab See also ftgen fillarray ftfill ftfree Credits Eduardo Moguillansky, 2021","title":"ftnew"},{"location":"opcodes/ftnew.html#ftnew","text":"","title":"ftnew"},{"location":"opcodes/ftnew.html#abstract","text":"creates a new table of a given size","title":"Abstract"},{"location":"opcodes/ftnew.html#description","text":"ftnew is a shortcut opcode to create a new table of a given size. It is possible to set the elements to an initial value (default=0). It explicitely disallows the user to set the table-number manually.","title":"Description"},{"location":"opcodes/ftnew.html#syntax","text":"i tabnum f tnew i size , [ i default = 0 ]","title":"Syntax"},{"location":"opcodes/ftnew.html#arguments","text":"isize : The size of the table. idefault : The initial value for all items in the table (default=0)","title":"Arguments"},{"location":"opcodes/ftnew.html#output","text":"itabnum : the number of the generated f-table","title":"Output"},{"location":"opcodes/ftnew.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/ftnew.html#examples","text":"; create a table from an array of any size i xs [] fillarray 0 , 1 , 2 , 3 , 4 , 5 i tab f tnew lenarray ( i xs ) copya2ftab i xs , i tab","title":"Examples"},{"location":"opcodes/ftnew.html#see-also","text":"ftgen fillarray ftfill ftfree","title":"See also"},{"location":"opcodes/ftnew.html#credits","text":"Eduardo Moguillansky, 2021","title":"Credits"},{"location":"opcodes/ftsetparams.html","text":"ftsetparams Abstract Set metadata parameters of a table, as if it was loaded via GEN1 Description ftsetparams can be used to set the parameters set via when reading a table via GEN1 (samplerate, number of channels, looping, etc). This are necessary by some opcodes (loscil, for example) to play correctly. Together with ftslice it can be used to extract a channel of a multichannel table preserving the table metadata. Syntax f tsetparams i ft , i samplerate , i numchannels , i loopstart = 0 , i basenote = 60 Arguments ift : the table number to modify isamplerate : the sample rate of the data saved in the table inumchannels : the number of channels of the audio sample iloopstart : if this is a loop, start of the sustain part ibasenote : pitch of the sample, as midinote Output Execution Time Init Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gi func0 ftgen 0 , 0 , 0 , - 1 , \"musicbox.flac\" , 0 , 0 , 0 gi 1 ftgen 0 , 0 , nsamp ( gi func0 ), 2 , 0 f tslicei gi func0 , gi 1 , 0 , 0 , 2 f tsetparams gi 1 , ftsr : i ( gi func0 ), 1 gi 2 ftgen 0 , 0 , nsamp ( gi func0 ), 2 , 0 f tslicei gi func0 , gi 2 , 1 , 0 , 2 f tsetparams gi 2 , ftsr : i ( gi func0 ), 1 instr 1 a 0 , a 1 loscil 1 , 1 , gi func0 , 1 outch 1 , a 0 , 2 , a 1 endin instr 2 a 0 loscil 1 , 1 , gi 1 , 1 a 1 loscil 1 , 1 , gi 2 , 1 outch 1 , a 0 , 2 , a 1 endin ; schedule(1, 0, -1) schedule ( 2 , 0 , - 1 ) </ CsInstruments > < CsScore > </ CsScore > </ CsoundSynthesizer > See also ftslice ftslicei loscil ftsr ftchnls Credits Eduardo Moguillansky, 2020","title":"ftsetparams"},{"location":"opcodes/ftsetparams.html#ftsetparams","text":"","title":"ftsetparams"},{"location":"opcodes/ftsetparams.html#abstract","text":"Set metadata parameters of a table, as if it was loaded via GEN1","title":"Abstract"},{"location":"opcodes/ftsetparams.html#description","text":"ftsetparams can be used to set the parameters set via when reading a table via GEN1 (samplerate, number of channels, looping, etc). This are necessary by some opcodes (loscil, for example) to play correctly. Together with ftslice it can be used to extract a channel of a multichannel table preserving the table metadata.","title":"Description"},{"location":"opcodes/ftsetparams.html#syntax","text":"f tsetparams i ft , i samplerate , i numchannels , i loopstart = 0 , i basenote = 60","title":"Syntax"},{"location":"opcodes/ftsetparams.html#arguments","text":"ift : the table number to modify isamplerate : the sample rate of the data saved in the table inumchannels : the number of channels of the audio sample iloopstart : if this is a loop, start of the sustain part ibasenote : pitch of the sample, as midinote","title":"Arguments"},{"location":"opcodes/ftsetparams.html#output","text":"","title":"Output"},{"location":"opcodes/ftsetparams.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/ftsetparams.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gi func0 ftgen 0 , 0 , 0 , - 1 , \"musicbox.flac\" , 0 , 0 , 0 gi 1 ftgen 0 , 0 , nsamp ( gi func0 ), 2 , 0 f tslicei gi func0 , gi 1 , 0 , 0 , 2 f tsetparams gi 1 , ftsr : i ( gi func0 ), 1 gi 2 ftgen 0 , 0 , nsamp ( gi func0 ), 2 , 0 f tslicei gi func0 , gi 2 , 1 , 0 , 2 f tsetparams gi 2 , ftsr : i ( gi func0 ), 1 instr 1 a 0 , a 1 loscil 1 , 1 , gi func0 , 1 outch 1 , a 0 , 2 , a 1 endin instr 2 a 0 loscil 1 , 1 , gi 1 , 1 a 1 loscil 1 , 1 , gi 2 , 1 outch 1 , a 0 , 2 , a 1 endin ; schedule(1, 0, -1) schedule ( 2 , 0 , - 1 ) </ CsInstruments > < CsScore > </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/ftsetparams.html#see-also","text":"ftslice ftslicei loscil ftsr ftchnls","title":"See also"},{"location":"opcodes/ftsetparams.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/getEnvVar.html","text":"getEnvVar Abstract Get the value of an environment variable Description getEnvVar first checks csound own environment and if the variable is not defined checks the global environment. If the variable is not defined, returns an empty string Note Csound updates its environment when passed flags like --env:NAME=value or --env:NAME+=value . Also csound adds the directory of an orchestra loaded at start time to its own path variables, like SSDIR, SADIR, etc. This opcode will reflect those changes Syntax Svalue getEnvVar Svarname Arguments `Svarname': The name of the env variable, something like \"SSDIR\" or \"USER\" Output Svalue : the value of the variable, if defined (an empty string otherwise) Execution Time Init Examples ; Get the value of the HOME env variable S home getEnvVar \"HOME\" ; and the actual value of INCDIR S incdir getEnvVar \"INCDIR\" prints \"HOME: %s , INCDIR: %s \\n \" , S home , S incdir See also system Credits Eduardo Moguillansky, 2020","title":"getEnvVar"},{"location":"opcodes/getEnvVar.html#getenvvar","text":"","title":"getEnvVar"},{"location":"opcodes/getEnvVar.html#abstract","text":"Get the value of an environment variable","title":"Abstract"},{"location":"opcodes/getEnvVar.html#description","text":"getEnvVar first checks csound own environment and if the variable is not defined checks the global environment. If the variable is not defined, returns an empty string Note Csound updates its environment when passed flags like --env:NAME=value or --env:NAME+=value . Also csound adds the directory of an orchestra loaded at start time to its own path variables, like SSDIR, SADIR, etc. This opcode will reflect those changes","title":"Description"},{"location":"opcodes/getEnvVar.html#syntax","text":"Svalue getEnvVar Svarname","title":"Syntax"},{"location":"opcodes/getEnvVar.html#arguments","text":"`Svarname': The name of the env variable, something like \"SSDIR\" or \"USER\"","title":"Arguments"},{"location":"opcodes/getEnvVar.html#output","text":"Svalue : the value of the variable, if defined (an empty string otherwise)","title":"Output"},{"location":"opcodes/getEnvVar.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/getEnvVar.html#examples","text":"; Get the value of the HOME env variable S home getEnvVar \"HOME\" ; and the actual value of INCDIR S incdir getEnvVar \"INCDIR\" prints \"HOME: %s , INCDIR: %s \\n \" , S home , S incdir","title":"Examples"},{"location":"opcodes/getEnvVar.html#see-also","text":"system","title":"See also"},{"location":"opcodes/getEnvVar.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/initerror.html","text":"initerror Abstract Throws an error message at init Description Use initerror to stop the current event with an init error Syntax initerror Smessage Arguments Smessage : the text message to show. Use sprintf to construct a message if needed Output Execution Time Init Examples if i midi > 128 then i niterror sprintf ( \"Received an invalid midi value ( %d )\" , i midi ) endif See also throwerror Credits Eduardo Moguillansky, 2020","title":"initerror"},{"location":"opcodes/initerror.html#initerror","text":"","title":"initerror"},{"location":"opcodes/initerror.html#abstract","text":"Throws an error message at init","title":"Abstract"},{"location":"opcodes/initerror.html#description","text":"Use initerror to stop the current event with an init error","title":"Description"},{"location":"opcodes/initerror.html#syntax","text":"initerror Smessage","title":"Syntax"},{"location":"opcodes/initerror.html#arguments","text":"Smessage : the text message to show. Use sprintf to construct a message if needed","title":"Arguments"},{"location":"opcodes/initerror.html#output","text":"","title":"Output"},{"location":"opcodes/initerror.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/initerror.html#examples","text":"if i midi > 128 then i niterror sprintf ( \"Received an invalid midi value ( %d )\" , i midi ) endif","title":"Examples"},{"location":"opcodes/initerror.html#see-also","text":"throwerror","title":"See also"},{"location":"opcodes/initerror.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/interp1d.html","text":"interp1d Abstract Interpolate between elements of an array/table Description Given a fractional index into an arra/table, interpolate between adjacent items. In the case of a table, a specific column of the table can be selected for performing interpolation. In this case, the index indicates the \"row\", the step value determines the size of each row, and the offset determines which column is used when interpolating. Possible interpolation modes are: linear, cos, floor, exponential and cubic. Together with bisect it can be used to generate any possible breakpoint-function configuration. NB : interp1d performs the opossite operation of bisect NB2 : when used with a table the param value can be given within the string, as \"exp=1.5\" or \"smooth=0.7\". For example, kout = interp1d(kidx, itab, \"exp=1.5\") Note At the moment the interpolation mode is set at init time and can't be modified Syntax k out i nterp1d k idx , xarr [], S mode = \"linear\" , k param = 0 a out i nterp1d a idx , xarr [], S mode = \"linear\" , k param = 0 i out i nterp1d i idx , i arr [], S mode = \"linear\" , k param = 0 k out [] i nterp1d k idx [], xarr [], S mode = \"linear\" , k param = 0 i out [] i nterp1d i idx [], i arr [], S mode = \"linear\" , k param = 0 k out i nterp1d k idx , k tab , S mode = \"linear\" , k step = 1 , k offset = 0 a out i nterp1d a idx , k tab , S mode = \"linear\" , k step = 1 , k offset = 0 i out i nterp1d i idx , i tab , S mode = \"linear\" , k step = 1 , k offset = 0 k out [] i nterp1d k idx [], k tab , S mode = \"linear\" , k step = 1 , k offset = 0 i out [] i nterp1d i idx [], k tab , S mode = \"linear\" , k step = 1 , k offset = 0 Arguments idx : the index into the array/table. For example, using linear interpolation (see mode) an index of 1.5 will interpolate halfway between arr[1] and arr[2] arr : the array (1D) holding the data. tab : the table holding the data mode : the interpolation mode. Possible interpolations modes are: \"linear\", \"cos\", \"floor\", \"cubic\", \"smooth\" (smoothstep, see https://en.wikipedia.org/wiki/Smoothstep), \"smoother\" (perlin's smootherstep) or \"exp\" (exponential). \"smoother\" interpolation is almost equal to \"smooth\" with param=0.7. param : a parameter used by the interpolation mode. In \"exp\" mode, param sets the exponent (2 will result in a quadratic curve). In \"smooth\" mode, param sets the number of extra smoothsteps (default=0). Fractional smoothsteps are possible (see ) Output out : the result of interpolating the array/table at the given index. Examples < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > /* Abstract ======== Interpolate between elements of an array/table Syntax ====== kout interp1d kidx, xarr[], Smode=\"linear\", kparam=0 aout interp1d aidx, xarr[], Smode=\"linear\", kparam=0 iout interp1d iidx, iarr[], Smode=\"linear\", kparam=0 kout[] interp1d kidx[], xarr[], Smode=\"linear\", kparam=0 iout[] interp1d iidx[], iarr[], Smode=\"linear\", kparam=0 kout interp1d kidx, ktab, Smode=\"linear\", kstep=1, koffset=0 aout interp1d aidx, ktab, Smode=\"linear\", kstep=1, koffset=0 iout interp1d iidx, itab, Smode=\"linear\", kstep=1, koffset=0 kout[] interp1d kidx[], ktab, Smode=\"linear\", kstep=1, koffset=0 iout[] interp1d iidx[], ktab, Smode=\"linear\", kstep=1, koffset=0 **NB**: interp1d performs the opposite operation of `bisect` See Also ======== bisect, bpf, linlin, getrowlin, linenv */ ksmps = 10 nchnls = 2 0dbfs = 1 instr example1 i xs [] fillarray 0 , 10 , 16 , 18 , 28 ; interpolate ixs between at index 1.5, interpolating linearly between ; ixs[1] and ixs[2] i out i nterp1d 1.5 , i xs print i out ; -> 13. ; scan ixs at k-rate k idx = line : k ( 0 , p3 , lenarray : i ( i xs ) - 1 ) k out2 i nterp1d k idx , i xs println \"kidx: %f , kout2: %f \" , k idx , k out2 endin instr example2 ; used together with bisect can create multiple piecewise interpolation configurations i times [] fillarray 0 , 4 , 5 , 10 i midi1 [] fillarray 64 , 64 , 63.5 , 64.5 i midi2 [] fillarray 64 , 63.4 , 63.4 , 63 i amps [] fillarray 0 , 0.8 , 0.8 , 0 k idx bisect timeinsts (), i times k amp i nterp1d k idx , i amps , \"cos\" a amp interp k amp a 1 oscili a amp , mtof ( i nterp1d ( k idx , i midi1 , \"cubic\" )) a 2 oscili a amp , mtof ( i nterp1d ( k idx , i midi2 )) println \"amp: %f \" , rms : k ( a amp ) outch 1 , a 1 , 2 , a 2 endin instr example3 ; a table can also be used with interp1d / bisect. A table can hold ; both x and y coordinates as pairs i time2midi1 f tfill 0 , 64 , 4 , 62 , 5 , 62 , 6 , 67 i time2midi2 f tfill 0 , 60 , 4 , 60 , 5 , 59 , 6 , 59 ftfree i time2midi1 , 1 ftfree i time2midi2 , 1 ; step=2, bisect the column 0. k t = timeinsts () k idx1 bisect k t , i time2midi1 , 2 k idx2 bisect k t , i time2midi2 , 2 ; -1: cosine interpolation, step size=2, offset=1 k midi1 i nterp1d k idx1 , i time2midi1 , \"cos\" , 2 , 1 k midi2 i nterp1d k idx2 , i time2midi2 , \"cos\" , 2 , 1 a 0 squinewave a ( mtof ( k midi1 )), a ( 0.1 ), a ( 0.1 ) a 1 squinewave a ( mtof ( k midi2 )), a ( 0.2 ), a ( 0.5 ) i gain = 0.1 i fade = 0.2 a env = linseg : a ( 0 , i fade , i gain , p3 - i fade * 2 - 0.1 , i gain , i fade , 0 ) outch 1 , a 0 * a env , 2 , a 1 * a env endin instr example4 ; test all curves, save to csv i file fiopen \"interp1d.csv\" , 0 fprints i file , \"# kx, kidx, klin, kcos, kfloor, kcub, kexp, ksmooth, ksmooth2, ksmoother \\n \" i xs [] fillarray 0 , 1 , 4 , 5 , 6.4 , 8 i ys [] fillarray 0 , 10 , 2 , 20 , 3.2 , 16 k x line 0 , p3 , i xs [ lenarray ( i xs ) - 1 ] k idx bisect k x , i xs k lin = i nterp1d ( k idx , i ys , \"linear\" ) k cos i nterp1d k idx , i ys , \"cos\" k floor i nterp1d k idx , i ys , \"floor\" k cub = lag ( i nterp1d ( k idx , i ys , \"cubic\" ), 0.1 ) k exp i nterp1d k idx , i ys , \"exp\" , 2 k smooth i nterp1d k idx , i ys , \"smooth\" , 0 k smooth2 i nterp1d k idx , i ys , \"smooth\" , 1 k smoother i nterp1d k idx , i ys , \"smoother\" ; kx, kidx, klin, kcos, kfloor, kcub, kexp[O[I]] fprintks i file , \" %g , %g , %g , %g , %g , %g , %g , %g , %g , %g \\n \" , k x , k idx , k lin , k cos , k floor , k cub , k exp , k smooth , k smooth2 , k smoother endin </ CsInstruments > < CsScore > ; Uncomment to perform each example ; i \"example1\" 0 1 ; i \"example2\" 0 10 ;i \"example3\" 0 7 i \"example4\" 0 2 </ CsScore > </ CsoundSynthesizer > See Also bisect bpf linlin getrowlin linenv","title":"interp1d"},{"location":"opcodes/interp1d.html#interp1d","text":"","title":"interp1d"},{"location":"opcodes/interp1d.html#abstract","text":"Interpolate between elements of an array/table","title":"Abstract"},{"location":"opcodes/interp1d.html#description","text":"Given a fractional index into an arra/table, interpolate between adjacent items. In the case of a table, a specific column of the table can be selected for performing interpolation. In this case, the index indicates the \"row\", the step value determines the size of each row, and the offset determines which column is used when interpolating. Possible interpolation modes are: linear, cos, floor, exponential and cubic. Together with bisect it can be used to generate any possible breakpoint-function configuration. NB : interp1d performs the opossite operation of bisect NB2 : when used with a table the param value can be given within the string, as \"exp=1.5\" or \"smooth=0.7\". For example, kout = interp1d(kidx, itab, \"exp=1.5\") Note At the moment the interpolation mode is set at init time and can't be modified","title":"Description"},{"location":"opcodes/interp1d.html#syntax","text":"k out i nterp1d k idx , xarr [], S mode = \"linear\" , k param = 0 a out i nterp1d a idx , xarr [], S mode = \"linear\" , k param = 0 i out i nterp1d i idx , i arr [], S mode = \"linear\" , k param = 0 k out [] i nterp1d k idx [], xarr [], S mode = \"linear\" , k param = 0 i out [] i nterp1d i idx [], i arr [], S mode = \"linear\" , k param = 0 k out i nterp1d k idx , k tab , S mode = \"linear\" , k step = 1 , k offset = 0 a out i nterp1d a idx , k tab , S mode = \"linear\" , k step = 1 , k offset = 0 i out i nterp1d i idx , i tab , S mode = \"linear\" , k step = 1 , k offset = 0 k out [] i nterp1d k idx [], k tab , S mode = \"linear\" , k step = 1 , k offset = 0 i out [] i nterp1d i idx [], k tab , S mode = \"linear\" , k step = 1 , k offset = 0","title":"Syntax"},{"location":"opcodes/interp1d.html#arguments","text":"idx : the index into the array/table. For example, using linear interpolation (see mode) an index of 1.5 will interpolate halfway between arr[1] and arr[2] arr : the array (1D) holding the data. tab : the table holding the data mode : the interpolation mode. Possible interpolations modes are: \"linear\", \"cos\", \"floor\", \"cubic\", \"smooth\" (smoothstep, see https://en.wikipedia.org/wiki/Smoothstep), \"smoother\" (perlin's smootherstep) or \"exp\" (exponential). \"smoother\" interpolation is almost equal to \"smooth\" with param=0.7. param : a parameter used by the interpolation mode. In \"exp\" mode, param sets the exponent (2 will result in a quadratic curve). In \"smooth\" mode, param sets the number of extra smoothsteps (default=0). Fractional smoothsteps are possible (see )","title":"Arguments"},{"location":"opcodes/interp1d.html#output","text":"out : the result of interpolating the array/table at the given index.","title":"Output"},{"location":"opcodes/interp1d.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > /* Abstract ======== Interpolate between elements of an array/table Syntax ====== kout interp1d kidx, xarr[], Smode=\"linear\", kparam=0 aout interp1d aidx, xarr[], Smode=\"linear\", kparam=0 iout interp1d iidx, iarr[], Smode=\"linear\", kparam=0 kout[] interp1d kidx[], xarr[], Smode=\"linear\", kparam=0 iout[] interp1d iidx[], iarr[], Smode=\"linear\", kparam=0 kout interp1d kidx, ktab, Smode=\"linear\", kstep=1, koffset=0 aout interp1d aidx, ktab, Smode=\"linear\", kstep=1, koffset=0 iout interp1d iidx, itab, Smode=\"linear\", kstep=1, koffset=0 kout[] interp1d kidx[], ktab, Smode=\"linear\", kstep=1, koffset=0 iout[] interp1d iidx[], ktab, Smode=\"linear\", kstep=1, koffset=0 **NB**: interp1d performs the opposite operation of `bisect` See Also ======== bisect, bpf, linlin, getrowlin, linenv */ ksmps = 10 nchnls = 2 0dbfs = 1 instr example1 i xs [] fillarray 0 , 10 , 16 , 18 , 28 ; interpolate ixs between at index 1.5, interpolating linearly between ; ixs[1] and ixs[2] i out i nterp1d 1.5 , i xs print i out ; -> 13. ; scan ixs at k-rate k idx = line : k ( 0 , p3 , lenarray : i ( i xs ) - 1 ) k out2 i nterp1d k idx , i xs println \"kidx: %f , kout2: %f \" , k idx , k out2 endin instr example2 ; used together with bisect can create multiple piecewise interpolation configurations i times [] fillarray 0 , 4 , 5 , 10 i midi1 [] fillarray 64 , 64 , 63.5 , 64.5 i midi2 [] fillarray 64 , 63.4 , 63.4 , 63 i amps [] fillarray 0 , 0.8 , 0.8 , 0 k idx bisect timeinsts (), i times k amp i nterp1d k idx , i amps , \"cos\" a amp interp k amp a 1 oscili a amp , mtof ( i nterp1d ( k idx , i midi1 , \"cubic\" )) a 2 oscili a amp , mtof ( i nterp1d ( k idx , i midi2 )) println \"amp: %f \" , rms : k ( a amp ) outch 1 , a 1 , 2 , a 2 endin instr example3 ; a table can also be used with interp1d / bisect. A table can hold ; both x and y coordinates as pairs i time2midi1 f tfill 0 , 64 , 4 , 62 , 5 , 62 , 6 , 67 i time2midi2 f tfill 0 , 60 , 4 , 60 , 5 , 59 , 6 , 59 ftfree i time2midi1 , 1 ftfree i time2midi2 , 1 ; step=2, bisect the column 0. k t = timeinsts () k idx1 bisect k t , i time2midi1 , 2 k idx2 bisect k t , i time2midi2 , 2 ; -1: cosine interpolation, step size=2, offset=1 k midi1 i nterp1d k idx1 , i time2midi1 , \"cos\" , 2 , 1 k midi2 i nterp1d k idx2 , i time2midi2 , \"cos\" , 2 , 1 a 0 squinewave a ( mtof ( k midi1 )), a ( 0.1 ), a ( 0.1 ) a 1 squinewave a ( mtof ( k midi2 )), a ( 0.2 ), a ( 0.5 ) i gain = 0.1 i fade = 0.2 a env = linseg : a ( 0 , i fade , i gain , p3 - i fade * 2 - 0.1 , i gain , i fade , 0 ) outch 1 , a 0 * a env , 2 , a 1 * a env endin instr example4 ; test all curves, save to csv i file fiopen \"interp1d.csv\" , 0 fprints i file , \"# kx, kidx, klin, kcos, kfloor, kcub, kexp, ksmooth, ksmooth2, ksmoother \\n \" i xs [] fillarray 0 , 1 , 4 , 5 , 6.4 , 8 i ys [] fillarray 0 , 10 , 2 , 20 , 3.2 , 16 k x line 0 , p3 , i xs [ lenarray ( i xs ) - 1 ] k idx bisect k x , i xs k lin = i nterp1d ( k idx , i ys , \"linear\" ) k cos i nterp1d k idx , i ys , \"cos\" k floor i nterp1d k idx , i ys , \"floor\" k cub = lag ( i nterp1d ( k idx , i ys , \"cubic\" ), 0.1 ) k exp i nterp1d k idx , i ys , \"exp\" , 2 k smooth i nterp1d k idx , i ys , \"smooth\" , 0 k smooth2 i nterp1d k idx , i ys , \"smooth\" , 1 k smoother i nterp1d k idx , i ys , \"smoother\" ; kx, kidx, klin, kcos, kfloor, kcub, kexp[O[I]] fprintks i file , \" %g , %g , %g , %g , %g , %g , %g , %g , %g , %g \\n \" , k x , k idx , k lin , k cos , k floor , k cub , k exp , k smooth , k smooth2 , k smoother endin </ CsInstruments > < CsScore > ; Uncomment to perform each example ; i \"example1\" 0 1 ; i \"example2\" 0 10 ;i \"example3\" 0 7 i \"example4\" 0 2 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/interp1d.html#see-also","text":"bisect bpf linlin getrowlin linenv","title":"See Also"},{"location":"opcodes/jsfx.html","text":"jsfx Abstract Instantiates and runs a jsfx script Description jsfx allows to instantiate and run a jsfx audio plugin within csound. There are two ways to run a jsfx script in csound. The simplest way is implemented in this plugin, jsfx , which allows to compile and control a jsfx plugin in one opcode. As an alternative, it is also possible to decouple these actions, first compiling a script (see jsfx_new ) and then calling jsfx_setslider and jsfx_play . Afterwords, slider values can be read via jsfx_getslider jsfx jsfx is an audio programming language implemented pritarily as part of the DAW REAPER . It is a scriptiong language with a built-in jit compiler which translates it to machine code on the fly. It allows the user to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. jsfx inputs and outputs A jsfx script has a certain number of audio input / output channels, and a series of \"sliders\", which are parameters operating at control rate. A script can also use these sliders to send control values, which can be read in csound via jsfx_getslider See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc. Syntax ihandle, aout1 [, aout2, ...] jsfx Spath, ain1 [, ain2, ...] [, id0, kval1, id1, kval2, ...] Arguments Spath : the path to the jsfx script. Either an absolute path, a relative path to the .csd file, or a filename alone, in which case it will be searched first in the current dir and in $SSDIR, if defined. ain1 , ain2 , etc: audio input channels. It is recommended that the number of input streams matches the number of channels expected in the plugin. If you pass less that the expected channels, the rest will be zeroed, and if passing more, only the number of audio channels expected by the plugin will actually be processed idx , kvalx : a jsfx script allows to define up to 64 control parameters, which are called slider s. Each slider has an idx (starting from 1) and a value. Here you can control as many sliders as you need. Each slider consists of a pair of values, an id (i- value) identifying the slider (this corresponds to the sliderx value in the jsfx script) and the value itself (a k- value) Output ihandle : a handle to the jsfx plugin created, which allows to operate on it later, for instance to read slider values via jsfx_getslider aout1 , aout2 : audio output channels. It is recommended that the number of output streams matches the number of channels expected in the plugin. If you pass less that the expected channels, the rest will be zeroed, and if passing more, only the number of audio channels expected by the plugin will actually be processed Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for jsfx opcode gi snd ftgen 0 , 0 , 0 , - 1 , \"bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i h , a 1 jsfx \"tubeharmonics.jsfx\" , a sig , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out if gk dump == 1 then jsfx_dump i h , metro ( 4 ) endif outs a 1 , a 1 endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer > See also jsfx_new jsfx_play jsfx_setslider jsfx_getslider Credits Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"jsfx"},{"location":"opcodes/jsfx.html#jsfx","text":"","title":"jsfx"},{"location":"opcodes/jsfx.html#abstract","text":"Instantiates and runs a jsfx script","title":"Abstract"},{"location":"opcodes/jsfx.html#description","text":"jsfx allows to instantiate and run a jsfx audio plugin within csound. There are two ways to run a jsfx script in csound. The simplest way is implemented in this plugin, jsfx , which allows to compile and control a jsfx plugin in one opcode. As an alternative, it is also possible to decouple these actions, first compiling a script (see jsfx_new ) and then calling jsfx_setslider and jsfx_play . Afterwords, slider values can be read via jsfx_getslider jsfx jsfx is an audio programming language implemented pritarily as part of the DAW REAPER . It is a scriptiong language with a built-in jit compiler which translates it to machine code on the fly. It allows the user to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. jsfx inputs and outputs A jsfx script has a certain number of audio input / output channels, and a series of \"sliders\", which are parameters operating at control rate. A script can also use these sliders to send control values, which can be read in csound via jsfx_getslider See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc.","title":"Description"},{"location":"opcodes/jsfx.html#syntax","text":"ihandle, aout1 [, aout2, ...] jsfx Spath, ain1 [, ain2, ...] [, id0, kval1, id1, kval2, ...]","title":"Syntax"},{"location":"opcodes/jsfx.html#arguments","text":"Spath : the path to the jsfx script. Either an absolute path, a relative path to the .csd file, or a filename alone, in which case it will be searched first in the current dir and in $SSDIR, if defined. ain1 , ain2 , etc: audio input channels. It is recommended that the number of input streams matches the number of channels expected in the plugin. If you pass less that the expected channels, the rest will be zeroed, and if passing more, only the number of audio channels expected by the plugin will actually be processed idx , kvalx : a jsfx script allows to define up to 64 control parameters, which are called slider s. Each slider has an idx (starting from 1) and a value. Here you can control as many sliders as you need. Each slider consists of a pair of values, an id (i- value) identifying the slider (this corresponds to the sliderx value in the jsfx script) and the value itself (a k- value)","title":"Arguments"},{"location":"opcodes/jsfx.html#output","text":"ihandle : a handle to the jsfx plugin created, which allows to operate on it later, for instance to read slider values via jsfx_getslider aout1 , aout2 : audio output channels. It is recommended that the number of output streams matches the number of channels expected in the plugin. If you pass less that the expected channels, the rest will be zeroed, and if passing more, only the number of audio channels expected by the plugin will actually be processed","title":"Output"},{"location":"opcodes/jsfx.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/jsfx.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for jsfx opcode gi snd ftgen 0 , 0 , 0 , - 1 , \"bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i h , a 1 jsfx \"tubeharmonics.jsfx\" , a sig , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out if gk dump == 1 then jsfx_dump i h , metro ( 4 ) endif outs a 1 , a 1 endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/jsfx.html#see-also","text":"jsfx_new jsfx_play jsfx_setslider jsfx_getslider","title":"See also"},{"location":"opcodes/jsfx.html#credits","text":"Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"Credits"},{"location":"opcodes/jsfx_getslider.html","text":"jsfx_setslider Abstract Gets a slider value of a jsfx instance Description With jsfx_getslider it is possible to get the current values of any slider defined in a jsfx script, mostly after calling jsfx or jsfx_play . A jsfx plugin defines a series of up to 64 sliders, which are control parameters used by the script. A slider can also be used to output values to the caller, for example to indicate the gain reduction in a compressor plugin, or the frequency in a pitch tracking plugin. A slider definition in a jsfx script has the form: slider7:0<0,20,0.01>Gain Reduction This defines a control parameter with default value 0 , between 0 and 20 , with a precission (an increment) of 0.01 and a label \"Gain Reduction\". To read the value of that slider: k gainreduction = jsfx_getslider ( i handle , 7 ) jsfx sliders Any slider which is not set via jsfx_setslider retains its default value. A value will always be confined to the range in the slider definition and will also be quantized to the increment in the slider definition. To disable any quantization, set the increment to 0 in the jsfx script jsfx jsfx is an audio programming language implemented primarily as part of the DAW REAPER . It is a scripting language with a built-in compiler which translates it to machine code. It allows to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc. Syntax k value jsfx_getslider i handle , k id Arguments ihandle : the handle created via jsfx_new or jsfx kidx : the slider number (this corresponds to the sliderx value in the jsfx script) Output kvalue : value of the slider Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for the opcodes jsfx_new, jsfx_play and jsfx_setslider gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i handle jsfx_new \"tubeharmonics.jsfx\" print i handle jsfx_setslider i handle , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out a out jsfx_play i handle , a sig if gk dump == 1 then jsfx_dump i handle , metro ( 4 ) endif k 7 jsfx_getslider i handle , 7 printf \"k7: %f \\r \" , changed2 ( k 7 ), k 7 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer > See also jsfx jsfx_new jsfx_play jsfx_setslider Credits Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"jsfx_setslider"},{"location":"opcodes/jsfx_getslider.html#jsfx_setslider","text":"","title":"jsfx_setslider"},{"location":"opcodes/jsfx_getslider.html#abstract","text":"Gets a slider value of a jsfx instance","title":"Abstract"},{"location":"opcodes/jsfx_getslider.html#description","text":"With jsfx_getslider it is possible to get the current values of any slider defined in a jsfx script, mostly after calling jsfx or jsfx_play . A jsfx plugin defines a series of up to 64 sliders, which are control parameters used by the script. A slider can also be used to output values to the caller, for example to indicate the gain reduction in a compressor plugin, or the frequency in a pitch tracking plugin. A slider definition in a jsfx script has the form: slider7:0<0,20,0.01>Gain Reduction This defines a control parameter with default value 0 , between 0 and 20 , with a precission (an increment) of 0.01 and a label \"Gain Reduction\". To read the value of that slider: k gainreduction = jsfx_getslider ( i handle , 7 ) jsfx sliders Any slider which is not set via jsfx_setslider retains its default value. A value will always be confined to the range in the slider definition and will also be quantized to the increment in the slider definition. To disable any quantization, set the increment to 0 in the jsfx script jsfx jsfx is an audio programming language implemented primarily as part of the DAW REAPER . It is a scripting language with a built-in compiler which translates it to machine code. It allows to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc.","title":"Description"},{"location":"opcodes/jsfx_getslider.html#syntax","text":"k value jsfx_getslider i handle , k id","title":"Syntax"},{"location":"opcodes/jsfx_getslider.html#arguments","text":"ihandle : the handle created via jsfx_new or jsfx kidx : the slider number (this corresponds to the sliderx value in the jsfx script)","title":"Arguments"},{"location":"opcodes/jsfx_getslider.html#output","text":"kvalue : value of the slider","title":"Output"},{"location":"opcodes/jsfx_getslider.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/jsfx_getslider.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for the opcodes jsfx_new, jsfx_play and jsfx_setslider gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i handle jsfx_new \"tubeharmonics.jsfx\" print i handle jsfx_setslider i handle , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out a out jsfx_play i handle , a sig if gk dump == 1 then jsfx_dump i handle , metro ( 4 ) endif k 7 jsfx_getslider i handle , 7 printf \"k7: %f \\r \" , changed2 ( k 7 ), k 7 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/jsfx_getslider.html#see-also","text":"jsfx jsfx_new jsfx_play jsfx_setslider","title":"See also"},{"location":"opcodes/jsfx_getslider.html#credits","text":"Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"Credits"},{"location":"opcodes/jsfx_new.html","text":"jsfx_new Abstract Instantiates a jsfx script Description jsfx_new instantiates and compiles a jsfx script (at init time). It returns a handle which can be used to modify control values and perform audio io. It is also possible to instantiate and play a script with only one opcode via jsfx . jsfx jsfx is an audio programming language implemented pritarily as part of the DAW REAPER . It is a scriptiong language with a built-in jit compiler which translates it to machine code on the fly. It allows the user to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. jsfx input / output A jsfx script has a certain number of audio input / output channels, and a series of \"sliders\", which are parameters operating at control rate. A script can also use these sliders to send control values, which can be read in csound via jsfx_getslider See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc. Syntax ihandle jsfx_new Spath Arguments Spath : the path to the jsfx script. Either an absolute path, a relative path to the .csd file, or a filename alone, in which case it will be searched first in the current dir and in $SSDIR, if defined. Output ihandle : a handle to the jsfx plugin created, which allows to operate on it later, for instance to perform audio io via jsfx_play Execution Time Init Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for the opcodes jsfx_new, jsfx_play and jsfx_setslider gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i handle jsfx_new \"tubeharmonics.jsfx\" print i handle jsfx_setslider i handle , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out a out jsfx_play i handle , a sig if gk dump == 1 then jsfx_dump i handle , metro ( 4 ) endif k 7 jsfx_getslider i handle , 7 printf \"k7: %f \\r \" , changed2 ( k 7 ), k 7 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0.1 3600 </ CsScore > </ CsoundSynthesizer > See also jsfx jsfx_play jsfx_setslider jsfx_getslider Credits Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"jsfx_new"},{"location":"opcodes/jsfx_new.html#jsfx_new","text":"","title":"jsfx_new"},{"location":"opcodes/jsfx_new.html#abstract","text":"Instantiates a jsfx script","title":"Abstract"},{"location":"opcodes/jsfx_new.html#description","text":"jsfx_new instantiates and compiles a jsfx script (at init time). It returns a handle which can be used to modify control values and perform audio io. It is also possible to instantiate and play a script with only one opcode via jsfx . jsfx jsfx is an audio programming language implemented pritarily as part of the DAW REAPER . It is a scriptiong language with a built-in jit compiler which translates it to machine code on the fly. It allows the user to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. jsfx input / output A jsfx script has a certain number of audio input / output channels, and a series of \"sliders\", which are parameters operating at control rate. A script can also use these sliders to send control values, which can be read in csound via jsfx_getslider See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc.","title":"Description"},{"location":"opcodes/jsfx_new.html#syntax","text":"ihandle jsfx_new Spath","title":"Syntax"},{"location":"opcodes/jsfx_new.html#arguments","text":"Spath : the path to the jsfx script. Either an absolute path, a relative path to the .csd file, or a filename alone, in which case it will be searched first in the current dir and in $SSDIR, if defined.","title":"Arguments"},{"location":"opcodes/jsfx_new.html#output","text":"ihandle : a handle to the jsfx plugin created, which allows to operate on it later, for instance to perform audio io via jsfx_play","title":"Output"},{"location":"opcodes/jsfx_new.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/jsfx_new.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for the opcodes jsfx_new, jsfx_play and jsfx_setslider gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i handle jsfx_new \"tubeharmonics.jsfx\" print i handle jsfx_setslider i handle , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out a out jsfx_play i handle , a sig if gk dump == 1 then jsfx_dump i handle , metro ( 4 ) endif k 7 jsfx_getslider i handle , 7 printf \"k7: %f \\r \" , changed2 ( k 7 ), k 7 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0.1 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/jsfx_new.html#see-also","text":"jsfx jsfx_play jsfx_setslider jsfx_getslider","title":"See also"},{"location":"opcodes/jsfx_new.html#credits","text":"Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"Credits"},{"location":"opcodes/jsfx_play.html","text":"jsfx_play Abstract Processes audio through a jsfx script Description jsfx_play calls the actual sample processing code defined in a jsfx script. The script must have been initialized via jsfx_new , which instantiates and compiles the script and returns a handle. jsfx jsfx is an audio programming language implemented primarily as part of the DAW REAPER . It is a scriptiong language with a built-in compiler which translates it to machine code on the fly. It allows the user to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. jsfx input / output A jsfx script has a certain number of audio input / output channels. The number of audio inputs / outputs passed to the script does not need to match the number of channels defined in the script but it is advised to do so. More precisely, if a plugin is stereo, passing only one channel will not reduce the work performed by the plugin. A plugin also defines a series of \"sliders\", which are parameters operating at control rate. A script can also use these sliders to send control values back, which can be read in csound via jsfx_getslider See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc. Syntax a1 [, a2, a3, ...] jsfx_play ihandle, ain1 [, ain2, ain3, ...] Arguments ain1 , ain2 , ...: the audio signals passed as input. The amount of channels processed is min(expected number of streams, given number of streams) Output a1 , a2 , ...: the output audio generated by the plugin Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for the opcodes jsfx_new, jsfx_play and jsfx_setslider gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i handle jsfx_new \"tubeharmonics.jsfx\" print i handle jsfx_setslider i handle , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out a out jsfx_play i handle , a sig if gk dump == 1 then jsfx_dump i handle , metro ( 4 ) endif k 7 jsfx_getslider i handle , 7 printf \"k7: %f \\r \" , changed2 ( k 7 ), k 7 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0.1 3600 </ CsScore > </ CsoundSynthesizer > See also jsfx_new jsfx_setslider jsfx_getslider Credits Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"jsfx_play"},{"location":"opcodes/jsfx_play.html#jsfx_play","text":"","title":"jsfx_play"},{"location":"opcodes/jsfx_play.html#abstract","text":"Processes audio through a jsfx script","title":"Abstract"},{"location":"opcodes/jsfx_play.html#description","text":"jsfx_play calls the actual sample processing code defined in a jsfx script. The script must have been initialized via jsfx_new , which instantiates and compiles the script and returns a handle. jsfx jsfx is an audio programming language implemented primarily as part of the DAW REAPER . It is a scriptiong language with a built-in compiler which translates it to machine code on the fly. It allows the user to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. jsfx input / output A jsfx script has a certain number of audio input / output channels. The number of audio inputs / outputs passed to the script does not need to match the number of channels defined in the script but it is advised to do so. More precisely, if a plugin is stereo, passing only one channel will not reduce the work performed by the plugin. A plugin also defines a series of \"sliders\", which are parameters operating at control rate. A script can also use these sliders to send control values back, which can be read in csound via jsfx_getslider See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc.","title":"Description"},{"location":"opcodes/jsfx_play.html#syntax","text":"a1 [, a2, a3, ...] jsfx_play ihandle, ain1 [, ain2, ain3, ...]","title":"Syntax"},{"location":"opcodes/jsfx_play.html#arguments","text":"ain1 , ain2 , ...: the audio signals passed as input. The amount of channels processed is min(expected number of streams, given number of streams)","title":"Arguments"},{"location":"opcodes/jsfx_play.html#output","text":"a1 , a2 , ...: the output audio generated by the plugin","title":"Output"},{"location":"opcodes/jsfx_play.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/jsfx_play.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for the opcodes jsfx_new, jsfx_play and jsfx_setslider gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i handle jsfx_new \"tubeharmonics.jsfx\" print i handle jsfx_setslider i handle , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out a out jsfx_play i handle , a sig if gk dump == 1 then jsfx_dump i handle , metro ( 4 ) endif k 7 jsfx_getslider i handle , 7 printf \"k7: %f \\r \" , changed2 ( k 7 ), k 7 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0.1 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/jsfx_play.html#see-also","text":"jsfx_new jsfx_setslider jsfx_getslider","title":"See also"},{"location":"opcodes/jsfx_play.html#credits","text":"Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"Credits"},{"location":"opcodes/jsfx_setslider.html","text":"jsfx_setslider Abstract Sets the slider values of a jsfx script Description With jsfx_setslider it is possible to set the values of any number of sliders defined in a jsfx script, mostly prior to calling jsfx_play . A jsfx plugin defines a series of up to 64 sliders, which are control parameters used by the script. A slider definition in a jsfx script has the form: slider3:1.5<0,4,0.01>Compression Ratio This defines a control parameter with default value 1.5 , between 0 and 4 , with a precission (an increment) of 0.01 and a label \"Copression Ratio\". k comprat = 2.5 jsfx_setslider i handle , 3 , k comprat The code above will set the slider #3 (the index passed corresponds with the slider number) to the value of kcomprat The value of any slider can be read via jsfx_getvalue (only one value at a time). many sliders It is possible to call jsfx_setslider with any number of sliders. It is not necessary to set all the sliders defined in the script. Any slider which is not set via jsfx_setslider retains its default value. A value will always be confined to the range in the slider definition and will also be quantized to the increment in the slider definition. To disable any quantization, set the increment to 0 in the jsfx script jsfx jsfx is an audio programming language implemented primarily as part of the DAW REAPER . It is a scriptiong language with a built-in compiler which translates it to machine code. It allows the user to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc. Syntax jsfx_setslider i handle , i d1 , k val1 [, i d2 , k val2 , i d3 , k val3 , ... ] Arguments ihandle : the handle created via jsfx_new or jsfx idx , kvalx : a jsfx script allows to define up to 64 control parameters, which are called slider s. Each slider has an idx (starting from 1) and a value. Here you can control as many sliders as you need. Each slider consists of a pair of values, an id identifying the slider (this corresponds to the sliderx value in the jsfx script) and the value itself (a k- value) Output Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for the opcodes jsfx_new, jsfx_play and jsfx_setslider gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i handle jsfx_new \"tubeharmonics.jsfx\" print i handle jsfx_setslider i handle , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out a out jsfx_play i handle , a sig if gk dump == 1 then jsfx_dump i handle , metro ( 4 ) endif k 7 jsfx_getslider i handle , 7 printf \"k7: %f \\r \" , changed2 ( k 7 ), k 7 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer > See also jsfx jsfx_new jsfx_play jsfx_getslider Credits Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"jsfx_setslider"},{"location":"opcodes/jsfx_setslider.html#jsfx_setslider","text":"","title":"jsfx_setslider"},{"location":"opcodes/jsfx_setslider.html#abstract","text":"Sets the slider values of a jsfx script","title":"Abstract"},{"location":"opcodes/jsfx_setslider.html#description","text":"With jsfx_setslider it is possible to set the values of any number of sliders defined in a jsfx script, mostly prior to calling jsfx_play . A jsfx plugin defines a series of up to 64 sliders, which are control parameters used by the script. A slider definition in a jsfx script has the form: slider3:1.5<0,4,0.01>Compression Ratio This defines a control parameter with default value 1.5 , between 0 and 4 , with a precission (an increment) of 0.01 and a label \"Copression Ratio\". k comprat = 2.5 jsfx_setslider i handle , 3 , k comprat The code above will set the slider #3 (the index passed corresponds with the slider number) to the value of kcomprat The value of any slider can be read via jsfx_getvalue (only one value at a time). many sliders It is possible to call jsfx_setslider with any number of sliders. It is not necessary to set all the sliders defined in the script. Any slider which is not set via jsfx_setslider retains its default value. A value will always be confined to the range in the slider definition and will also be quantized to the increment in the slider definition. To disable any quantization, set the increment to 0 in the jsfx script jsfx jsfx is an audio programming language implemented primarily as part of the DAW REAPER . It is a scriptiong language with a built-in compiler which translates it to machine code. It allows the user to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc.","title":"Description"},{"location":"opcodes/jsfx_setslider.html#syntax","text":"jsfx_setslider i handle , i d1 , k val1 [, i d2 , k val2 , i d3 , k val3 , ... ]","title":"Syntax"},{"location":"opcodes/jsfx_setslider.html#arguments","text":"ihandle : the handle created via jsfx_new or jsfx idx , kvalx : a jsfx script allows to define up to 64 control parameters, which are called slider s. Each slider has an idx (starting from 1) and a value. Here you can control as many sliders as you need. Each slider consists of a pair of values, an id identifying the slider (this corresponds to the sliderx value in the jsfx script) and the value itself (a k- value)","title":"Arguments"},{"location":"opcodes/jsfx_setslider.html#output","text":"","title":"Output"},{"location":"opcodes/jsfx_setslider.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/jsfx_setslider.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for the opcodes jsfx_new, jsfx_play and jsfx_setslider gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i handle jsfx_new \"tubeharmonics.jsfx\" print i handle jsfx_setslider i handle , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out a out jsfx_play i handle , a sig if gk dump == 1 then jsfx_dump i handle , metro ( 4 ) endif k 7 jsfx_getslider i handle , 7 printf \"k7: %f \\r \" , changed2 ( k 7 ), k 7 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/jsfx_setslider.html#see-also","text":"jsfx jsfx_new jsfx_play jsfx_getslider","title":"See also"},{"location":"opcodes/jsfx_setslider.html#credits","text":"Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"Credits"},{"location":"opcodes/lfnoise.html","text":"lfnoise Abstract low frequency, band-limited noise Description Generates random values at a rate given by the nearest integer division of the sample rate by the freq argument. If kinterp==0, between generated values 0 is output. Otherwise the output is the result of interpolating between the generated values. Output is always band limited. Syntax a out lfnoise k rate , k interp = 0 Arguments krate : the frequency to generate new values kinterp : if 1, the output is the result of linear interpolation between the generated values Output aout : if kinterp==0, then this is the output random values at the given frequency, or 0. If kinterp==1, then output is the result of interpolation between two generated values. Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* Example file for lfnoise lfnoise generates a random value between 0-1 at the given frequency. If kinterp=1, then values are interpolated; otherwise, they are held until next value */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 FLpanel \"lfnoise\" , 400 , 200 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 322 , 20 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk freq , i h1 FLslider \"freq\" , 0 , 200 , 0 , 3 , i disp1 , 300 , 30 , 20 , 20 gk interp , i h2 FLbutton \"interpolate\" , 1 , 0 , 3 , 100 , 50 , 20 , 80 , - 1 gk gain , i h3 FLslider \"gain\" , 0 , 1 , 0 , 3 , - 1 , 300 , 30 , 20 , 140 FLpanelEnd FLrun FLsetVal_i 8 , i h1 FLsetVal_i 0.1 , i h3 instr 1 a out lfnoise gk freq , gk interp a out *= interp ( gk gain ) outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer > See also dust2 crackle Credits Eduardo Moguillansky, 2019 (port of pd/else's lfnoise , which is itself a merge of supercollider's LFNoise0 and LFNoise1 )","title":"lfnoise"},{"location":"opcodes/lfnoise.html#lfnoise","text":"","title":"lfnoise"},{"location":"opcodes/lfnoise.html#abstract","text":"low frequency, band-limited noise","title":"Abstract"},{"location":"opcodes/lfnoise.html#description","text":"Generates random values at a rate given by the nearest integer division of the sample rate by the freq argument. If kinterp==0, between generated values 0 is output. Otherwise the output is the result of interpolating between the generated values. Output is always band limited.","title":"Description"},{"location":"opcodes/lfnoise.html#syntax","text":"a out lfnoise k rate , k interp = 0","title":"Syntax"},{"location":"opcodes/lfnoise.html#arguments","text":"krate : the frequency to generate new values kinterp : if 1, the output is the result of linear interpolation between the generated values","title":"Arguments"},{"location":"opcodes/lfnoise.html#output","text":"aout : if kinterp==0, then this is the output random values at the given frequency, or 0. If kinterp==1, then output is the result of interpolation between two generated values.","title":"Output"},{"location":"opcodes/lfnoise.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/lfnoise.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* Example file for lfnoise lfnoise generates a random value between 0-1 at the given frequency. If kinterp=1, then values are interpolated; otherwise, they are held until next value */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 FLpanel \"lfnoise\" , 400 , 200 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 322 , 20 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk freq , i h1 FLslider \"freq\" , 0 , 200 , 0 , 3 , i disp1 , 300 , 30 , 20 , 20 gk interp , i h2 FLbutton \"interpolate\" , 1 , 0 , 3 , 100 , 50 , 20 , 80 , - 1 gk gain , i h3 FLslider \"gain\" , 0 , 1 , 0 , 3 , - 1 , 300 , 30 , 20 , 140 FLpanelEnd FLrun FLsetVal_i 8 , i h1 FLsetVal_i 0.1 , i h3 instr 1 a out lfnoise gk freq , gk interp a out *= interp ( gk gain ) outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/lfnoise.html#see-also","text":"dust2 crackle","title":"See also"},{"location":"opcodes/lfnoise.html#credits","text":"Eduardo Moguillansky, 2019 (port of pd/else's lfnoise , which is itself a merge of supercollider's LFNoise0 and LFNoise1 )","title":"Credits"},{"location":"opcodes/linenv.html","text":"linenv Abstract A triggerable linear envelope with sustain segment Description linenv is similar to linsegr with an additional gate argument, allowing to retrigger it at will. One of the values can be defined as a sustain point, meaning that as long as the gate is held, the envelope enters a sustain state when reaching this point. When the gate is set to 0, the envelope traverses the rest of the defined points. Syntax xout linenv k gate , i sustindex , k val0 , [ k time1 , k val1 , k time2 , k val2 , ... ] Arguments kgate : whenever this switches from 0 to 1 a new envelope starts isustindex : the index of the sustain point. For example, if isustindex is 2, then when the envelope reaches kval2 (after ktime0+ktime1), it enters a sustain phase, where its value remains unmodified until the gate is set to 0. If no sustain point is desired, set isustindex to 0. NB : negative values count from end. To imitate the behaviour of linsegr, use -1 as sustain index. kval0 , ktime1 , ...: a linear envelope, similar to linsegr . The release part can have as many segments as desired. ktimex values are defined as time interval between two values, not as absolute timestamps Output xout : value of the envelope (k- or a- rate) Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* This is the example file for opcode \"linenv\" linenv is a triggerable envelope with a sustain segment aout linenv kgate, isustidx, kval0, ktime1, kval1, ..., ktimen, kvaln NB: use xtratim if necessary to allow for release segment */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gk gate init 0 FLpanel \"linenv\" , 240 , 100 , 100 , 100 gk gate , gi h1 FLbutton \" Gate\" , 1 , 0 , 2 , 80 , 40 , 10 , 10 , - 1 FLpanelEnd FLrun instr 1 k gate = trighold : k ( metro ( 1 / 2 ), 0.5 ) k env linenv k gate , 1 , 0 , 0.15 , 1 , 0.1 , 0 printf \"t: %f , kenv: %f \\n \" , timeinstk (), timeinsts (), k env k env *= 0.2 a sig = pinker () * interp ( k env ) outs a sig , a sig endin instr 2 i period = 2 i gatedur = 1 k gate = trighold : k ( metro ( 1 / i period ), i gatedur ) a env linenv k gate , - 2 , 0 , 0.05 , 1 , 0.2 , 0.5 , 0.2 , 1 , 0.4 , 0 a sig = oscili : a ( 0.2 , 1000 ) * a env FLsetVal changed ( k gate ), k gate , gi h1 outs a sig , a sig endin instr 3 a sig pinker a env linenv gk gate , 2 , 0 , 0.05 , 1 , 0.1 , 0.2 , 0.5 , 0 a sig *= a env outs a sig , a sig endin instr 4 ; no sustain (\"one shot\") a sig pinker a env linenv gk gate , 0 , 0 , 0.05 , 1 , 0.1 , 0.2 , 0.5 , 0 a sig *= a env outs a sig , a sig endin </ CsInstruments > < CsScore > ; i1 0 10 ; i2 0 10 ; i3 0 100 i 4 0 100 </ CsScore > </ CsoundSynthesizer > See also ramptrig linsegr bpf Credits Eduardo Moguillansky, 2019 (idea based on pd/else's envgen and supercollider's envgen )","title":"linenv"},{"location":"opcodes/linenv.html#linenv","text":"","title":"linenv"},{"location":"opcodes/linenv.html#abstract","text":"A triggerable linear envelope with sustain segment","title":"Abstract"},{"location":"opcodes/linenv.html#description","text":"linenv is similar to linsegr with an additional gate argument, allowing to retrigger it at will. One of the values can be defined as a sustain point, meaning that as long as the gate is held, the envelope enters a sustain state when reaching this point. When the gate is set to 0, the envelope traverses the rest of the defined points.","title":"Description"},{"location":"opcodes/linenv.html#syntax","text":"xout linenv k gate , i sustindex , k val0 , [ k time1 , k val1 , k time2 , k val2 , ... ]","title":"Syntax"},{"location":"opcodes/linenv.html#arguments","text":"kgate : whenever this switches from 0 to 1 a new envelope starts isustindex : the index of the sustain point. For example, if isustindex is 2, then when the envelope reaches kval2 (after ktime0+ktime1), it enters a sustain phase, where its value remains unmodified until the gate is set to 0. If no sustain point is desired, set isustindex to 0. NB : negative values count from end. To imitate the behaviour of linsegr, use -1 as sustain index. kval0 , ktime1 , ...: a linear envelope, similar to linsegr . The release part can have as many segments as desired. ktimex values are defined as time interval between two values, not as absolute timestamps","title":"Arguments"},{"location":"opcodes/linenv.html#output","text":"xout : value of the envelope (k- or a- rate)","title":"Output"},{"location":"opcodes/linenv.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/linenv.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* This is the example file for opcode \"linenv\" linenv is a triggerable envelope with a sustain segment aout linenv kgate, isustidx, kval0, ktime1, kval1, ..., ktimen, kvaln NB: use xtratim if necessary to allow for release segment */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gk gate init 0 FLpanel \"linenv\" , 240 , 100 , 100 , 100 gk gate , gi h1 FLbutton \" Gate\" , 1 , 0 , 2 , 80 , 40 , 10 , 10 , - 1 FLpanelEnd FLrun instr 1 k gate = trighold : k ( metro ( 1 / 2 ), 0.5 ) k env linenv k gate , 1 , 0 , 0.15 , 1 , 0.1 , 0 printf \"t: %f , kenv: %f \\n \" , timeinstk (), timeinsts (), k env k env *= 0.2 a sig = pinker () * interp ( k env ) outs a sig , a sig endin instr 2 i period = 2 i gatedur = 1 k gate = trighold : k ( metro ( 1 / i period ), i gatedur ) a env linenv k gate , - 2 , 0 , 0.05 , 1 , 0.2 , 0.5 , 0.2 , 1 , 0.4 , 0 a sig = oscili : a ( 0.2 , 1000 ) * a env FLsetVal changed ( k gate ), k gate , gi h1 outs a sig , a sig endin instr 3 a sig pinker a env linenv gk gate , 2 , 0 , 0.05 , 1 , 0.1 , 0.2 , 0.5 , 0 a sig *= a env outs a sig , a sig endin instr 4 ; no sustain (\"one shot\") a sig pinker a env linenv gk gate , 0 , 0 , 0.05 , 1 , 0.1 , 0.2 , 0.5 , 0 a sig *= a env outs a sig , a sig endin </ CsInstruments > < CsScore > ; i1 0 10 ; i2 0 10 ; i3 0 100 i 4 0 100 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/linenv.html#see-also","text":"ramptrig linsegr bpf","title":"See also"},{"location":"opcodes/linenv.html#credits","text":"Eduardo Moguillansky, 2019 (idea based on pd/else's envgen and supercollider's envgen )","title":"Credits"},{"location":"opcodes/loadnpy.html","text":"loadnpy Abstract Load an array (of any number of dimensions) saved as a .npy file Description loadnpy loads an array saved as a .npy file. A .npy file holds a possibly multidimensional array of either int or float type, with members of 32 or 64 bits. This opcodes converts all such formats to a float array of the same shape. For more information on the .npy format, see https://numpy.org/devdocs/reference/generated/numpy.lib.format.html Syntax i Arr [] loadnpy S path k Arr [] loadnpy S path Arguments Spath : the path to the saved .npy file Output iArr / kArr : the data as an array. Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 i A [] loadnpy \"test-float64.npy\" printarray i A i B [] loadnpy \"test-2D.npy\" printarray i B i C [] loadnpy \"test-int.npy\" printarray i C turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also ftgen fillarray ftnew ftfree Credits Eduardo Moguillansky, 2021","title":"loadnpy"},{"location":"opcodes/loadnpy.html#loadnpy","text":"","title":"loadnpy"},{"location":"opcodes/loadnpy.html#abstract","text":"Load an array (of any number of dimensions) saved as a .npy file","title":"Abstract"},{"location":"opcodes/loadnpy.html#description","text":"loadnpy loads an array saved as a .npy file. A .npy file holds a possibly multidimensional array of either int or float type, with members of 32 or 64 bits. This opcodes converts all such formats to a float array of the same shape. For more information on the .npy format, see https://numpy.org/devdocs/reference/generated/numpy.lib.format.html","title":"Description"},{"location":"opcodes/loadnpy.html#syntax","text":"i Arr [] loadnpy S path k Arr [] loadnpy S path","title":"Syntax"},{"location":"opcodes/loadnpy.html#arguments","text":"Spath : the path to the saved .npy file","title":"Arguments"},{"location":"opcodes/loadnpy.html#output","text":"iArr / kArr : the data as an array.","title":"Output"},{"location":"opcodes/loadnpy.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/loadnpy.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 i A [] loadnpy \"test-float64.npy\" printarray i A i B [] loadnpy \"test-2D.npy\" printarray i B i C [] loadnpy \"test-int.npy\" printarray i C turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/loadnpy.html#see-also","text":"ftgen fillarray ftnew ftfree","title":"See also"},{"location":"opcodes/loadnpy.html#credits","text":"Eduardo Moguillansky, 2021","title":"Credits"},{"location":"opcodes/memview.html","text":"memview Abstract Create a view into a table or another array Description memview makes it possible to operate on a table as if it were an array (using any array opcode), or to operate on a slice of an array without copying the underlying memory. It can be used to efficiently read a slice of an existing array, operate on rows of a 2D matrix, etc. The underlying memory is shared between the source and the view for the duration of the event. Using the returned array as a left-side variable is not supported. This can result in reallocation/resizing of the array, which in this case is not allowed since the underlying memory does not belong to the array. Using it in this way results in undefined behaviour The same holds true for creating a view from a ftable and freeing the ftable during the lifetime of the view. Syntax i View [] memview i ft , [, i start = 0 , i end = 0 ] k View [] memview i Source [] [, i start = 0 , i end = 0 ] k View [] memview k Source [] [, i start = 0 , i end = 0 ] Arguments ift : the source ftable iSource[] / kSource[] : the source array istart : the start index of the view (default=0) iend : the end index of the view (non inclusive, default=end of the table / array) Output iView[] / kView[] : the array view Execution time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound - m0 - d </ CsOptions > < CsInstruments > /* memview Create a view into a table or another array iView[] memview ift, [, istart=0, iend=0] kView[] memview iSource[] [, istart=0, iend=0] kView[] memview kSource[] [, istart=0, iend=0] ift: the source ftable iSource[] / kSource[]: the source array istart: the start index of the view (default=0) iend: the end index of the view (non inclusive, default=end of the table / array) memview makes it possible to operate on a table as if it were an array, using any array opcode. It is also possible to take a slice from a different array without copying the underlying elements. It can be used to efficiently read a slice of an existing array, operate on rows of a 2D matrix, etc. The underlying memory is shared between the source and the view for the duration of the event. It is not supported to reuse the array as a left-side variable because that could incurr in reallocation / resizing, which in this case is not allowed since the underlying memory does not belong to the array. Using it in this way results in undefined behaviour. The same holds true for creating a view from a ftable and freeing the ftable during the lifetime of the view. */ gi tab ftgen 0 , 0 , 10 , - 2 , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 instr 1 i View [] memview gi tab prints \" \\n $$$$ Original array:\" printarray i View i View [ 2 ] = 20 i View *= 0.5 prints \" \\n $$$$ Modified array:\" printarray i View prints \" \\n $$$$ Source table should be modified as well \\n \" ftprint gi tab prints \"array length: %d \\n \" , lenarray ( i View ) turnoff endin instr 2 k View [] memview gi tab printf \" \\n $$$$ Original array:\" , 1 printarray k View k View [ 2 ] = 20 k View *= 0.5 printf \" \\n $$$$ Modified array:\" , 1 printarray k View printf \" \\n $$$$ Source table should be modified as well \\n \" , 1 ftprint gi tab , - 1 turnoff endin instr 3 i X [] fillarray 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 i Y [] memview i X , 5 k Z [] memview i X , 3 , 8 i Y *= 10 printarray i Y printarray i X printarray k Z turnoff endin instr 4 k X [] fillarray 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 k Y [] memview k X , 5 k Y *= 0.5 printarray k X printarray k Y turnoff endin </ CsInstruments > < CsScore > ; i1 0 1 ; i2 0 1 i 3 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also copya2ftab slicearray tabrowlin ref deref Credits Eduado Moguillansky, 2019","title":"memview"},{"location":"opcodes/memview.html#memview","text":"","title":"memview"},{"location":"opcodes/memview.html#abstract","text":"Create a view into a table or another array","title":"Abstract"},{"location":"opcodes/memview.html#description","text":"memview makes it possible to operate on a table as if it were an array (using any array opcode), or to operate on a slice of an array without copying the underlying memory. It can be used to efficiently read a slice of an existing array, operate on rows of a 2D matrix, etc. The underlying memory is shared between the source and the view for the duration of the event. Using the returned array as a left-side variable is not supported. This can result in reallocation/resizing of the array, which in this case is not allowed since the underlying memory does not belong to the array. Using it in this way results in undefined behaviour The same holds true for creating a view from a ftable and freeing the ftable during the lifetime of the view.","title":"Description"},{"location":"opcodes/memview.html#syntax","text":"i View [] memview i ft , [, i start = 0 , i end = 0 ] k View [] memview i Source [] [, i start = 0 , i end = 0 ] k View [] memview k Source [] [, i start = 0 , i end = 0 ]","title":"Syntax"},{"location":"opcodes/memview.html#arguments","text":"ift : the source ftable iSource[] / kSource[] : the source array istart : the start index of the view (default=0) iend : the end index of the view (non inclusive, default=end of the table / array)","title":"Arguments"},{"location":"opcodes/memview.html#output","text":"iView[] / kView[] : the array view","title":"Output"},{"location":"opcodes/memview.html#execution-time","text":"Init","title":"Execution time"},{"location":"opcodes/memview.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound - m0 - d </ CsOptions > < CsInstruments > /* memview Create a view into a table or another array iView[] memview ift, [, istart=0, iend=0] kView[] memview iSource[] [, istart=0, iend=0] kView[] memview kSource[] [, istart=0, iend=0] ift: the source ftable iSource[] / kSource[]: the source array istart: the start index of the view (default=0) iend: the end index of the view (non inclusive, default=end of the table / array) memview makes it possible to operate on a table as if it were an array, using any array opcode. It is also possible to take a slice from a different array without copying the underlying elements. It can be used to efficiently read a slice of an existing array, operate on rows of a 2D matrix, etc. The underlying memory is shared between the source and the view for the duration of the event. It is not supported to reuse the array as a left-side variable because that could incurr in reallocation / resizing, which in this case is not allowed since the underlying memory does not belong to the array. Using it in this way results in undefined behaviour. The same holds true for creating a view from a ftable and freeing the ftable during the lifetime of the view. */ gi tab ftgen 0 , 0 , 10 , - 2 , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 instr 1 i View [] memview gi tab prints \" \\n $$$$ Original array:\" printarray i View i View [ 2 ] = 20 i View *= 0.5 prints \" \\n $$$$ Modified array:\" printarray i View prints \" \\n $$$$ Source table should be modified as well \\n \" ftprint gi tab prints \"array length: %d \\n \" , lenarray ( i View ) turnoff endin instr 2 k View [] memview gi tab printf \" \\n $$$$ Original array:\" , 1 printarray k View k View [ 2 ] = 20 k View *= 0.5 printf \" \\n $$$$ Modified array:\" , 1 printarray k View printf \" \\n $$$$ Source table should be modified as well \\n \" , 1 ftprint gi tab , - 1 turnoff endin instr 3 i X [] fillarray 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 i Y [] memview i X , 5 k Z [] memview i X , 3 , 8 i Y *= 10 printarray i Y printarray i X printarray k Z turnoff endin instr 4 k X [] fillarray 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 k Y [] memview k X , 5 k Y *= 0.5 printarray k X printarray k Y turnoff endin </ CsInstruments > < CsScore > ; i1 0 1 ; i2 0 1 i 3 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/memview.html#see-also","text":"copya2ftab slicearray tabrowlin ref deref","title":"See also"},{"location":"opcodes/memview.html#credits","text":"Eduado Moguillansky, 2019","title":"Credits"},{"location":"opcodes/pathAbsolute.html","text":"pathAbsolute Abstract Returns the absolute path of a file Description If a relative path is given as argument, pathAbsolute returns the absolute path relative to the current working directory. pathAbsolute will also expand ~ in unix platforms, so \"~/Documents/foo.txt\" will be expended to \"/home/<user>/Documents/foo.txt\" in linux and \"/Users/<user>/Documents/foo.txt\" in macOS. Other environmental variables are NOT expanded. Current working directory vs script directory Bear in mind that the current working directory is not necessarily the directory of the csd being run but the directory in which csound was started (either directly or via the API). To calculate the absolute path in relation to the directory of the script being run, see scriptDir . Syntax Sabspath pathAbsolute Spath Arguments `Spath': The path to a file or directory Output Sabspath : the absolute path Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* pathAbsolute Returns the absolute path of a file. */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 S path = \"/home/bar\" S abs = pathAbsolute ( S path ) prints \"Path: \\\" %s \\\" , Absolute Path: \\\" %s \\\" \\n \" , S path , S abs S path = \"foo/bar.ext\" S abs = pathAbsolute ( S path ) prints \"Path: \\\" %s \\\" , Absolute Path: \\\" %s \\\" \\n \" , S path , S abs S path = \" ~/Documents/mydoc.txt\" S abs = pathAbsolute ( S path ) prints \"Path: \\\" %s \\\" , Absolute Path: \\\" %s \\\" \\n \" , S path , S abs turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also scriptDir pathJoin pathSplit Credits Eduardo Moguillansky, 2020","title":"pathAbsolute"},{"location":"opcodes/pathAbsolute.html#pathabsolute","text":"","title":"pathAbsolute"},{"location":"opcodes/pathAbsolute.html#abstract","text":"Returns the absolute path of a file","title":"Abstract"},{"location":"opcodes/pathAbsolute.html#description","text":"If a relative path is given as argument, pathAbsolute returns the absolute path relative to the current working directory. pathAbsolute will also expand ~ in unix platforms, so \"~/Documents/foo.txt\" will be expended to \"/home/<user>/Documents/foo.txt\" in linux and \"/Users/<user>/Documents/foo.txt\" in macOS. Other environmental variables are NOT expanded. Current working directory vs script directory Bear in mind that the current working directory is not necessarily the directory of the csd being run but the directory in which csound was started (either directly or via the API). To calculate the absolute path in relation to the directory of the script being run, see scriptDir .","title":"Description"},{"location":"opcodes/pathAbsolute.html#syntax","text":"Sabspath pathAbsolute Spath","title":"Syntax"},{"location":"opcodes/pathAbsolute.html#arguments","text":"`Spath': The path to a file or directory","title":"Arguments"},{"location":"opcodes/pathAbsolute.html#output","text":"Sabspath : the absolute path","title":"Output"},{"location":"opcodes/pathAbsolute.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/pathAbsolute.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* pathAbsolute Returns the absolute path of a file. */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 S path = \"/home/bar\" S abs = pathAbsolute ( S path ) prints \"Path: \\\" %s \\\" , Absolute Path: \\\" %s \\\" \\n \" , S path , S abs S path = \"foo/bar.ext\" S abs = pathAbsolute ( S path ) prints \"Path: \\\" %s \\\" , Absolute Path: \\\" %s \\\" \\n \" , S path , S abs S path = \" ~/Documents/mydoc.txt\" S abs = pathAbsolute ( S path ) prints \"Path: \\\" %s \\\" , Absolute Path: \\\" %s \\\" \\n \" , S path , S abs turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pathAbsolute.html#see-also","text":"scriptDir pathJoin pathSplit","title":"See also"},{"location":"opcodes/pathAbsolute.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/pathIsAbsolute.html","text":"pathIsAbsolute Abstract Returns 1 if the path of a file is absolute Description Returns 1 if the path of a file is absolute Syntax i_isabsolute pathIsAbsolute Spath k_isabsolute pathIsAbsolute Spath Arguments `Spath': The path to a file or directory Output i_isabsolute : 1 if the path is absolute, 0 otherwise Execution Time Init (if the result is i-type) Perf (if the result is k-type) Examples i _isabsolute pathAbsolute \"relative/path/to/file.txt\" prints \"Path is absolute: %s \\n \" , i _isabsolute == 1 ? \"yes\" : \"no\" See also pathAbsolute scriptDir Credits Eduardo Moguillansky, 2020","title":"pathIsAbsolute"},{"location":"opcodes/pathIsAbsolute.html#pathisabsolute","text":"","title":"pathIsAbsolute"},{"location":"opcodes/pathIsAbsolute.html#abstract","text":"Returns 1 if the path of a file is absolute","title":"Abstract"},{"location":"opcodes/pathIsAbsolute.html#description","text":"Returns 1 if the path of a file is absolute","title":"Description"},{"location":"opcodes/pathIsAbsolute.html#syntax","text":"i_isabsolute pathIsAbsolute Spath k_isabsolute pathIsAbsolute Spath","title":"Syntax"},{"location":"opcodes/pathIsAbsolute.html#arguments","text":"`Spath': The path to a file or directory","title":"Arguments"},{"location":"opcodes/pathIsAbsolute.html#output","text":"i_isabsolute : 1 if the path is absolute, 0 otherwise","title":"Output"},{"location":"opcodes/pathIsAbsolute.html#execution-time","text":"Init (if the result is i-type) Perf (if the result is k-type)","title":"Execution Time"},{"location":"opcodes/pathIsAbsolute.html#examples","text":"i _isabsolute pathAbsolute \"relative/path/to/file.txt\" prints \"Path is absolute: %s \\n \" , i _isabsolute == 1 ? \"yes\" : \"no\"","title":"Examples"},{"location":"opcodes/pathIsAbsolute.html#see-also","text":"pathAbsolute scriptDir","title":"See also"},{"location":"opcodes/pathIsAbsolute.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/pathJoin.html","text":"pathJoin Abstract Join two parts of a path according to the current platform Description Given a directory and a filename, or a base directory and a relative path, join these according to the current platform Syntax Sout pathJoin Spath1, Spath2 Arguments Spath1 : The first part to join Spath2 : The second part to join Output Sout : the result of joining both paths Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 S dir = \"/home/bar\" S base = \"filename.ext\" S path = pathJoin ( S dir , S base ) prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S dir = \"/home/bar/\" S base = \"filename.ext\" S path = pathJoin ( S dir , S base ) prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S dir = \"\" S base = \"filename.ext\" S path = pathJoin ( S dir , S base ) prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S dir = \"/home/bar\" S base = \"\" S path = pathJoin ( S dir , S base ) prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also pathSplit pathSplitExt Credits Eduardo Moguillansky, 2020","title":"pathJoin"},{"location":"opcodes/pathJoin.html#pathjoin","text":"","title":"pathJoin"},{"location":"opcodes/pathJoin.html#abstract","text":"Join two parts of a path according to the current platform","title":"Abstract"},{"location":"opcodes/pathJoin.html#description","text":"Given a directory and a filename, or a base directory and a relative path, join these according to the current platform","title":"Description"},{"location":"opcodes/pathJoin.html#syntax","text":"Sout pathJoin Spath1, Spath2","title":"Syntax"},{"location":"opcodes/pathJoin.html#arguments","text":"Spath1 : The first part to join Spath2 : The second part to join","title":"Arguments"},{"location":"opcodes/pathJoin.html#output","text":"Sout : the result of joining both paths","title":"Output"},{"location":"opcodes/pathJoin.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/pathJoin.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 S dir = \"/home/bar\" S base = \"filename.ext\" S path = pathJoin ( S dir , S base ) prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S dir = \"/home/bar/\" S base = \"filename.ext\" S path = pathJoin ( S dir , S base ) prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S dir = \"\" S base = \"filename.ext\" S path = pathJoin ( S dir , S base ) prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S dir = \"/home/bar\" S base = \"\" S path = pathJoin ( S dir , S base ) prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pathJoin.html#see-also","text":"pathSplit pathSplitExt","title":"See also"},{"location":"opcodes/pathJoin.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/pathNative.html","text":"pathNative Abstract Convert a path to its native version Description Convert a path to a native path by replacing path separators to the native separators ('/' in unix, '\\' in windows) This is only useful when passing paths to external processes which need an absolute, native path NB : do not use absolute paths when writing cross-platform paths, since it is not possible to convert an absolute unix path to an absolute windows path (because of windows use of drives) NB2 : windows already converts any forward slash to backwards slash, so as long as you use relative paths, there is no need to use this Syntax Snative pathNative Spath Arguments Spath : the path to convert Output Snative : the native path Execution Time Init Examples S path = \"foo/bar/baz.txt\" S native pathNative S path prints \"Original: %s , Native version: %s \\n \" , S path , S native ; this should print the original in unix, \"foo\\bar\\baz.txt\" in windows See also pathNative Credits Eduardo Moguillansky, 2020","title":"pathNative"},{"location":"opcodes/pathNative.html#pathnative","text":"","title":"pathNative"},{"location":"opcodes/pathNative.html#abstract","text":"Convert a path to its native version","title":"Abstract"},{"location":"opcodes/pathNative.html#description","text":"Convert a path to a native path by replacing path separators to the native separators ('/' in unix, '\\' in windows) This is only useful when passing paths to external processes which need an absolute, native path NB : do not use absolute paths when writing cross-platform paths, since it is not possible to convert an absolute unix path to an absolute windows path (because of windows use of drives) NB2 : windows already converts any forward slash to backwards slash, so as long as you use relative paths, there is no need to use this","title":"Description"},{"location":"opcodes/pathNative.html#syntax","text":"Snative pathNative Spath","title":"Syntax"},{"location":"opcodes/pathNative.html#arguments","text":"Spath : the path to convert","title":"Arguments"},{"location":"opcodes/pathNative.html#output","text":"Snative : the native path","title":"Output"},{"location":"opcodes/pathNative.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/pathNative.html#examples","text":"S path = \"foo/bar/baz.txt\" S native pathNative S path prints \"Original: %s , Native version: %s \\n \" , S path , S native ; this should print the original in unix, \"foo\\bar\\baz.txt\" in windows","title":"Examples"},{"location":"opcodes/pathNative.html#see-also","text":"pathNative","title":"See also"},{"location":"opcodes/pathNative.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/pathSplit.html","text":"pathSplit Abstract Split a path into directory and basename Description Given a path /path/to/filename.txt , split it in /path/to and filename.txt . The directory part will never end with a path separator unless it is the root path Syntax Sdirectory, Sbase pathSplit Spath Arguments Spath : The path to split Output Sdirectory : the directory part of the path Sbase : the basename part of the path Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 S path = \"/home/bar/filename.ext\" S dir , S base pathSplit S path prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S path = \"filename.ext\" S dir , S base pathSplit S path prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S path = \"/filename.ext\" S dir , S base pathSplit S path prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also pathSplitk pathSplitExt pathSplitExtk Credits Eduardo Moguillansky, 2020","title":"pathSplit"},{"location":"opcodes/pathSplit.html#pathsplit","text":"","title":"pathSplit"},{"location":"opcodes/pathSplit.html#abstract","text":"Split a path into directory and basename","title":"Abstract"},{"location":"opcodes/pathSplit.html#description","text":"Given a path /path/to/filename.txt , split it in /path/to and filename.txt . The directory part will never end with a path separator unless it is the root path","title":"Description"},{"location":"opcodes/pathSplit.html#syntax","text":"Sdirectory, Sbase pathSplit Spath","title":"Syntax"},{"location":"opcodes/pathSplit.html#arguments","text":"Spath : The path to split","title":"Arguments"},{"location":"opcodes/pathSplit.html#output","text":"Sdirectory : the directory part of the path Sbase : the basename part of the path","title":"Output"},{"location":"opcodes/pathSplit.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/pathSplit.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 S path = \"/home/bar/filename.ext\" S dir , S base pathSplit S path prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S path = \"filename.ext\" S dir , S base pathSplit S path prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S path = \"/filename.ext\" S dir , S base pathSplit S path prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pathSplit.html#see-also","text":"pathSplitk pathSplitExt pathSplitExtk","title":"See also"},{"location":"opcodes/pathSplit.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/pathSplitExt.html","text":"pathSplitExt Abstract Split a path into prefix and extension Description Given a path /path/to/filename.txt , split it in /path/to/filename and .txt . See pathSplitExtk for a performance time version Syntax Sprefix, Sext pathSplitExt Spath Arguments Spath : The path to split Output Sprefix : Everything before the extension Sext : the extension, beginning with a . Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 S path = \"/home/bar/filename.ext\" S 1 , S ext pathSplitExt S path prints \"Spath: \\\" %s \\\" , S1: \\\" %s \\\" , Sext: \\\" %s \\\"\\n \" , S path , S 1 , S ext S path = \"foo.filename.ext\" S 1 , S ext pathSplitExt S path prints \"Spath: \\\" %s \\\" , S1: \\\" %s \\\" , Sext: \\\" %s \\\"\\n \" , S path , S 1 , S ext S path = \"/filename.ext\" S 1 , S ext pathSplitExt S path prints \"Spath: \\\" %s \\\" , S1: \\\" %s \\\" , Sext: \\\" %s \\\"\\n \" , S path , S 1 , S ext turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also pathSplitExtk pathSplit pathJoin Credits Eduardo Moguillansky, 2020","title":"pathSplitExt"},{"location":"opcodes/pathSplitExt.html#pathsplitext","text":"","title":"pathSplitExt"},{"location":"opcodes/pathSplitExt.html#abstract","text":"Split a path into prefix and extension","title":"Abstract"},{"location":"opcodes/pathSplitExt.html#description","text":"Given a path /path/to/filename.txt , split it in /path/to/filename and .txt . See pathSplitExtk for a performance time version","title":"Description"},{"location":"opcodes/pathSplitExt.html#syntax","text":"Sprefix, Sext pathSplitExt Spath","title":"Syntax"},{"location":"opcodes/pathSplitExt.html#arguments","text":"Spath : The path to split","title":"Arguments"},{"location":"opcodes/pathSplitExt.html#output","text":"Sprefix : Everything before the extension Sext : the extension, beginning with a .","title":"Output"},{"location":"opcodes/pathSplitExt.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/pathSplitExt.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 S path = \"/home/bar/filename.ext\" S 1 , S ext pathSplitExt S path prints \"Spath: \\\" %s \\\" , S1: \\\" %s \\\" , Sext: \\\" %s \\\"\\n \" , S path , S 1 , S ext S path = \"foo.filename.ext\" S 1 , S ext pathSplitExt S path prints \"Spath: \\\" %s \\\" , S1: \\\" %s \\\" , Sext: \\\" %s \\\"\\n \" , S path , S 1 , S ext S path = \"/filename.ext\" S 1 , S ext pathSplitExt S path prints \"Spath: \\\" %s \\\" , S1: \\\" %s \\\" , Sext: \\\" %s \\\"\\n \" , S path , S 1 , S ext turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pathSplitExt.html#see-also","text":"pathSplitExtk pathSplit pathJoin","title":"See also"},{"location":"opcodes/pathSplitExt.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/pathSplitExtk.html","text":"pathSplitExtk Abstract Split a path into prefix and extension at performance time Description Given a path /path/to/filename.txt , split it in /path/to/filename and .txt . See pathSplitExt for an init-time only version Syntax Sprefix, Sext pathSplitExtk Spath Arguments Spath : The path to split Output Sprefix : Everything before the extension Sext : the extension, beginning with a . Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 S path = \"/home/bar/filename.ext\" S 1 , S ext pathSplitExt S path prints \"Spath: \\\" %s \\\" , S1: \\\" %s \\\" , Sext: \\\" %s \\\"\\n \" , S path , S 1 , S ext S path = \"foo.filename.ext\" S 1 , S ext pathSplitExt S path prints \"Spath: \\\" %s \\\" , S1: \\\" %s \\\" , Sext: \\\" %s \\\"\\n \" , S path , S 1 , S ext S path = \"/filename.ext\" S 1 , S ext pathSplitExt S path prints \"Spath: \\\" %s \\\" , S1: \\\" %s \\\" , Sext: \\\" %s \\\"\\n \" , S path , S 1 , S ext turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also pathSplitExt pathSplit pathJoin Credits Eduardo Moguillansky, 2020","title":"pathSplitExtk"},{"location":"opcodes/pathSplitExtk.html#pathsplitextk","text":"","title":"pathSplitExtk"},{"location":"opcodes/pathSplitExtk.html#abstract","text":"Split a path into prefix and extension at performance time","title":"Abstract"},{"location":"opcodes/pathSplitExtk.html#description","text":"Given a path /path/to/filename.txt , split it in /path/to/filename and .txt . See pathSplitExt for an init-time only version","title":"Description"},{"location":"opcodes/pathSplitExtk.html#syntax","text":"Sprefix, Sext pathSplitExtk Spath","title":"Syntax"},{"location":"opcodes/pathSplitExtk.html#arguments","text":"Spath : The path to split","title":"Arguments"},{"location":"opcodes/pathSplitExtk.html#output","text":"Sprefix : Everything before the extension Sext : the extension, beginning with a .","title":"Output"},{"location":"opcodes/pathSplitExtk.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/pathSplitExtk.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 S path = \"/home/bar/filename.ext\" S 1 , S ext pathSplitExt S path prints \"Spath: \\\" %s \\\" , S1: \\\" %s \\\" , Sext: \\\" %s \\\"\\n \" , S path , S 1 , S ext S path = \"foo.filename.ext\" S 1 , S ext pathSplitExt S path prints \"Spath: \\\" %s \\\" , S1: \\\" %s \\\" , Sext: \\\" %s \\\"\\n \" , S path , S 1 , S ext S path = \"/filename.ext\" S 1 , S ext pathSplitExt S path prints \"Spath: \\\" %s \\\" , S1: \\\" %s \\\" , Sext: \\\" %s \\\"\\n \" , S path , S 1 , S ext turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pathSplitExtk.html#see-also","text":"pathSplitExt pathSplit pathJoin","title":"See also"},{"location":"opcodes/pathSplitExtk.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/pathSplitk.html","text":"pathSplitk Abstract Split a path into directory and basename at perf-time Description Given a path /path/to/filename.txt , split it in /path/to and filename.txt . The directory part will never end with a path separator unless it is the root path Syntax Sdirectory, Sbase pathSplitk Spath Arguments Spath : The path to split Output Sdirectory : the directory part of the path Sbase : the basename part of the path Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 S path = \"/home/bar/filename.ext\" S dir , S base pathSplitk S path printsk \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S path = \"filename.ext\" S dir , S base pathSplitk S path printsk \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S path = \"/filename.ext\" S dir , S base pathSplitk S path printsk \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base turnoff endin </ CsInstruments > < CsScore > i 1 0 1 See also pathSplit pathSplitExt pathSplitExtk Credits Eduardo Moguillansky, 2020","title":"pathSplitk"},{"location":"opcodes/pathSplitk.html#pathsplitk","text":"","title":"pathSplitk"},{"location":"opcodes/pathSplitk.html#abstract","text":"Split a path into directory and basename at perf-time","title":"Abstract"},{"location":"opcodes/pathSplitk.html#description","text":"Given a path /path/to/filename.txt , split it in /path/to and filename.txt . The directory part will never end with a path separator unless it is the root path","title":"Description"},{"location":"opcodes/pathSplitk.html#syntax","text":"Sdirectory, Sbase pathSplitk Spath","title":"Syntax"},{"location":"opcodes/pathSplitk.html#arguments","text":"Spath : The path to split","title":"Arguments"},{"location":"opcodes/pathSplitk.html#output","text":"Sdirectory : the directory part of the path Sbase : the basename part of the path","title":"Output"},{"location":"opcodes/pathSplitk.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/pathSplitk.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 S path = \"/home/bar/filename.ext\" S dir , S base pathSplitk S path printsk \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S path = \"filename.ext\" S dir , S base pathSplitk S path printsk \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S path = \"/filename.ext\" S dir , S base pathSplitk S path printsk \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base turnoff endin </ CsInstruments > < CsScore > i 1 0 1","title":"Examples"},{"location":"opcodes/pathSplitk.html#see-also","text":"pathSplit pathSplitExt pathSplitExtk","title":"See also"},{"location":"opcodes/pathSplitk.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/perlin3.html","text":"perlin3 Abstract gradient noise sound generator Description Perlin noise is a type of gradient noise devised by Ken Perlin, and commonly used to add texture to objects rendered in computer graphics. It is deterministic: for a given input co-ordinate it always returns the same output value. To make audible noise you will typically need to define some trajectory through the co-ordinate space. perlin3 is a csound port of Supercollider's Perlin3 Syntax a out perlin3 a x , a y , a z k out perlin3 k x , k y , k z Arguments kx , ky , kz : the coordinates of a point in 3D space. In the current implementation the space wraps at 255 so any value is actually possible. Output aout / kout : the perlin noise corresponding to the given coordinates Execution Time Performance Examples < CsoundSynthesizer > < CsInstruments > /* to be run in csoundqt >= 0.9.8 */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; an empty table to plot gi plot1 ftgen 0 , 0 , 1000 , 2 , 0 gi plot2 ftgen 0 , 0 , 1000 , 2 , 0 opcode tabplot , 0 , Sik S chan , i tab , k value xin outvalue S chan , i tab tablew k value , accum : k ( 1 ), i tab , 0 , 0 , 1 ; update the plot if metro ( 20 ) == 1 then outvalue S chan , k ( - 1 ) endif endop instr perlin3 k speed = line : k ( 1 , 10 , 4 ) a x = accum : a ( k speed / sr ) a z = a x * 0.5 a per1 = perlin3 ( a x , a ( 0 ), a z ) a per2 = perlin3 ( a ( 0 ), a x , a z ) a sig = pinker () * 0.4 ; remap to 0-1 a per1 = ( a per1 + 1 ) * 0.5 a per2 = ( a per2 + 1 ) * 0.5 i lagtime = 0.1 a 1 = a sig * lag ( a per1 , i lagtime ) a 2 = a sig * lag ( a per2 , i lagtime ) a 1 , a 2 reverbsc a 1 , a 2 , 0.92 , 12000 outch 1 , a 1 , 2 , a 2 ; plot the trajectory in csoundqt tabplot \"plot1\" , gi plot1 , a per1 [ 0 ] tabplot \"plot2\" , gi plot2 , a per2 [ 0 ] endin </ CsInstruments > < CsScore > i \"perlin3\" 0 300 </ CsScore > </ CsoundSynthesizer > < bsbPanel > < label > Widgets </ label > < objectName /> < x > 0 </ x > < y > 0 </ y > < w idth > 0 </ w idth > < height > 0 </ height > < visible > true </ visible > < uuid /> < bgcolor mode = \"nobackground\" > < r > 255 </ r > < g > 255 </ g > < b > 255 </ b > </ bgcolor > < bsbObject version = \"2\" type = \"BSBTableDisplay\" > < objectName > plot1 </ objectName > < x > 6 </ x > < y > 11 </ y > < w idth > 500 </ w idth > < height > 150 </ height > < uuid > { b75d16b1 - 05 b 3 - 4358 - 974 e - f 2dfa85d3d34 } </ uuid > < visible > true </ visible > < midichan > 0 </ midichan > < midicc >- 3 </ midicc > < description /> < color > < r > 255 </ r > < g > 193 </ g > < b > 3 </ b > </ color > < range > 0.00 </ range > </ bsbObject > < bsbObject version = \"2\" type = \"BSBTableDisplay\" > < objectName > plot2 </ objectName > < x > 5 </ x > < y > 170 </ y > < w idth > 500 </ w idth > < height > 150 </ height > < uuid > { 9 a 8 bac 1 d - 2234 - 450 c - 8807 - 37 f 9902 bfb 74 } </ uuid > < visible > true </ visible > < midichan > 0 </ midichan > < midicc >- 3 </ midicc > < description /> < color > < r > 255 </ r > < g > 193 </ g > < b > 3 </ b > </ color > < range > 0.00 </ range > </ bsbObject > </ bsbPanel > < bsbPresets > </ bsbPresets > See also Supercollider's Perlin3 Credits Eduardo Moguillansky, 2020","title":"perlin3"},{"location":"opcodes/perlin3.html#perlin3","text":"","title":"perlin3"},{"location":"opcodes/perlin3.html#abstract","text":"gradient noise sound generator","title":"Abstract"},{"location":"opcodes/perlin3.html#description","text":"Perlin noise is a type of gradient noise devised by Ken Perlin, and commonly used to add texture to objects rendered in computer graphics. It is deterministic: for a given input co-ordinate it always returns the same output value. To make audible noise you will typically need to define some trajectory through the co-ordinate space. perlin3 is a csound port of Supercollider's Perlin3","title":"Description"},{"location":"opcodes/perlin3.html#syntax","text":"a out perlin3 a x , a y , a z k out perlin3 k x , k y , k z","title":"Syntax"},{"location":"opcodes/perlin3.html#arguments","text":"kx , ky , kz : the coordinates of a point in 3D space. In the current implementation the space wraps at 255 so any value is actually possible.","title":"Arguments"},{"location":"opcodes/perlin3.html#output","text":"aout / kout : the perlin noise corresponding to the given coordinates","title":"Output"},{"location":"opcodes/perlin3.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/perlin3.html#examples","text":"< CsoundSynthesizer > < CsInstruments > /* to be run in csoundqt >= 0.9.8 */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; an empty table to plot gi plot1 ftgen 0 , 0 , 1000 , 2 , 0 gi plot2 ftgen 0 , 0 , 1000 , 2 , 0 opcode tabplot , 0 , Sik S chan , i tab , k value xin outvalue S chan , i tab tablew k value , accum : k ( 1 ), i tab , 0 , 0 , 1 ; update the plot if metro ( 20 ) == 1 then outvalue S chan , k ( - 1 ) endif endop instr perlin3 k speed = line : k ( 1 , 10 , 4 ) a x = accum : a ( k speed / sr ) a z = a x * 0.5 a per1 = perlin3 ( a x , a ( 0 ), a z ) a per2 = perlin3 ( a ( 0 ), a x , a z ) a sig = pinker () * 0.4 ; remap to 0-1 a per1 = ( a per1 + 1 ) * 0.5 a per2 = ( a per2 + 1 ) * 0.5 i lagtime = 0.1 a 1 = a sig * lag ( a per1 , i lagtime ) a 2 = a sig * lag ( a per2 , i lagtime ) a 1 , a 2 reverbsc a 1 , a 2 , 0.92 , 12000 outch 1 , a 1 , 2 , a 2 ; plot the trajectory in csoundqt tabplot \"plot1\" , gi plot1 , a per1 [ 0 ] tabplot \"plot2\" , gi plot2 , a per2 [ 0 ] endin </ CsInstruments > < CsScore > i \"perlin3\" 0 300 </ CsScore > </ CsoundSynthesizer > < bsbPanel > < label > Widgets </ label > < objectName /> < x > 0 </ x > < y > 0 </ y > < w idth > 0 </ w idth > < height > 0 </ height > < visible > true </ visible > < uuid /> < bgcolor mode = \"nobackground\" > < r > 255 </ r > < g > 255 </ g > < b > 255 </ b > </ bgcolor > < bsbObject version = \"2\" type = \"BSBTableDisplay\" > < objectName > plot1 </ objectName > < x > 6 </ x > < y > 11 </ y > < w idth > 500 </ w idth > < height > 150 </ height > < uuid > { b75d16b1 - 05 b 3 - 4358 - 974 e - f 2dfa85d3d34 } </ uuid > < visible > true </ visible > < midichan > 0 </ midichan > < midicc >- 3 </ midicc > < description /> < color > < r > 255 </ r > < g > 193 </ g > < b > 3 </ b > </ color > < range > 0.00 </ range > </ bsbObject > < bsbObject version = \"2\" type = \"BSBTableDisplay\" > < objectName > plot2 </ objectName > < x > 5 </ x > < y > 170 </ y > < w idth > 500 </ w idth > < height > 150 </ height > < uuid > { 9 a 8 bac 1 d - 2234 - 450 c - 8807 - 37 f 9902 bfb 74 } </ uuid > < visible > true </ visible > < midichan > 0 </ midichan > < midicc >- 3 </ midicc > < description /> < color > < r > 255 </ r > < g > 193 </ g > < b > 3 </ b > </ color > < range > 0.00 </ range > </ bsbObject > </ bsbPanel > < bsbPresets > </ bsbPresets >","title":"Examples"},{"location":"opcodes/perlin3.html#see-also","text":"Supercollider's Perlin3","title":"See also"},{"location":"opcodes/perlin3.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/poly.html","text":"poly Abstract poly creates and controls multiple parallel version of an opcode Description poly creates a user given number of instances of an opcode, each with its own state, inputs and outputs. The resulting output is an array where each element holds the output of the corresponding instance. In general, an opcode has a signature, given by the number and types of its output and input arguments. For example, the opcode oscili as used like aout oscili kamp, kfreq has a signature a / kk ( a as output, kk as input). To follow this example, to create 10 parallel versions of this opcode (an oscillator bank) it is possible to use poly like this: k Freqs [] fillarray 100 , 110 , 200 , 220 , 300 , 330 , 400 , 440 , 500 , 550 a Out [] poly 10 , \"oscili\" , 0.1 , k Freqs Notice that it is possible to set one value for each instance, as given by kFreqs , or one value to be shared by all instances, as given by the amplitude 0.1 . By changing the array kFreqs it is possible to modify the frequency of each oscillator. It is of course possible to chain multiple poly s to generate complex effect chains, and poly can also be used with k-values. Warning At the moment poly works only with builtin opcodes . This might change in the future Note for limitations in the type system of csound, poly works with all opcodes which have at least one output. For opcodes with no outputs (like outch , for example), use poly0 Syntax out1[], [ out2[], ... ] poly inuminstances, Sopcode, xarg0, [xarg1, ...] Arguments inuminstances : the number of instances of Sopcode to instantiate Sopcode : the name of the opcode xargs : any number of arguments, either i-, k- or a-rate, either scalar or arrays, or strings, as needed by the given opcode. String arrays are not yet supported The number and type of the input arguments depend on the arguments passed to the given opcode. The same applies for the output arguments NB : output arguments are always arrays, input arguments can be arrays, in which case they must be at least the size of inuminstances , or scalars, in which case the same value is shared by multiple instances Output The output is one or more arrays of k- or a-type, corresponding to the opcode. For instance, an opcode like aout oscili 0.1, kfreq will output an array of audio channels. An opcode like pan2 will output two audio arrays. Examples LISTEN < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 0dbfs = 1 ; create an array of random values between 0-1 ; inum: number of elements in the array opcode rndarr , i[] , i i num xin i Out [] init i num i 0 = 0 while i 0 < i num do i Out [ i 0 ] = unirand ( 1 ) i 0 += 1 od xout i Out endop ; multiple oscillators, mixed down to mono instr 1 ; number of oscillators i num = 100 ; fundamental k midi = line ( ntom : i ( \"2G\" ), p3 , ntom : i ( \"1C\" )) k f0 = mtof ( k midi ) ; each oscillator is an overtone of f0 k Ratios [] genarray_i 1 , i num ; harmonicity over time k exp line 1 , p3 , 1.32 ; the freq. of each oscillator k Freqs [] = ( k Ratios ^ k exp ) * k f0 ; array of random phases, to avoid synchronous start i Phs [] rndarr i num ; generate the oscillators. a Oscils [] poly i num , \"oscili\" , 1 / i num , k Freqs , - 1 , i Phs a mono sumarray a Oscils a mono *= linsegr : a ( 0 , 0.05 , 1 , 0.05 , 0 ) outs a mono , a mono endin ; poly instances stacked as a processing pipe instr 2 ; amount of polyphony i num = 30 i Freqs [] rndarr i num ; the ratios of the overtones k Ratios [] genarray_i 1 , i num ; a down gliss k m0 linseg ntom : i ( \"2C\" ), p3 * 0.8 , ntom : i ( \"1C\" ) k f0 = mtof ( k m0 ) ; harmonicity curve k p linsegb 1 , p3 * 0.8 , 1.68 ; calculate actual freqs. k Freqs [] = ( k Ratios ^ k p ) * k f0 ; lfo freqs. used for AM and panning k f linsegb 0.1 , p3 * 0.62 , 0.8 , p3 * 0.8 , 0.8 , p3 * 0.96 , 12 , p3 , 60 k LfoFreqs [] = i Freqs * k f ; multiple noise instances, amplitude modulated a A [] poly i num , \"noise\" , 0.5 , 0.3 a Amps [] poly i num , \"oscili\" , 1 , k LfoFreqs * 0.6 a A *= a Amps ; filter noise with bandpass k Q linsegb 0.5 , p3 * 0.5 , 0.02 , p3 , 0.0001 k Bands [] = k Freqs * k Q a B [] poly i num , \"resonr\" , a A , k Freqs , k Bands ; panning. poly works also with k-rate and with ; opcodes producing multiple outputs, like pan2 k PanPos [] poly i num , \"lfo\" , 0.5 , k LfoFreqs k PanPos += 0.5 ; lfo in the range 0-1 for panning a L [], a R [] poly i num , \"pan2\" , a B , k PanPos a left sumarray a L a right sumarray a R ; compress / fade a ref init 1 a sig = 0.707 * ( a left + a right ) a gain compress2 a ref , a sig , - 90 , - 48 , - 24 , 2.5 , 0.05 , 0.2 , 0.05 a left *= a gain a right *= a gain a gain2 compress2 a ref , ( a left + a right ) * 0.707 , - 90 , - 6 , - 3 , 20 , 0.002 , 0.010 , 0.02 a env = a gain2 * cossegr : a ( 0 , 1 , 1 , 0.1 , 0 ) outs a left * a env , a right * a env endin opcode test , a , k k freq xin a out oscili 0.1 , k freq xout a out endop instr 3 ; test udo k freqs [] fillarray 440 , 443 a A [] poly 2 , \"test\" , k freqs a 0 sumarray a A outs a 0 , a 0 endin </ CsInstruments > < CsScore > i 1 0 8 i 2 9 50 ; i 3 0 1 </ CsScore > </ CsoundSynthesizer > See also poly0 maparray polyseq Credits Eduardo Moguillansky, 2019","title":"poly"},{"location":"opcodes/poly.html#poly","text":"","title":"poly"},{"location":"opcodes/poly.html#abstract","text":"poly creates and controls multiple parallel version of an opcode","title":"Abstract"},{"location":"opcodes/poly.html#description","text":"poly creates a user given number of instances of an opcode, each with its own state, inputs and outputs. The resulting output is an array where each element holds the output of the corresponding instance. In general, an opcode has a signature, given by the number and types of its output and input arguments. For example, the opcode oscili as used like aout oscili kamp, kfreq has a signature a / kk ( a as output, kk as input). To follow this example, to create 10 parallel versions of this opcode (an oscillator bank) it is possible to use poly like this: k Freqs [] fillarray 100 , 110 , 200 , 220 , 300 , 330 , 400 , 440 , 500 , 550 a Out [] poly 10 , \"oscili\" , 0.1 , k Freqs Notice that it is possible to set one value for each instance, as given by kFreqs , or one value to be shared by all instances, as given by the amplitude 0.1 . By changing the array kFreqs it is possible to modify the frequency of each oscillator. It is of course possible to chain multiple poly s to generate complex effect chains, and poly can also be used with k-values. Warning At the moment poly works only with builtin opcodes . This might change in the future Note for limitations in the type system of csound, poly works with all opcodes which have at least one output. For opcodes with no outputs (like outch , for example), use poly0","title":"Description"},{"location":"opcodes/poly.html#syntax","text":"out1[], [ out2[], ... ] poly inuminstances, Sopcode, xarg0, [xarg1, ...]","title":"Syntax"},{"location":"opcodes/poly.html#arguments","text":"inuminstances : the number of instances of Sopcode to instantiate Sopcode : the name of the opcode xargs : any number of arguments, either i-, k- or a-rate, either scalar or arrays, or strings, as needed by the given opcode. String arrays are not yet supported The number and type of the input arguments depend on the arguments passed to the given opcode. The same applies for the output arguments NB : output arguments are always arrays, input arguments can be arrays, in which case they must be at least the size of inuminstances , or scalars, in which case the same value is shared by multiple instances","title":"Arguments"},{"location":"opcodes/poly.html#output","text":"The output is one or more arrays of k- or a-type, corresponding to the opcode. For instance, an opcode like aout oscili 0.1, kfreq will output an array of audio channels. An opcode like pan2 will output two audio arrays.","title":"Output"},{"location":"opcodes/poly.html#examples","text":"LISTEN < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 0dbfs = 1 ; create an array of random values between 0-1 ; inum: number of elements in the array opcode rndarr , i[] , i i num xin i Out [] init i num i 0 = 0 while i 0 < i num do i Out [ i 0 ] = unirand ( 1 ) i 0 += 1 od xout i Out endop ; multiple oscillators, mixed down to mono instr 1 ; number of oscillators i num = 100 ; fundamental k midi = line ( ntom : i ( \"2G\" ), p3 , ntom : i ( \"1C\" )) k f0 = mtof ( k midi ) ; each oscillator is an overtone of f0 k Ratios [] genarray_i 1 , i num ; harmonicity over time k exp line 1 , p3 , 1.32 ; the freq. of each oscillator k Freqs [] = ( k Ratios ^ k exp ) * k f0 ; array of random phases, to avoid synchronous start i Phs [] rndarr i num ; generate the oscillators. a Oscils [] poly i num , \"oscili\" , 1 / i num , k Freqs , - 1 , i Phs a mono sumarray a Oscils a mono *= linsegr : a ( 0 , 0.05 , 1 , 0.05 , 0 ) outs a mono , a mono endin ; poly instances stacked as a processing pipe instr 2 ; amount of polyphony i num = 30 i Freqs [] rndarr i num ; the ratios of the overtones k Ratios [] genarray_i 1 , i num ; a down gliss k m0 linseg ntom : i ( \"2C\" ), p3 * 0.8 , ntom : i ( \"1C\" ) k f0 = mtof ( k m0 ) ; harmonicity curve k p linsegb 1 , p3 * 0.8 , 1.68 ; calculate actual freqs. k Freqs [] = ( k Ratios ^ k p ) * k f0 ; lfo freqs. used for AM and panning k f linsegb 0.1 , p3 * 0.62 , 0.8 , p3 * 0.8 , 0.8 , p3 * 0.96 , 12 , p3 , 60 k LfoFreqs [] = i Freqs * k f ; multiple noise instances, amplitude modulated a A [] poly i num , \"noise\" , 0.5 , 0.3 a Amps [] poly i num , \"oscili\" , 1 , k LfoFreqs * 0.6 a A *= a Amps ; filter noise with bandpass k Q linsegb 0.5 , p3 * 0.5 , 0.02 , p3 , 0.0001 k Bands [] = k Freqs * k Q a B [] poly i num , \"resonr\" , a A , k Freqs , k Bands ; panning. poly works also with k-rate and with ; opcodes producing multiple outputs, like pan2 k PanPos [] poly i num , \"lfo\" , 0.5 , k LfoFreqs k PanPos += 0.5 ; lfo in the range 0-1 for panning a L [], a R [] poly i num , \"pan2\" , a B , k PanPos a left sumarray a L a right sumarray a R ; compress / fade a ref init 1 a sig = 0.707 * ( a left + a right ) a gain compress2 a ref , a sig , - 90 , - 48 , - 24 , 2.5 , 0.05 , 0.2 , 0.05 a left *= a gain a right *= a gain a gain2 compress2 a ref , ( a left + a right ) * 0.707 , - 90 , - 6 , - 3 , 20 , 0.002 , 0.010 , 0.02 a env = a gain2 * cossegr : a ( 0 , 1 , 1 , 0.1 , 0 ) outs a left * a env , a right * a env endin opcode test , a , k k freq xin a out oscili 0.1 , k freq xout a out endop instr 3 ; test udo k freqs [] fillarray 440 , 443 a A [] poly 2 , \"test\" , k freqs a 0 sumarray a A outs a 0 , a 0 endin </ CsInstruments > < CsScore > i 1 0 8 i 2 9 50 ; i 3 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/poly.html#see-also","text":"poly0 maparray polyseq","title":"See also"},{"location":"opcodes/poly.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/poly0.html","text":"poly0 Abstract poly0 creates and controls multiple parallel version of an opcode with no outputs Description poly0 creates a user given number of instances of an opcode, each with its own state, inputs and outputs. The resulting output is an array where each element holds the output of the corresponding instance. In general, an opcode has a signature, given by the number and types of its output and input arguments. For example, the opcode oscili as used like aout oscili kamp, kfreq has a signature a / kk ( a as output, kk as input). To follow this example, to create 10 parallel versions of this opcode (an oscillator bank) it is possible to use poly0 like this: k Freqs [] fillarray 100 , 110 , 200 , 220 , 300 , 330 , 400 , 440 , 500 , 550 i Pans [] fillarray 0 , 1 , 0 , 1 , 0.5 , 0.3 , 0.7 , 0.2 , 0.9 , 0.8 a Sigs [] poly 10 , \"oscili\" , 0.1 , k Freqs a Ls [], a Rs [] poly 10 , \"pan2\" , a Sigs , i Pans poly0 10 , \"outch\" , 1 , a Ls poly0 10 , \"outch\" , 2 , a Rs Notice that it is possible to set one value for each instance, as given by kFreqs , or one value to be shared by all instances, as given by the amplitude 0.1 . By changing the array kFreqs it is possible to modify the frequency of each oscillator. It is of course possible to chain multiple poly0 s to generate complex effect chains, and poly0 can also be used with k-values. Warning At the moment poly0 works only with builtin opcodes . This might change in the future Syntax poly0 inuminstances, Sopcode, xarg0, [xarg1, ...] Arguments inuminstances : the number of instances of Sopcode to instantiate Sopcode : the name of the opcode xargs : any number of arguments, either i-, k- or a-rate, either scalar or arrays, or strings, as needed by the given opcode. String arrays are not yet supported The number and type of the input arguments depend on the arguments passed to the given opcode. The same applies for the output arguments NB : output arguments are always arrays, input arguments can be arrays, in which case they must be at least the size of inuminstances , or scalars, in which case the same value is shared by multiple instances Examples See poly for examples See also poly maparray polyseq Credits Eduardo Moguillansky, 2019","title":"poly0"},{"location":"opcodes/poly0.html#poly0","text":"","title":"poly0"},{"location":"opcodes/poly0.html#abstract","text":"poly0 creates and controls multiple parallel version of an opcode with no outputs","title":"Abstract"},{"location":"opcodes/poly0.html#description","text":"poly0 creates a user given number of instances of an opcode, each with its own state, inputs and outputs. The resulting output is an array where each element holds the output of the corresponding instance. In general, an opcode has a signature, given by the number and types of its output and input arguments. For example, the opcode oscili as used like aout oscili kamp, kfreq has a signature a / kk ( a as output, kk as input). To follow this example, to create 10 parallel versions of this opcode (an oscillator bank) it is possible to use poly0 like this: k Freqs [] fillarray 100 , 110 , 200 , 220 , 300 , 330 , 400 , 440 , 500 , 550 i Pans [] fillarray 0 , 1 , 0 , 1 , 0.5 , 0.3 , 0.7 , 0.2 , 0.9 , 0.8 a Sigs [] poly 10 , \"oscili\" , 0.1 , k Freqs a Ls [], a Rs [] poly 10 , \"pan2\" , a Sigs , i Pans poly0 10 , \"outch\" , 1 , a Ls poly0 10 , \"outch\" , 2 , a Rs Notice that it is possible to set one value for each instance, as given by kFreqs , or one value to be shared by all instances, as given by the amplitude 0.1 . By changing the array kFreqs it is possible to modify the frequency of each oscillator. It is of course possible to chain multiple poly0 s to generate complex effect chains, and poly0 can also be used with k-values. Warning At the moment poly0 works only with builtin opcodes . This might change in the future","title":"Description"},{"location":"opcodes/poly0.html#syntax","text":"poly0 inuminstances, Sopcode, xarg0, [xarg1, ...]","title":"Syntax"},{"location":"opcodes/poly0.html#arguments","text":"inuminstances : the number of instances of Sopcode to instantiate Sopcode : the name of the opcode xargs : any number of arguments, either i-, k- or a-rate, either scalar or arrays, or strings, as needed by the given opcode. String arrays are not yet supported The number and type of the input arguments depend on the arguments passed to the given opcode. The same applies for the output arguments NB : output arguments are always arrays, input arguments can be arrays, in which case they must be at least the size of inuminstances , or scalars, in which case the same value is shared by multiple instances","title":"Arguments"},{"location":"opcodes/poly0.html#examples","text":"See poly for examples","title":"Examples"},{"location":"opcodes/poly0.html#see-also","text":"poly maparray polyseq","title":"See also"},{"location":"opcodes/poly0.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/polyseq.html","text":"polyseq Abstract polyseq creates and controls multiple sequential version of an opcode Description polyseq creates a user given number of instances of an opcode, each with its own state. The output of an instance is routed to the input of the next instance, forming a chain. Each instance can be controlled individually. We differentiate between chained and multiplexed arguments. chained arguments are the ones which are mapped from one opcode instance to the next, so that the output of one instance is routed to the input of the next. multiplexed are passed after the chained arguments and work as they do with poly : if an array is passed, then each instance is delivered one element of this array, and if a scalar value is passed, then all instances share the same argument. Example All this is best explained with an example: ; these two signal chains produce the same result a 0 pinker k Freqs [] fillarray 100 , 150 , 300 , 330 a eq rbjeq a 0 , k Freqs [ 0 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 1 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 2 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 3 ], 2 , 10 , 1 , 8 a seq polyseq 4 , \"rbjeq\" , a 0 , k Freqs , 2 , 10 , 1 , 8 Syntax xouts polyseq numinstances:i, opcodename:s, xins, params ... polyseq can have any number of inputs and outputs, as long as the opcode used has matching inputs and outputs. Arguments inuminstances : the number of instances of Sopcode to instantiate Sopcode : the name of the opcode xins : any number of arguments, either k- or a-rate, which should correspond to the outputs of the opcode The number and type of the input arguments depend on the arguments passed to the given opcode. The same applies for the output arguments Output xouts : any number of arguments of type k or a , as output by the opcode Examples LISTEN < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 0dbfs = 1 ; Example file for polyseq instr 1 ; A simple parametric eq. ; On the left channel, the reference signal, ; on the right, the polyseq implementation. ; These should be the same a 0 pinker a 0 *= ampdb ( - 12 ) k Freqs [] fillarray 400 , 1400 , 3000 , 4400 , 8000 , 12000 k Qs [] fillarray 10 , 20 , 10 , 20 , 10 , 20 k V = ampdb ( 18 ) a ref = a 0 a ref rbjeq a ref , k Freqs [ 0 ], k V , k Qs [ 0 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 1 ], k V , k Qs [ 1 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 2 ], k V , k Qs [ 2 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 3 ], k V , k Qs [ 3 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 4 ], k V , k Qs [ 4 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 5 ], k V , k Qs [ 5 ], 1 , 8 a seq polyseq lenarray ( k Freqs ), \"rbjeq\" , a 0 , k Freqs , k V , k Qs , 1 , 8 outs a ref , a seq endin opcode rndarr , i[] , iii i num , i min , i max xin i Out [] init i num i 0 = 0 i delta = i max - i min while i 0 < i num do i Out [ i 0 ] = i min + unirand ( i delta ) i 0 += 1 od xout i Out endop instr 2 ; two varying eqs a 0 = pinker () * ampdb ( - 8 ) k Freqs0 [] fillarray 50 , 130 , 400 , 500 , 1400 , 3000 , 4400 , 5000 , 8000 i num lenarray k Freqs0 i Freqslfo [] rndarr i num , 0.05 , 0.4 k Lfos [] poly i num , \"lfo\" , 0.1 , i Freqslfo k FreqsL [] = k Freqs0 * ( 1 + k Lfos ) k FreqsR [] = k Freqs0 * ( 1 + k Lfos * 1.62 ) k Qs [] poly i num , \"lfo\" , 5 , i Freqslfo * 1.5 k Qs += 7.5 a eqL polyseq i num , \"rbjeq\" , a 0 , k FreqsL , ampdb ( 10 ), k Qs , 1 , 8 a eqR polyseq i num , \"rbjeq\" , a 0 , k FreqsR , ampdb ( 12 ), k Qs * 1.5 , 1 , 8 ; declick a env = linsegr ( 0 , 0.5 , 1 , 0.5 , 0 ) outs a eqL * a env , a eqR * a env endin </ CsInstruments > < CsScore > i 1 0 5 i 2 5 20 </ CsScore > </ CsoundSynthesizer > See also maparray poly Credits Eduardo Moguillansky, 2019","title":"polyseq"},{"location":"opcodes/polyseq.html#polyseq","text":"","title":"polyseq"},{"location":"opcodes/polyseq.html#abstract","text":"polyseq creates and controls multiple sequential version of an opcode","title":"Abstract"},{"location":"opcodes/polyseq.html#description","text":"polyseq creates a user given number of instances of an opcode, each with its own state. The output of an instance is routed to the input of the next instance, forming a chain. Each instance can be controlled individually. We differentiate between chained and multiplexed arguments. chained arguments are the ones which are mapped from one opcode instance to the next, so that the output of one instance is routed to the input of the next. multiplexed are passed after the chained arguments and work as they do with poly : if an array is passed, then each instance is delivered one element of this array, and if a scalar value is passed, then all instances share the same argument.","title":"Description"},{"location":"opcodes/polyseq.html#example","text":"All this is best explained with an example: ; these two signal chains produce the same result a 0 pinker k Freqs [] fillarray 100 , 150 , 300 , 330 a eq rbjeq a 0 , k Freqs [ 0 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 1 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 2 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 3 ], 2 , 10 , 1 , 8 a seq polyseq 4 , \"rbjeq\" , a 0 , k Freqs , 2 , 10 , 1 , 8","title":"Example"},{"location":"opcodes/polyseq.html#syntax","text":"xouts polyseq numinstances:i, opcodename:s, xins, params ... polyseq can have any number of inputs and outputs, as long as the opcode used has matching inputs and outputs.","title":"Syntax"},{"location":"opcodes/polyseq.html#arguments","text":"inuminstances : the number of instances of Sopcode to instantiate Sopcode : the name of the opcode xins : any number of arguments, either k- or a-rate, which should correspond to the outputs of the opcode The number and type of the input arguments depend on the arguments passed to the given opcode. The same applies for the output arguments","title":"Arguments"},{"location":"opcodes/polyseq.html#output","text":"xouts : any number of arguments of type k or a , as output by the opcode","title":"Output"},{"location":"opcodes/polyseq.html#examples","text":"LISTEN < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 0dbfs = 1 ; Example file for polyseq instr 1 ; A simple parametric eq. ; On the left channel, the reference signal, ; on the right, the polyseq implementation. ; These should be the same a 0 pinker a 0 *= ampdb ( - 12 ) k Freqs [] fillarray 400 , 1400 , 3000 , 4400 , 8000 , 12000 k Qs [] fillarray 10 , 20 , 10 , 20 , 10 , 20 k V = ampdb ( 18 ) a ref = a 0 a ref rbjeq a ref , k Freqs [ 0 ], k V , k Qs [ 0 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 1 ], k V , k Qs [ 1 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 2 ], k V , k Qs [ 2 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 3 ], k V , k Qs [ 3 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 4 ], k V , k Qs [ 4 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 5 ], k V , k Qs [ 5 ], 1 , 8 a seq polyseq lenarray ( k Freqs ), \"rbjeq\" , a 0 , k Freqs , k V , k Qs , 1 , 8 outs a ref , a seq endin opcode rndarr , i[] , iii i num , i min , i max xin i Out [] init i num i 0 = 0 i delta = i max - i min while i 0 < i num do i Out [ i 0 ] = i min + unirand ( i delta ) i 0 += 1 od xout i Out endop instr 2 ; two varying eqs a 0 = pinker () * ampdb ( - 8 ) k Freqs0 [] fillarray 50 , 130 , 400 , 500 , 1400 , 3000 , 4400 , 5000 , 8000 i num lenarray k Freqs0 i Freqslfo [] rndarr i num , 0.05 , 0.4 k Lfos [] poly i num , \"lfo\" , 0.1 , i Freqslfo k FreqsL [] = k Freqs0 * ( 1 + k Lfos ) k FreqsR [] = k Freqs0 * ( 1 + k Lfos * 1.62 ) k Qs [] poly i num , \"lfo\" , 5 , i Freqslfo * 1.5 k Qs += 7.5 a eqL polyseq i num , \"rbjeq\" , a 0 , k FreqsL , ampdb ( 10 ), k Qs , 1 , 8 a eqR polyseq i num , \"rbjeq\" , a 0 , k FreqsR , ampdb ( 12 ), k Qs * 1.5 , 1 , 8 ; declick a env = linsegr ( 0 , 0.5 , 1 , 0.5 , 0 ) outs a eqL * a env , a eqR * a env endin </ CsInstruments > < CsScore > i 1 0 5 i 2 5 20 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/polyseq.html#see-also","text":"maparray poly","title":"See also"},{"location":"opcodes/polyseq.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/pool_at.html","text":"pool_at Abstract Returns the item of a pool at a given index Description A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. To get a value, call pool_pop and when finished using it the value is returned to the pool with pool_push . pool_size returns the size of the pool (the number of items in it, not the capacity, see pool_capacity for that) Syntax item pool_at ipool, index kitem pool_at ipool, kindex Arguments ipool : the pool to push the value to index / kindex : the index to query Output item / kitem : the item at the given index Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for pool_at pool_at returns the item of a pool at a given index item pool_at ipool, idx ktem pool_at ipool, kidx */ opcode print_pool , 0 , i i pool xin i 0 = 0 i size = pool_size ( i pool ) while i 0 < i size do i tem = pool_at ( i pool , i 0 ) print i tem i 0 += 1 od endop instr 1 i pool pool_gen 10 i 1 pool_pop i pool i 2 pool_pop i pool prints \" \\n <<< pool size: %d , pool capacity: %d >>> \\n\\n \" , \\ pool_size : i ( i pool ), pool_capacity : i ( i pool ) print_pool i pool turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer > See also pool_capacity pool_pop pool_new pool_gen Credits Eduardo Moguillansky, 2019","title":"pool_at"},{"location":"opcodes/pool_at.html#pool_at","text":"","title":"pool_at"},{"location":"opcodes/pool_at.html#abstract","text":"Returns the item of a pool at a given index","title":"Abstract"},{"location":"opcodes/pool_at.html#description","text":"A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. To get a value, call pool_pop and when finished using it the value is returned to the pool with pool_push . pool_size returns the size of the pool (the number of items in it, not the capacity, see pool_capacity for that)","title":"Description"},{"location":"opcodes/pool_at.html#syntax","text":"item pool_at ipool, index kitem pool_at ipool, kindex","title":"Syntax"},{"location":"opcodes/pool_at.html#arguments","text":"ipool : the pool to push the value to index / kindex : the index to query","title":"Arguments"},{"location":"opcodes/pool_at.html#output","text":"item / kitem : the item at the given index","title":"Output"},{"location":"opcodes/pool_at.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/pool_at.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for pool_at pool_at returns the item of a pool at a given index item pool_at ipool, idx ktem pool_at ipool, kidx */ opcode print_pool , 0 , i i pool xin i 0 = 0 i size = pool_size ( i pool ) while i 0 < i size do i tem = pool_at ( i pool , i 0 ) print i tem i 0 += 1 od endop instr 1 i pool pool_gen 10 i 1 pool_pop i pool i 2 pool_pop i pool prints \" \\n <<< pool size: %d , pool capacity: %d >>> \\n\\n \" , \\ pool_size : i ( i pool ), pool_capacity : i ( i pool ) print_pool i pool turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pool_at.html#see-also","text":"pool_capacity pool_pop pool_new pool_gen","title":"See also"},{"location":"opcodes/pool_at.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/pool_capacity.html","text":"pool_capacity Abstract Returns the capacity of a pool Description A pool is actually a stack of numbers, based on an array. pool_capacity returns the maximum number of items which can be pushed in this pool. If the pool was created with a fixed capacity, then pushing when the pool is full will result in a performance error. To create a pool with dynamic size, use pool_new without giving a capacity (see pool_new ) The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. To get a value, call pool_pop and when finished using it the value is returned to the pool with pool_push . pool_capacity returns the capacity of the pool (the max. number of items it can hold, not the actual size, see pool_size for that) Note To differenciate between the opcode being called at init- or at performance time, use the functional style pool_capacity:i(ipool) or pool_capacity:k(ipool) Syntax icapacity pool_capacity ipool kcapacity pool_capacity kpool Arguments ipool : the pool query Output icapacity / kcapacity : the max. number of items this pool can hold Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for pool_size pool_size returns the size of the pool, either at init or at performance time The size of a pool is the number of items actually inside the pool (see also pool_capacity) */ instr 1 i pool pool_gen 10 i 1 pool_pop i pool i 2 pool_pop i pool prints \" \\n <<< pool size: %d , pool capacity: %d >>> \\n\\n \" , \\ pool_size : i ( i pool ), pool_capacity : i ( i pool ) turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer > See also pool_size pool_pop pool_new pool_gen Credits Eduardo Moguillansky, 2019","title":"pool_capacity"},{"location":"opcodes/pool_capacity.html#pool_capacity","text":"","title":"pool_capacity"},{"location":"opcodes/pool_capacity.html#abstract","text":"Returns the capacity of a pool","title":"Abstract"},{"location":"opcodes/pool_capacity.html#description","text":"A pool is actually a stack of numbers, based on an array. pool_capacity returns the maximum number of items which can be pushed in this pool. If the pool was created with a fixed capacity, then pushing when the pool is full will result in a performance error. To create a pool with dynamic size, use pool_new without giving a capacity (see pool_new ) The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. To get a value, call pool_pop and when finished using it the value is returned to the pool with pool_push . pool_capacity returns the capacity of the pool (the max. number of items it can hold, not the actual size, see pool_size for that) Note To differenciate between the opcode being called at init- or at performance time, use the functional style pool_capacity:i(ipool) or pool_capacity:k(ipool)","title":"Description"},{"location":"opcodes/pool_capacity.html#syntax","text":"icapacity pool_capacity ipool kcapacity pool_capacity kpool","title":"Syntax"},{"location":"opcodes/pool_capacity.html#arguments","text":"ipool : the pool query","title":"Arguments"},{"location":"opcodes/pool_capacity.html#output","text":"icapacity / kcapacity : the max. number of items this pool can hold","title":"Output"},{"location":"opcodes/pool_capacity.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/pool_capacity.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for pool_size pool_size returns the size of the pool, either at init or at performance time The size of a pool is the number of items actually inside the pool (see also pool_capacity) */ instr 1 i pool pool_gen 10 i 1 pool_pop i pool i 2 pool_pop i pool prints \" \\n <<< pool size: %d , pool capacity: %d >>> \\n\\n \" , \\ pool_size : i ( i pool ), pool_capacity : i ( i pool ) turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pool_capacity.html#see-also","text":"pool_size pool_pop pool_new pool_gen","title":"See also"},{"location":"opcodes/pool_capacity.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/pool_gen.html","text":"pool_gen Abstract Create a pool and fill it with values Description A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. pool_gen creates a pool of values of a given size by filling the pool with values from 1 to the given size Syntax ipool pool_gen isize ipool pool_gen istart, iend Arguments isize : the size of the pool. istart : the start item iend : the end item (inclusive) Output ipool : an index identifying this pool. This index is used when calling any pool opcode Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 opcode pool_print , 0 , i i pool xin i 0 = 0 i size = pool_size ( i pool ) while i 0 < i size do i val = pool_at ( i pool , i 0 ) print i val i 0 += 1 od endop instr test1 i pool pool_gen 100 i size pool_size i pool i capacity pool_capacity i pool print i size print i capacity pool_print i pool endin instr test2 ; create a pool, fill with with numbers from 1 to 100 (inclusive) i pool pool_gen 1 , 100 i size pool_size i pool i capacity pool_capacity i pool print i size print i capacity pool_print i pool endin instr sep prints \" \\n -------------------------------- \\n\\n \" ; turnoff endin </ CsInstruments > < CsScore > i \"test1\" 0 0.1 i \"sep\" 0.1 0.1 i \"test2\" 0.2 0.1 </ CsScore > </ CsoundSynthesizer > See also pool_new pool_push pool_pop pool_size pool_capacity Credits Eduardo Moguillansky, 2019","title":"pool_gen"},{"location":"opcodes/pool_gen.html#pool_gen","text":"","title":"pool_gen"},{"location":"opcodes/pool_gen.html#abstract","text":"Create a pool and fill it with values","title":"Abstract"},{"location":"opcodes/pool_gen.html#description","text":"A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. pool_gen creates a pool of values of a given size by filling the pool with values from 1 to the given size","title":"Description"},{"location":"opcodes/pool_gen.html#syntax","text":"ipool pool_gen isize ipool pool_gen istart, iend","title":"Syntax"},{"location":"opcodes/pool_gen.html#arguments","text":"isize : the size of the pool. istart : the start item iend : the end item (inclusive)","title":"Arguments"},{"location":"opcodes/pool_gen.html#output","text":"ipool : an index identifying this pool. This index is used when calling any pool opcode","title":"Output"},{"location":"opcodes/pool_gen.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/pool_gen.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 opcode pool_print , 0 , i i pool xin i 0 = 0 i size = pool_size ( i pool ) while i 0 < i size do i val = pool_at ( i pool , i 0 ) print i val i 0 += 1 od endop instr test1 i pool pool_gen 100 i size pool_size i pool i capacity pool_capacity i pool print i size print i capacity pool_print i pool endin instr test2 ; create a pool, fill with with numbers from 1 to 100 (inclusive) i pool pool_gen 1 , 100 i size pool_size i pool i capacity pool_capacity i pool print i size print i capacity pool_print i pool endin instr sep prints \" \\n -------------------------------- \\n\\n \" ; turnoff endin </ CsInstruments > < CsScore > i \"test1\" 0 0.1 i \"sep\" 0.1 0.1 i \"test2\" 0.2 0.1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pool_gen.html#see-also","text":"pool_new pool_push pool_pop pool_size pool_capacity","title":"See also"},{"location":"opcodes/pool_gen.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/pool_isfull.html","text":"pool_isfull Abstract Returns 1 if the pool is full Description A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually, assigning bus indexes, etc. To get a value, call pool_pop and when finished using it the value is returned to the pool with pool_push . pool_isfull returns 1 if the pool is full (its size == its capacity) and the pool can't be grown. Note Use pool_size(ipool) == 0 to query if the pool is empty Note To differenciate between the opcode being called at init- or at performance time, use the functional style pool_isfull:i(ipool) or pool_isfull:k(ipool) Syntax i_isfull pool_isfull ipool k_isfull pool_isfull ipool Arguments ipool : the pool to push the value to Output i_isfull / k_isfull : 1 if the pool is full, 0 otherwise Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for pool_isfull pool_isfull returns 1 if the pool is full, 0 otherwise If the pool was created The size of a pool is the number of items actually inside the pool (see also pool_capacity) */ instr 1 ; create a pull of fixed size, filled with the integers 0 to 9 i pool pool_gen 10 i 1 pool_pop i pool pool_push i pool , i 1 if pool_isfull : i ( i pool ) == 1 then prints \"pool is full \\n \" endif ; this should fail pool_push i pool , 10 turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer > See also pool_size pool_capacity pool_pop pool_new pool_gen Credits Eduardo Moguillansky, 2019","title":"pool_isfull"},{"location":"opcodes/pool_isfull.html#pool_isfull","text":"","title":"pool_isfull"},{"location":"opcodes/pool_isfull.html#abstract","text":"Returns 1 if the pool is full","title":"Abstract"},{"location":"opcodes/pool_isfull.html#description","text":"A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually, assigning bus indexes, etc. To get a value, call pool_pop and when finished using it the value is returned to the pool with pool_push . pool_isfull returns 1 if the pool is full (its size == its capacity) and the pool can't be grown. Note Use pool_size(ipool) == 0 to query if the pool is empty Note To differenciate between the opcode being called at init- or at performance time, use the functional style pool_isfull:i(ipool) or pool_isfull:k(ipool)","title":"Description"},{"location":"opcodes/pool_isfull.html#syntax","text":"i_isfull pool_isfull ipool k_isfull pool_isfull ipool","title":"Syntax"},{"location":"opcodes/pool_isfull.html#arguments","text":"ipool : the pool to push the value to","title":"Arguments"},{"location":"opcodes/pool_isfull.html#output","text":"i_isfull / k_isfull : 1 if the pool is full, 0 otherwise","title":"Output"},{"location":"opcodes/pool_isfull.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/pool_isfull.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for pool_isfull pool_isfull returns 1 if the pool is full, 0 otherwise If the pool was created The size of a pool is the number of items actually inside the pool (see also pool_capacity) */ instr 1 ; create a pull of fixed size, filled with the integers 0 to 9 i pool pool_gen 10 i 1 pool_pop i pool pool_push i pool , i 1 if pool_isfull : i ( i pool ) == 1 then prints \"pool is full \\n \" endif ; this should fail pool_push i pool , 10 turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pool_isfull.html#see-also","text":"pool_size pool_capacity pool_pop pool_new pool_gen","title":"See also"},{"location":"opcodes/pool_isfull.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/pool_new.html","text":"pool_new Abstract Create an empty pool Description A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. pool_new creates an empty pool. To use the pool it must be first filled with values via pool_push . If a size is given, a pool of the given size is allocated and the size can't be modified. If no size is given, a pool of variable size is created. Variable size / fixed size A variable size pool produces allocations during performance, which might be a problem in certain situations / architectures or when running in --realtime mode. Syntax ipool pool_new isize=0 Arguments isize : the size of the pool. If leaved out or set as 0, a pool of variable size is created. Values can be pushed via pool_push and the pool will grow to accomodate these. Output ipool : an index identifying this pool. This index is used when calling any pool opcode Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; create an empty global pool of fixed capacity. gi pool pool_new 100 instr 1 pool_push gi pool , 45 pool_push gi pool , 47 i size pool_size gi pool print i size i num1 pool_pop gi pool i num2 pool_pop gi pool print i num1 print i num2 i size pool_size gi pool print i size turnoff endin </ CsInstruments > < CsScore > i 1 0 1 e 5 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also pool_gen pool_push pool_pop pool_size pool_capacity Credits Eduardo Moguillansky, 2019","title":"pool_new"},{"location":"opcodes/pool_new.html#pool_new","text":"","title":"pool_new"},{"location":"opcodes/pool_new.html#abstract","text":"Create an empty pool","title":"Abstract"},{"location":"opcodes/pool_new.html#description","text":"A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. pool_new creates an empty pool. To use the pool it must be first filled with values via pool_push . If a size is given, a pool of the given size is allocated and the size can't be modified. If no size is given, a pool of variable size is created. Variable size / fixed size A variable size pool produces allocations during performance, which might be a problem in certain situations / architectures or when running in --realtime mode.","title":"Description"},{"location":"opcodes/pool_new.html#syntax","text":"ipool pool_new isize=0","title":"Syntax"},{"location":"opcodes/pool_new.html#arguments","text":"isize : the size of the pool. If leaved out or set as 0, a pool of variable size is created. Values can be pushed via pool_push and the pool will grow to accomodate these.","title":"Arguments"},{"location":"opcodes/pool_new.html#output","text":"ipool : an index identifying this pool. This index is used when calling any pool opcode","title":"Output"},{"location":"opcodes/pool_new.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/pool_new.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; create an empty global pool of fixed capacity. gi pool pool_new 100 instr 1 pool_push gi pool , 45 pool_push gi pool , 47 i size pool_size gi pool print i size i num1 pool_pop gi pool i num2 pool_pop gi pool print i num1 print i num2 i size pool_size gi pool print i size turnoff endin </ CsInstruments > < CsScore > i 1 0 1 e 5 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pool_new.html#see-also","text":"pool_gen pool_push pool_pop pool_size pool_capacity","title":"See also"},{"location":"opcodes/pool_new.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/pool_pop.html","text":"pool_pop Abstract Pop (get) an item from a pool Description A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. To get a value, call pool_pop and when finished using it the value is returned to the pool with pool_push . Syntax ivalue pool_pop ipool [, iifempty=-1] kvalue pool_pop ipool [, kifempty=-1] Arguments ipool : the pool to push the value to iifempty / kifempty : this value is returned if the pool is empty. Output ivalue / kvalue : the value to push Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; create a global pool for all instances gi pool pool_gen 1 , 1000 ; create audio buses gi numbuses = 200 zakinit gi numbuses , 1 ; a pool of buses gi buses pool_gen gi numbuses ; release item back to instance pool, print a message ; when that happens opcode pool_release_instance , 0 , ii i pool , i p1 xin i val = f rac2int ( i p1 , pool_capacity ( i pool )) defer \"prints\" , \"releasing back to pool %d \\n \" , i val pool_push i pool , i val , 1 endop instr exit exitnow endin ; schedule and control audio generator instr controlsaw ; get an unused bus i bus = pool_pop ( gi buses ) prints \"Using bus %d \\n \" , i bus i freq = p5 i cap pool_capacity gi pool ; get a unique instance number for \"saw\" instrument i saw = nstrnum ( \"saw\" ) + pool_pop ( gi pool ) / i cap schedule i saw , 0 , p3 , i bus , i freq ; modulate the frequency pwrite i saw , 5 , linseg ( i freq , p3 , i freq * 0.1 ) ; get a unique instance number for filter instrument i filter = nstrnum ( \"filter\" ) + pool_pop ( gi pool ) / i cap schedule i filter , 0 , p3 , i bus , 100 ; modulate its cutoff freq. pwrite i filter , 5 , linseg ( 100 , p3 , 4000 ) ; release bus back to pool when finished (notice the 1 at the end) ; we could have done ; defer \"pool_push\", gibuses, ibus pool_push gi buses , i bus , 1 endin instr saw i bus = p4 k freq = p5 i amp = 0.02 i fade = 0.05 a 0 = vco2 ( i amp , k freq ) a 0 += vco2 ( i amp , k freq * 0.5 ) a 0 += vco2 ( i amp , k freq * 0.25 ) a 0 *= cosseg ( 0 , p3 * 0.5 , 1 , p3 * 0.5 , 0 ) ; write audio to bus zawm a 0 , i bus ; release instance back to the pool pool_release_instance gi pool , p1 endin ; filter audio in bus, output to the outside world instr filter i bus = p4 k freq = p5 a 0 zar i bus a 0 zdf_ladder a 0 , k freq , 18 outch 1 , a 0 endin instr + example1 i dur = 10 ; dur of each note i offset = 0.6 ; offset between notes i Freqs [] genarray 1000 , 8000 , 100 ; begin freq. of gliss. for each note printarray i Freqs ; create a note for each frequency i 0 = 0 while i 0 < lenarray ( i Freqs ) do schedule \"controlsaw\" , i offset * i 0 , i dur , 0 , i Freqs [ i 0 ] i 0 += 1 od ; clear zak zacl 0 , gi numbuses ; schedule exit schedule \"exit\" , i offset * i 0 + i dur + 1 , - 1 endin schedule \"example1\" , 0 , - 1 </ CsInstruments > < CsScore > </ CsScore > </ CsoundSynthesizer > See also pool_push pool_new pool_gen pool_size pool_capacity Credits Eduardo Moguillansky, 2019","title":"pool_pop"},{"location":"opcodes/pool_pop.html#pool_pop","text":"","title":"pool_pop"},{"location":"opcodes/pool_pop.html#abstract","text":"Pop (get) an item from a pool","title":"Abstract"},{"location":"opcodes/pool_pop.html#description","text":"A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. To get a value, call pool_pop and when finished using it the value is returned to the pool with pool_push .","title":"Description"},{"location":"opcodes/pool_pop.html#syntax","text":"ivalue pool_pop ipool [, iifempty=-1] kvalue pool_pop ipool [, kifempty=-1]","title":"Syntax"},{"location":"opcodes/pool_pop.html#arguments","text":"ipool : the pool to push the value to iifempty / kifempty : this value is returned if the pool is empty.","title":"Arguments"},{"location":"opcodes/pool_pop.html#output","text":"ivalue / kvalue : the value to push","title":"Output"},{"location":"opcodes/pool_pop.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/pool_pop.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; create a global pool for all instances gi pool pool_gen 1 , 1000 ; create audio buses gi numbuses = 200 zakinit gi numbuses , 1 ; a pool of buses gi buses pool_gen gi numbuses ; release item back to instance pool, print a message ; when that happens opcode pool_release_instance , 0 , ii i pool , i p1 xin i val = f rac2int ( i p1 , pool_capacity ( i pool )) defer \"prints\" , \"releasing back to pool %d \\n \" , i val pool_push i pool , i val , 1 endop instr exit exitnow endin ; schedule and control audio generator instr controlsaw ; get an unused bus i bus = pool_pop ( gi buses ) prints \"Using bus %d \\n \" , i bus i freq = p5 i cap pool_capacity gi pool ; get a unique instance number for \"saw\" instrument i saw = nstrnum ( \"saw\" ) + pool_pop ( gi pool ) / i cap schedule i saw , 0 , p3 , i bus , i freq ; modulate the frequency pwrite i saw , 5 , linseg ( i freq , p3 , i freq * 0.1 ) ; get a unique instance number for filter instrument i filter = nstrnum ( \"filter\" ) + pool_pop ( gi pool ) / i cap schedule i filter , 0 , p3 , i bus , 100 ; modulate its cutoff freq. pwrite i filter , 5 , linseg ( 100 , p3 , 4000 ) ; release bus back to pool when finished (notice the 1 at the end) ; we could have done ; defer \"pool_push\", gibuses, ibus pool_push gi buses , i bus , 1 endin instr saw i bus = p4 k freq = p5 i amp = 0.02 i fade = 0.05 a 0 = vco2 ( i amp , k freq ) a 0 += vco2 ( i amp , k freq * 0.5 ) a 0 += vco2 ( i amp , k freq * 0.25 ) a 0 *= cosseg ( 0 , p3 * 0.5 , 1 , p3 * 0.5 , 0 ) ; write audio to bus zawm a 0 , i bus ; release instance back to the pool pool_release_instance gi pool , p1 endin ; filter audio in bus, output to the outside world instr filter i bus = p4 k freq = p5 a 0 zar i bus a 0 zdf_ladder a 0 , k freq , 18 outch 1 , a 0 endin instr + example1 i dur = 10 ; dur of each note i offset = 0.6 ; offset between notes i Freqs [] genarray 1000 , 8000 , 100 ; begin freq. of gliss. for each note printarray i Freqs ; create a note for each frequency i 0 = 0 while i 0 < lenarray ( i Freqs ) do schedule \"controlsaw\" , i offset * i 0 , i dur , 0 , i Freqs [ i 0 ] i 0 += 1 od ; clear zak zacl 0 , gi numbuses ; schedule exit schedule \"exit\" , i offset * i 0 + i dur + 1 , - 1 endin schedule \"example1\" , 0 , - 1 </ CsInstruments > < CsScore > </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pool_pop.html#see-also","text":"pool_push pool_new pool_gen pool_size pool_capacity","title":"See also"},{"location":"opcodes/pool_pop.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/pool_push.html","text":"pool_push Abstract Push an item into a pool Description A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. To get a value, call pool_pop and when finished using it the value is returned to the pool with pool_push . Syntax pool_push ipool, ivalue, iwhen=0 pool_push ipool, kvalue Arguments ipool : the pool to push the value to ivalue / kvalue : the value to push iwhen : if 0, the value is pushed at init time, if 1 the value is pushed at release time. This argument can only be used when calling the opcode at init time Output Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; create a global pool for all instances gi pool pool_gen 1 , 1000 ; create audio buses gi numbuses = 200 zakinit gi numbuses , 1 ; a pool of buses gi buses pool_gen gi numbuses ; release item back to instance pool, print a message ; when that happens opcode pool_release_instance , 0 , ii i pool , i p1 xin i val = f rac2int ( i p1 , pool_capacity ( i pool )) defer \"prints\" , \"releasing back to pool %d \\n \" , i val pool_push i pool , i val , 1 endop instr exit exitnow endin ; schedule and control audio generator instr controlsaw ; get an unused bus i bus = pool_pop ( gi buses ) prints \"Using bus %d \\n \" , i bus i freq = p5 i cap pool_capacity gi pool ; get a unique instance number for \"saw\" instrument i saw = nstrnum ( \"saw\" ) + pool_pop ( gi pool ) / i cap schedule i saw , 0 , p3 , i bus , i freq ; modulate the frequency pwrite i saw , 5 , linseg ( i freq , p3 , i freq * 0.1 ) ; get a unique instance number for filter instrument i filter = nstrnum ( \"filter\" ) + pool_pop ( gi pool ) / i cap schedule i filter , 0 , p3 , i bus , 100 ; modulate its cutoff freq. pwrite i filter , 5 , linseg ( 100 , p3 , 4000 ) ; release bus back to pool when finished (notice the 1 at the end) ; we could have done ; defer \"pool_push\", gibuses, ibus pool_push gi buses , i bus , 1 endin instr saw i bus = p4 k freq = p5 i amp = 0.02 i fade = 0.05 a 0 = vco2 ( i amp , k freq ) a 0 += vco2 ( i amp , k freq * 0.5 ) a 0 += vco2 ( i amp , k freq * 0.25 ) a 0 *= cosseg ( 0 , p3 * 0.5 , 1 , p3 * 0.5 , 0 ) ; write audio to bus zawm a 0 , i bus ; release instance back to the pool pool_release_instance gi pool , p1 endin ; filter audio in bus, output to the outside world instr filter i bus = p4 k freq = p5 a 0 zar i bus a 0 zdf_ladder a 0 , k freq , 18 outch 1 , a 0 endin instr + example1 i dur = 10 ; dur of each note i offset = 0.6 ; offset between notes i Freqs [] genarray 1000 , 8000 , 100 ; begin freq. of gliss. for each note printarray i Freqs ; create a note for each frequency i 0 = 0 while i 0 < lenarray ( i Freqs ) do schedule \"controlsaw\" , i offset * i 0 , i dur , 0 , i Freqs [ i 0 ] i 0 += 1 od ; clear zak zacl 0 , gi numbuses ; schedule exit schedule \"exit\" , i offset * i 0 + i dur + 1 , - 1 endin schedule \"example1\" , 0 , - 1 </ CsInstruments > < CsScore > </ CsScore > </ CsoundSynthesizer > See also pool_pop pool_new pool_gen Credits Eduardo Moguillansky, 2019","title":"pool_push"},{"location":"opcodes/pool_push.html#pool_push","text":"","title":"pool_push"},{"location":"opcodes/pool_push.html#abstract","text":"Push an item into a pool","title":"Abstract"},{"location":"opcodes/pool_push.html#description","text":"A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. To get a value, call pool_pop and when finished using it the value is returned to the pool with pool_push .","title":"Description"},{"location":"opcodes/pool_push.html#syntax","text":"pool_push ipool, ivalue, iwhen=0 pool_push ipool, kvalue","title":"Syntax"},{"location":"opcodes/pool_push.html#arguments","text":"ipool : the pool to push the value to ivalue / kvalue : the value to push iwhen : if 0, the value is pushed at init time, if 1 the value is pushed at release time. This argument can only be used when calling the opcode at init time","title":"Arguments"},{"location":"opcodes/pool_push.html#output","text":"","title":"Output"},{"location":"opcodes/pool_push.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/pool_push.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; create a global pool for all instances gi pool pool_gen 1 , 1000 ; create audio buses gi numbuses = 200 zakinit gi numbuses , 1 ; a pool of buses gi buses pool_gen gi numbuses ; release item back to instance pool, print a message ; when that happens opcode pool_release_instance , 0 , ii i pool , i p1 xin i val = f rac2int ( i p1 , pool_capacity ( i pool )) defer \"prints\" , \"releasing back to pool %d \\n \" , i val pool_push i pool , i val , 1 endop instr exit exitnow endin ; schedule and control audio generator instr controlsaw ; get an unused bus i bus = pool_pop ( gi buses ) prints \"Using bus %d \\n \" , i bus i freq = p5 i cap pool_capacity gi pool ; get a unique instance number for \"saw\" instrument i saw = nstrnum ( \"saw\" ) + pool_pop ( gi pool ) / i cap schedule i saw , 0 , p3 , i bus , i freq ; modulate the frequency pwrite i saw , 5 , linseg ( i freq , p3 , i freq * 0.1 ) ; get a unique instance number for filter instrument i filter = nstrnum ( \"filter\" ) + pool_pop ( gi pool ) / i cap schedule i filter , 0 , p3 , i bus , 100 ; modulate its cutoff freq. pwrite i filter , 5 , linseg ( 100 , p3 , 4000 ) ; release bus back to pool when finished (notice the 1 at the end) ; we could have done ; defer \"pool_push\", gibuses, ibus pool_push gi buses , i bus , 1 endin instr saw i bus = p4 k freq = p5 i amp = 0.02 i fade = 0.05 a 0 = vco2 ( i amp , k freq ) a 0 += vco2 ( i amp , k freq * 0.5 ) a 0 += vco2 ( i amp , k freq * 0.25 ) a 0 *= cosseg ( 0 , p3 * 0.5 , 1 , p3 * 0.5 , 0 ) ; write audio to bus zawm a 0 , i bus ; release instance back to the pool pool_release_instance gi pool , p1 endin ; filter audio in bus, output to the outside world instr filter i bus = p4 k freq = p5 a 0 zar i bus a 0 zdf_ladder a 0 , k freq , 18 outch 1 , a 0 endin instr + example1 i dur = 10 ; dur of each note i offset = 0.6 ; offset between notes i Freqs [] genarray 1000 , 8000 , 100 ; begin freq. of gliss. for each note printarray i Freqs ; create a note for each frequency i 0 = 0 while i 0 < lenarray ( i Freqs ) do schedule \"controlsaw\" , i offset * i 0 , i dur , 0 , i Freqs [ i 0 ] i 0 += 1 od ; clear zak zacl 0 , gi numbuses ; schedule exit schedule \"exit\" , i offset * i 0 + i dur + 1 , - 1 endin schedule \"example1\" , 0 , - 1 </ CsInstruments > < CsScore > </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pool_push.html#see-also","text":"pool_pop pool_new pool_gen","title":"See also"},{"location":"opcodes/pool_push.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/pool_size.html","text":"pool_size Abstract Returns the size of a pool Description A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. To get a value, call pool_pop and when finished using it the value is returned to the pool with pool_push . pool_size returns the size of the pool (the number of items in it, not the capacity, see pool_capacity for that) Note To differenciate between the opcode being called at init- or at performance time, use the functional style pool_size:i(ipool) or pool_size:k(ipool) Syntax isize pool_size ipool ksize pool_size kpool Arguments ipool : the pool to push the value to Output isize / ksize : the number of items in the pool Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for pool_size pool_size returns the size of the pool, either at init or at performance time The size of a pool is the number of items actually inside the pool (see also pool_capacity) */ opcode print_pool , 0 , i i pool xin i 0 = 0 i size = pool_size ( i pool ) while i 0 < i size do i tem = pool_at ( i pool , i 0 ) print i tem i 0 += 1 od endop instr 1 i pool pool_gen 10 i 1 pool_pop i pool i 2 pool_pop i pool prints \" \\n <<< pool size: %d , pool capacity: %d >>> \\n\\n \" , \\ pool_size : i ( i pool ), pool_capacity : i ( i pool ) print_pool i pool turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer > See also pool_capacity pool_pop pool_new pool_gen Credits Eduardo Moguillansky, 2019","title":"pool_size"},{"location":"opcodes/pool_size.html#pool_size","text":"","title":"pool_size"},{"location":"opcodes/pool_size.html#abstract","text":"Returns the size of a pool","title":"Abstract"},{"location":"opcodes/pool_size.html#description","text":"A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. To get a value, call pool_pop and when finished using it the value is returned to the pool with pool_push . pool_size returns the size of the pool (the number of items in it, not the capacity, see pool_capacity for that) Note To differenciate between the opcode being called at init- or at performance time, use the functional style pool_size:i(ipool) or pool_size:k(ipool)","title":"Description"},{"location":"opcodes/pool_size.html#syntax","text":"isize pool_size ipool ksize pool_size kpool","title":"Syntax"},{"location":"opcodes/pool_size.html#arguments","text":"ipool : the pool to push the value to","title":"Arguments"},{"location":"opcodes/pool_size.html#output","text":"isize / ksize : the number of items in the pool","title":"Output"},{"location":"opcodes/pool_size.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/pool_size.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for pool_size pool_size returns the size of the pool, either at init or at performance time The size of a pool is the number of items actually inside the pool (see also pool_capacity) */ opcode print_pool , 0 , i i pool xin i 0 = 0 i size = pool_size ( i pool ) while i 0 < i size do i tem = pool_at ( i pool , i 0 ) print i tem i 0 += 1 od endop instr 1 i pool pool_gen 10 i 1 pool_pop i pool i 2 pool_pop i pool prints \" \\n <<< pool size: %d , pool capacity: %d >>> \\n\\n \" , \\ pool_size : i ( i pool ), pool_capacity : i ( i pool ) print_pool i pool turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pool_size.html#see-also","text":"pool_capacity pool_pop pool_new pool_gen","title":"See also"},{"location":"opcodes/pool_size.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/pread.html","text":"pread Abstract Read pfield values from any active instrument instance Description pread can be used to query the pfield value of a running instance (possibly a fractional instrument number) of an instrument. Together with pwrite it can be used to establish a two-way communication between two running instances of any two instruments. It no instance is found that matches the given instrument number, the output value is set to inotfound . Behaviour If no matching instance is found, pread returns inotfound . Reporting starts at the moment a matching instance is found. To avoid a continuous search, set instrnum as negative number. In this case, a matching instance is searched only once, and, if not found, this opcode becomes a noop If an instance is found and stops, pread returns inotfound from the moment the instance stops and no new instance is searched. Syntax output : i | k pread i nstrnum : i , i ndex : i | k [, i notfound =- 1 ] Arguments instrnum (i): the (fractional) instrument number to modify index (i or k): the index of the pfield to read. If kindex is 4, then p4 will be modified inotfound : the value to return if instrnum is not found. To avoid misinterpretation, this value should be different than any expected value of the pfield Output output (i or k): the current value of the given pfield. Will be inotfound if no matching instance has been found. Execution Time Init (if output is of i-type) Performance (if output is of k-type) Examples < CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > /* Example file for pread ====================== ivalue pread instrnum, index [, inotfound=-1] kvalue pread instrnum, kindex [, inotfound=-1] pread reads a pfield value from an active instrument Returns inotfound if instrnum is not active Raises a performance error if index is out of range */ instr 1 print p4 endin instr 2 i p4 pread 1.01 , 4 printf \"<<<< instr 1.01 p4= %f >>>> \\n \" , 1 , i p4 turnoff endin </ CsInstruments > < CsScore > i 1.01 0 2 95 i 2 1 0.1 </ CsScore > </ CsoundSynthesizer > See also pwrite pset p passign uniqinstance Credits Eduardo Moguillansky, 2019","title":"pread"},{"location":"opcodes/pread.html#pread","text":"","title":"pread"},{"location":"opcodes/pread.html#abstract","text":"Read pfield values from any active instrument instance","title":"Abstract"},{"location":"opcodes/pread.html#description","text":"pread can be used to query the pfield value of a running instance (possibly a fractional instrument number) of an instrument. Together with pwrite it can be used to establish a two-way communication between two running instances of any two instruments. It no instance is found that matches the given instrument number, the output value is set to inotfound .","title":"Description"},{"location":"opcodes/pread.html#behaviour","text":"If no matching instance is found, pread returns inotfound . Reporting starts at the moment a matching instance is found. To avoid a continuous search, set instrnum as negative number. In this case, a matching instance is searched only once, and, if not found, this opcode becomes a noop If an instance is found and stops, pread returns inotfound from the moment the instance stops and no new instance is searched.","title":"Behaviour"},{"location":"opcodes/pread.html#syntax","text":"output : i | k pread i nstrnum : i , i ndex : i | k [, i notfound =- 1 ]","title":"Syntax"},{"location":"opcodes/pread.html#arguments","text":"instrnum (i): the (fractional) instrument number to modify index (i or k): the index of the pfield to read. If kindex is 4, then p4 will be modified inotfound : the value to return if instrnum is not found. To avoid misinterpretation, this value should be different than any expected value of the pfield","title":"Arguments"},{"location":"opcodes/pread.html#output","text":"output (i or k): the current value of the given pfield. Will be inotfound if no matching instance has been found.","title":"Output"},{"location":"opcodes/pread.html#execution-time","text":"Init (if output is of i-type) Performance (if output is of k-type)","title":"Execution Time"},{"location":"opcodes/pread.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > /* Example file for pread ====================== ivalue pread instrnum, index [, inotfound=-1] kvalue pread instrnum, kindex [, inotfound=-1] pread reads a pfield value from an active instrument Returns inotfound if instrnum is not active Raises a performance error if index is out of range */ instr 1 print p4 endin instr 2 i p4 pread 1.01 , 4 printf \"<<<< instr 1.01 p4= %f >>>> \\n \" , 1 , i p4 turnoff endin </ CsInstruments > < CsScore > i 1.01 0 2 95 i 2 1 0.1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pread.html#see-also","text":"pwrite pset p passign uniqinstance","title":"See also"},{"location":"opcodes/pread.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/pwrite.html","text":"pwrite Abstract Modify pfield values of an active instrument instance Description pwrite can be used to modify the value of a pfield of a running instance (possibly a fractional instrument number). Dynamic pfields In order for pwrite to have any effect, the instrument in question should have an assignment of the sort kfreq = p5 . Behaviour A matching instance is searched at performance time, so that its behaviour can be controlled via if or timout statements. If no active instance is found, search is retried until a matching instance is found. To avoid retrying, set instrnum to a negative value. If the instance ceases to exist during another instrument is modifying its pfield values, nothing happens. pwrite notices that the instance is not active anymore and becomes a NOOP . Exact instance vs Broadcasting If instrnum is a fractional instrument number, pwrite will only affect the first instance matching this exact number. If instrnum is set to an integer number, pwrite will broadcast the changes to ALL instruments with the same integer number. Warning Setting a value of a pfield out of range will result in a performance error. Syntax pwrite i nstrnum : i , i ndex : i | k , value : i | k , [ i ndex2 , value2 , ... ] Arguments instrnum (init only): the (fractional) instrument number to modify index (i-, k-): the index of the pfield to modify. If kindex is 4, then p4 will be modified value (i-, k-): the new value of the given pfield Info Multiple index:value pairs can be modified simultaneously Execution Time Init (if index and value are i-values) Performance (if any index or value are k-variables) Examples < CsoundSynthesizer > < CsOptions > - odac - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr exit exitnow endin ;; Example 1. instr 2 creates and controls instr 1 instr 1 pset 0 , 0 , 0 , 40 , 50 k t timeinsts k 4 = p4 k 5 = p5 printf \"time: %.4f \\t instance: %.3f \\t p4: %f \\t p5: %f \\n \" , metro ( 20 ), k t , p1 , k 4 , k 5 endin instr 2 k val line 0 , p3 , 1 pwrite 1.01 , 4 , k val pwrite 1.02 , 5 , k val * 2 endin instr example1 schedule 1.01 , 0 , 4 , - 1 schedule 1.02 , 0 , 4 , - 1 schedule 2 , 1 , 1 schedule \"exit\" , 4 , - 1 turnoff endin ;----------------------------- ; Example 2, one instrument modulates another instr ex2_generator pset p1 , p2 , p3 , 0.5 , 1000 , 4000 , 0.1 k amp = p4 k freq = p5 k cutoff = p6 k resonance = p7 a saw vco2 , k amp , k freq a out moogladder2 , a saw , k cutoff , k resonance a out *= linsegr ( 0 , 0.1 , 1 , 0.1 , 0 ) outs a out , a out endin instr ex2_control i glissdur = p4 i num = nstrnum ( \"ex2_generator\" ) i num1 = i num + 0.001 i num2 = i num + 0.002 k freq1 linseg ntof ( \"4A\" ), i glissdur , ntof ( \"3A\" ) k freq2 linseg ntof ( \"4F\" ), i glissdur , ntof ( \"3F\" ) ; amp schedule i num1 , 0 , p3 , 0.2 schedule i num2 , 0 , p3 , 0.2 pwrite i num1 , 5 , k freq1 pwrite i num2 , 5 , k freq2 endin instr ex2_broadcast printf \"filter start \\n \" , 1 i num = nstrnum ( \"ex2_generator\" ) k cutoff linseg 4000 , p3 , 400 k resonance linseg 0.1 , p3 * 0.5 , 0.8 pwrite i num , 6 , k cutoff , 7 , k resonance endin instr example2 schedule \"ex2_control\" , 0 , 8 , 4 schedule \"ex2_broadcast\" , 4 , 4 schedule \"exit\" , 8.5 , - 1 turnoff endin ;; Uncomment as needed ; schedule \"example1\", 0, 1 schedule \"example2\" , 0 , 1 </ CsInstruments > < CsScore > </ CsScore > </ CsoundSynthesizer > See also pread pset p passign uniqinstance Credits Eduardo Moguillansky, 2019","title":"pwrite"},{"location":"opcodes/pwrite.html#pwrite","text":"","title":"pwrite"},{"location":"opcodes/pwrite.html#abstract","text":"Modify pfield values of an active instrument instance","title":"Abstract"},{"location":"opcodes/pwrite.html#description","text":"pwrite can be used to modify the value of a pfield of a running instance (possibly a fractional instrument number).","title":"Description"},{"location":"opcodes/pwrite.html#dynamic-pfields","text":"In order for pwrite to have any effect, the instrument in question should have an assignment of the sort kfreq = p5 .","title":"Dynamic pfields"},{"location":"opcodes/pwrite.html#behaviour","text":"A matching instance is searched at performance time, so that its behaviour can be controlled via if or timout statements. If no active instance is found, search is retried until a matching instance is found. To avoid retrying, set instrnum to a negative value. If the instance ceases to exist during another instrument is modifying its pfield values, nothing happens. pwrite notices that the instance is not active anymore and becomes a NOOP .","title":"Behaviour"},{"location":"opcodes/pwrite.html#exact-instance-vs-broadcasting","text":"If instrnum is a fractional instrument number, pwrite will only affect the first instance matching this exact number. If instrnum is set to an integer number, pwrite will broadcast the changes to ALL instruments with the same integer number. Warning Setting a value of a pfield out of range will result in a performance error.","title":"Exact instance vs Broadcasting"},{"location":"opcodes/pwrite.html#syntax","text":"pwrite i nstrnum : i , i ndex : i | k , value : i | k , [ i ndex2 , value2 , ... ]","title":"Syntax"},{"location":"opcodes/pwrite.html#arguments","text":"instrnum (init only): the (fractional) instrument number to modify index (i-, k-): the index of the pfield to modify. If kindex is 4, then p4 will be modified value (i-, k-): the new value of the given pfield Info Multiple index:value pairs can be modified simultaneously","title":"Arguments"},{"location":"opcodes/pwrite.html#execution-time","text":"Init (if index and value are i-values) Performance (if any index or value are k-variables)","title":"Execution Time"},{"location":"opcodes/pwrite.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr exit exitnow endin ;; Example 1. instr 2 creates and controls instr 1 instr 1 pset 0 , 0 , 0 , 40 , 50 k t timeinsts k 4 = p4 k 5 = p5 printf \"time: %.4f \\t instance: %.3f \\t p4: %f \\t p5: %f \\n \" , metro ( 20 ), k t , p1 , k 4 , k 5 endin instr 2 k val line 0 , p3 , 1 pwrite 1.01 , 4 , k val pwrite 1.02 , 5 , k val * 2 endin instr example1 schedule 1.01 , 0 , 4 , - 1 schedule 1.02 , 0 , 4 , - 1 schedule 2 , 1 , 1 schedule \"exit\" , 4 , - 1 turnoff endin ;----------------------------- ; Example 2, one instrument modulates another instr ex2_generator pset p1 , p2 , p3 , 0.5 , 1000 , 4000 , 0.1 k amp = p4 k freq = p5 k cutoff = p6 k resonance = p7 a saw vco2 , k amp , k freq a out moogladder2 , a saw , k cutoff , k resonance a out *= linsegr ( 0 , 0.1 , 1 , 0.1 , 0 ) outs a out , a out endin instr ex2_control i glissdur = p4 i num = nstrnum ( \"ex2_generator\" ) i num1 = i num + 0.001 i num2 = i num + 0.002 k freq1 linseg ntof ( \"4A\" ), i glissdur , ntof ( \"3A\" ) k freq2 linseg ntof ( \"4F\" ), i glissdur , ntof ( \"3F\" ) ; amp schedule i num1 , 0 , p3 , 0.2 schedule i num2 , 0 , p3 , 0.2 pwrite i num1 , 5 , k freq1 pwrite i num2 , 5 , k freq2 endin instr ex2_broadcast printf \"filter start \\n \" , 1 i num = nstrnum ( \"ex2_generator\" ) k cutoff linseg 4000 , p3 , 400 k resonance linseg 0.1 , p3 * 0.5 , 0.8 pwrite i num , 6 , k cutoff , 7 , k resonance endin instr example2 schedule \"ex2_control\" , 0 , 8 , 4 schedule \"ex2_broadcast\" , 4 , 4 schedule \"exit\" , 8.5 , - 1 turnoff endin ;; Uncomment as needed ; schedule \"example1\", 0, 1 schedule \"example2\" , 0 , 1 </ CsInstruments > < CsScore > </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pwrite.html#see-also","text":"pread pset p passign uniqinstance","title":"See also"},{"location":"opcodes/pwrite.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/ramptrig.html","text":"ramptrig Abstract A triggerable ramp between 0 and 1 Description ramptrig is a phasor between 0 and 1, with the difference that it stops after reaching its end point. Whenever it is triggered it rewinds to 0 and starts ramping to 1 in the given duration. A trigger detected whenever the value is possitive and higher than the previous value. Usage as envelope generator Together with bpf this can be used to emulate supercollider's Env and EnvGen , where ramptrig is used as a triggerable phasor, passed as an argument to bpf , which generates the envelope. See examples Syntax k out ramptrig k trig , k dur , k valuepost = 1 , k valuepre = 0 a out ramptrig k trig , k dir , k valuepost = 1 k out , k finished ramptrig k trig , k dur , k valuepost = 1 , k valuepre = 0 Arguments ktrig : whenever this is possitive and higher than last value, kout is rewinded to 0 kdur : the duration of the ramp ivaluepost : value when ramp reaches its end (default=1) ivaluepre : value previous to any trigger (default=0) Output kout : value of the ramp, between 0 and 1. It can also be ivaluepost or ivaluepre if these are set to any other value than the default kfinished : will be one whenever the ramp reaches its end value. Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > ; This is the example file of ramptrig ; ramptrig is a triggerable ramp from 0 to 1 ; xout ramptrig xtrig, kdur sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; Use Case #1: An envelope which can be retriggered instr 1 ; Duration of envelope k dur = 4 ; This is the gate, could be any irregular signal, midi, osc, etc. k trig metro 0.5 ; Whenever ktrig is possitive and higher than previous value, ; kx ramps from 0 to 1 in kdur seconds k x ramptrig k trig , k dur ; actual envelope k env bpf k x * k dur , 0 , 0 , 0.02 , 1 , k dur , 0 a sig oscili 0.2 , 1000 ; asig pinker a sig *= interp ( k env ) outs a sig , a sig endin ; Use Case #2: Use finished trigger to signal something instr 2 k trig metro 1 / 4 k trig delayk k trig , 0.5 i dur = 2 k phase , k finished1 ramptrig k trig , 2 printf \"finished! \\n \" , k finished1 k env bpf k phase * i dur , 0 , 0 , 0.5 , 1 , 0.8 , 0.5 , 1 , 1 , i dur , 0 a sig = pinker () * interp ( k env ) outs a sig , a sig endin </ CsInstruments > < CsScore > i 1 0 10 ; i2 0 12 ; i3 0 20 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also linenv trigphasor bpf Credits Eduardo Moguillansky, 2019","title":"ramptrig"},{"location":"opcodes/ramptrig.html#ramptrig","text":"","title":"ramptrig"},{"location":"opcodes/ramptrig.html#abstract","text":"A triggerable ramp between 0 and 1","title":"Abstract"},{"location":"opcodes/ramptrig.html#description","text":"ramptrig is a phasor between 0 and 1, with the difference that it stops after reaching its end point. Whenever it is triggered it rewinds to 0 and starts ramping to 1 in the given duration. A trigger detected whenever the value is possitive and higher than the previous value. Usage as envelope generator Together with bpf this can be used to emulate supercollider's Env and EnvGen , where ramptrig is used as a triggerable phasor, passed as an argument to bpf , which generates the envelope. See examples","title":"Description"},{"location":"opcodes/ramptrig.html#syntax","text":"k out ramptrig k trig , k dur , k valuepost = 1 , k valuepre = 0 a out ramptrig k trig , k dir , k valuepost = 1 k out , k finished ramptrig k trig , k dur , k valuepost = 1 , k valuepre = 0","title":"Syntax"},{"location":"opcodes/ramptrig.html#arguments","text":"ktrig : whenever this is possitive and higher than last value, kout is rewinded to 0 kdur : the duration of the ramp ivaluepost : value when ramp reaches its end (default=1) ivaluepre : value previous to any trigger (default=0)","title":"Arguments"},{"location":"opcodes/ramptrig.html#output","text":"kout : value of the ramp, between 0 and 1. It can also be ivaluepost or ivaluepre if these are set to any other value than the default kfinished : will be one whenever the ramp reaches its end value.","title":"Output"},{"location":"opcodes/ramptrig.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/ramptrig.html#examples","text":"< CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > ; This is the example file of ramptrig ; ramptrig is a triggerable ramp from 0 to 1 ; xout ramptrig xtrig, kdur sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; Use Case #1: An envelope which can be retriggered instr 1 ; Duration of envelope k dur = 4 ; This is the gate, could be any irregular signal, midi, osc, etc. k trig metro 0.5 ; Whenever ktrig is possitive and higher than previous value, ; kx ramps from 0 to 1 in kdur seconds k x ramptrig k trig , k dur ; actual envelope k env bpf k x * k dur , 0 , 0 , 0.02 , 1 , k dur , 0 a sig oscili 0.2 , 1000 ; asig pinker a sig *= interp ( k env ) outs a sig , a sig endin ; Use Case #2: Use finished trigger to signal something instr 2 k trig metro 1 / 4 k trig delayk k trig , 0.5 i dur = 2 k phase , k finished1 ramptrig k trig , 2 printf \"finished! \\n \" , k finished1 k env bpf k phase * i dur , 0 , 0 , 0.5 , 1 , 0.8 , 0.5 , 1 , 1 , i dur , 0 a sig = pinker () * interp ( k env ) outs a sig , a sig endin </ CsInstruments > < CsScore > i 1 0 10 ; i2 0 12 ; i3 0 20 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/ramptrig.html#see-also","text":"linenv trigphasor bpf","title":"See also"},{"location":"opcodes/ramptrig.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/ref.html","text":"ref Abstract Get a reference to a variable Description ref and deref implement a mechanism to pass a reference to an array, allowing to share it across instruments, opcodes, etc. Refs are reference counted and deallocate themselves when out of scope and not being used by any object. It makes it possible to pass arrays by reference to user defined opcodes, allowing to modify an array in place, skip copying memory, etc. i X [] fillarray 0 , 1 , 2 , 3 , 4 i ref ref i X i Y [] deref i ref In the case above, iY shares the same memory as iX and any modification in one array will be visible in the other. Syntax i ref ref xArray , [ i extrarefs = 0 ] Arguments xArray : the array to be referenced iextrarefs : use this for the niche case where a reference is passed to an event scheduled at a point in time later that the end of the current event. Without this, the ref would go out of scope before the deref takes place. Any extra ref must be matched with an extra deref ( kArr[] deref iref, 1 ) Output iref : an integer identifying the reference handle. Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > ;; Example file for ref - deref sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gi A [] fillarray 0 , 1000 , 2000 , 3000 ; Example 1: take a ref from an array, deref it to create a second view of it instr 1 ; a source array i X [] fillarray 0 , 10 , 20 , 30 , 40 ; create a ref of iXs, return the index i ref ref i X ; now iYs points to iXs i Y [] deref i ref printarray i Y , \"\" , \"instrument 1, iY\" i Z [] fillarray 0 , 1 , 3 , 5 , 7 ; create a ref, pass it to instr. 2 schedule 2 , 0 , 1 , ref ( i Z ) ; create another ref of iZ. In this case the event is scheduled ; in the future, so the source will not exist anymore when instr. 2 ; is scheduled. This should fail. schedule 2 , 1 , 1 , ref ( i Z ) turnoff endin instr 2 i ref = p4 if refvalid ( i ref ) == 1 then i Zs [] deref i ref printarray i Zs , \"\" , \"p1=2, iZs\" else prints \" \\n The reference has become invalid \\n \" endif turnoff endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; Example 2: extra references to keep array alive instr 3 ; create a source array k Xs [] fillarray 1 , 1 , 2 , 3 , 5 , 8 , 13 ; In order to bridge the time gap between the end of life of the source ; of a ref and the scheduled event where a deref is taken, it is possible ; to create a forward reference, a \"promise\" that one deref has been scheduled ; in the future. ; short lived event, ends before this event schedule 4 , 0 , 0.1 , ref ( k Xs ), 0 ; starts before we end, but survives us schedule 4 , p3 - 0.1 , 0.2 , ref ( k Xs ), 0 ; starts after we end, we need an extra reference schedule 4 , p3 + 1 , 0.1 , ref ( k Xs , 1 ), 1 defer \"prints\" , \" --- instr. 3 finished --- \\n \" endin instr 4 prints \"instr. 4 \\n \" k View [] deref p4 , p5 printarray k View defer \"prints\" , \" --- instr. 4 finished --- \\n \" ; At deinition time the memory of the `iView` array is marked as deallocated. ; The handle (a global structure created by the `ref` opcode) which owns the memory, ; is signaled that no other clients of this data are alive. It deallocates the ; original memory and frees itself endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; test: multiple derefs instr 5 i Xs [] fillarray 0 , 1 , 4 , 9 i ref ref i Xs i Ys [] deref i ref i Zs [] deref i ref printarray i Ys printarray i Zs i Xs [ 0 ] = 100 printarray i Zs turnoff endin ; test performance of pass-by-value vs pass-by-reference opcode arrayadd , i[] , i[]i ; pass by value in and out i In [], i x xin i Out [] = i In + i x xout i Out endop opcode arrayaddref , i[] , ii ; pass by ref in, by value out i ref , i x xin i In [] deref i ref i Out [] = i In + i x xout i Out endop opcode arrayadd_inplace , 0 , ii ; in place i ref , i x xin i In [] deref i ref i In += i x endop opcode arrayadd_byref_inout , 0 , iii ; pass by ref in and out i refin , i refout , i x xin i In [] deref i refin i Out [] deref i refout if lenarray ( i Out ) >= lenarray ( i In ) then i Out = i In + i x endif endop instr testUdoPerformance1 ; Here we test the performance gain of passing arrays by reference. ; Passing the input array by reference seems to produce a speedup of ~25%, i num = 10000 i Xs [] genarray 0 , i num i i = 0 i t0 rtclock while i i < 20 do i Ys [] arrayadd i Xs , 2.0 i i += 1 od i t1 rtclock prints \"Dur UDO pass by value = %.8f \\n \" , i t1 - i t0 i ref = ref ( i Xs ) i t0 rtclock i Y0 [] arrayaddref i ref , 0.1 i Y0 arrayaddref i ref , 0.2 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i t1 rtclock prints \"Dur UDO pass by ref input = %.8f \\n \" , i t1 - i t0 i Zs [] genarray 0 , i num i Out [] init lenarray ( i Zs ) i t0 rtclock i refZ = ref ( i Zs ) i refOut = ref ( i Out ) arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 i t1 rtclock prints \"Dur UDO pass by ref in and out= %.8f \\n \" , i t1 - i t0 ; printarray iOut endin instr 7 i In [] genarray 0 , 1000 i Out [] init lenarray ( i In ) arrayadd_byref_inout ref ( i In ), ref ( i Out ), 0.5 turnoff endin instr 8 ; test k arrays ; 1. A way to convert a i-array to a k-array by taking a reference i Xs [] genarray 0 , 99 k Xs [] deref ref ( i Xs ) k Xs [ 0 ] = timeinsts () printarray k Xs , metro ( 8 ) endin instr 9 ; we need genarray_i because otherwise kXs is not initialized at i-time k Xs [] genarray 0 , 9 i Xs [] deref ref ( k Xs ) i Xs += 10 printarray i Xs printarray k Xs turnoff endin ; schedule 1, 0, 1 ; schedule 3, 0, 1 ; schedule 5, 0, 0.1 schedule \"testUdoPerformance1\" , 0 , 0.1 ; schedule 8, 0, 4 </ CsInstruments > < CsScore > e 10 </ CsScore > </ CsoundSynthesizer > See also deref defer schedule event release Credits Eduardo Moguillansky, 2019","title":"ref"},{"location":"opcodes/ref.html#ref","text":"","title":"ref"},{"location":"opcodes/ref.html#abstract","text":"Get a reference to a variable","title":"Abstract"},{"location":"opcodes/ref.html#description","text":"ref and deref implement a mechanism to pass a reference to an array, allowing to share it across instruments, opcodes, etc. Refs are reference counted and deallocate themselves when out of scope and not being used by any object. It makes it possible to pass arrays by reference to user defined opcodes, allowing to modify an array in place, skip copying memory, etc. i X [] fillarray 0 , 1 , 2 , 3 , 4 i ref ref i X i Y [] deref i ref In the case above, iY shares the same memory as iX and any modification in one array will be visible in the other.","title":"Description"},{"location":"opcodes/ref.html#syntax","text":"i ref ref xArray , [ i extrarefs = 0 ]","title":"Syntax"},{"location":"opcodes/ref.html#arguments","text":"xArray : the array to be referenced iextrarefs : use this for the niche case where a reference is passed to an event scheduled at a point in time later that the end of the current event. Without this, the ref would go out of scope before the deref takes place. Any extra ref must be matched with an extra deref ( kArr[] deref iref, 1 )","title":"Arguments"},{"location":"opcodes/ref.html#output","text":"iref : an integer identifying the reference handle.","title":"Output"},{"location":"opcodes/ref.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/ref.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > ;; Example file for ref - deref sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gi A [] fillarray 0 , 1000 , 2000 , 3000 ; Example 1: take a ref from an array, deref it to create a second view of it instr 1 ; a source array i X [] fillarray 0 , 10 , 20 , 30 , 40 ; create a ref of iXs, return the index i ref ref i X ; now iYs points to iXs i Y [] deref i ref printarray i Y , \"\" , \"instrument 1, iY\" i Z [] fillarray 0 , 1 , 3 , 5 , 7 ; create a ref, pass it to instr. 2 schedule 2 , 0 , 1 , ref ( i Z ) ; create another ref of iZ. In this case the event is scheduled ; in the future, so the source will not exist anymore when instr. 2 ; is scheduled. This should fail. schedule 2 , 1 , 1 , ref ( i Z ) turnoff endin instr 2 i ref = p4 if refvalid ( i ref ) == 1 then i Zs [] deref i ref printarray i Zs , \"\" , \"p1=2, iZs\" else prints \" \\n The reference has become invalid \\n \" endif turnoff endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; Example 2: extra references to keep array alive instr 3 ; create a source array k Xs [] fillarray 1 , 1 , 2 , 3 , 5 , 8 , 13 ; In order to bridge the time gap between the end of life of the source ; of a ref and the scheduled event where a deref is taken, it is possible ; to create a forward reference, a \"promise\" that one deref has been scheduled ; in the future. ; short lived event, ends before this event schedule 4 , 0 , 0.1 , ref ( k Xs ), 0 ; starts before we end, but survives us schedule 4 , p3 - 0.1 , 0.2 , ref ( k Xs ), 0 ; starts after we end, we need an extra reference schedule 4 , p3 + 1 , 0.1 , ref ( k Xs , 1 ), 1 defer \"prints\" , \" --- instr. 3 finished --- \\n \" endin instr 4 prints \"instr. 4 \\n \" k View [] deref p4 , p5 printarray k View defer \"prints\" , \" --- instr. 4 finished --- \\n \" ; At deinition time the memory of the `iView` array is marked as deallocated. ; The handle (a global structure created by the `ref` opcode) which owns the memory, ; is signaled that no other clients of this data are alive. It deallocates the ; original memory and frees itself endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; test: multiple derefs instr 5 i Xs [] fillarray 0 , 1 , 4 , 9 i ref ref i Xs i Ys [] deref i ref i Zs [] deref i ref printarray i Ys printarray i Zs i Xs [ 0 ] = 100 printarray i Zs turnoff endin ; test performance of pass-by-value vs pass-by-reference opcode arrayadd , i[] , i[]i ; pass by value in and out i In [], i x xin i Out [] = i In + i x xout i Out endop opcode arrayaddref , i[] , ii ; pass by ref in, by value out i ref , i x xin i In [] deref i ref i Out [] = i In + i x xout i Out endop opcode arrayadd_inplace , 0 , ii ; in place i ref , i x xin i In [] deref i ref i In += i x endop opcode arrayadd_byref_inout , 0 , iii ; pass by ref in and out i refin , i refout , i x xin i In [] deref i refin i Out [] deref i refout if lenarray ( i Out ) >= lenarray ( i In ) then i Out = i In + i x endif endop instr testUdoPerformance1 ; Here we test the performance gain of passing arrays by reference. ; Passing the input array by reference seems to produce a speedup of ~25%, i num = 10000 i Xs [] genarray 0 , i num i i = 0 i t0 rtclock while i i < 20 do i Ys [] arrayadd i Xs , 2.0 i i += 1 od i t1 rtclock prints \"Dur UDO pass by value = %.8f \\n \" , i t1 - i t0 i ref = ref ( i Xs ) i t0 rtclock i Y0 [] arrayaddref i ref , 0.1 i Y0 arrayaddref i ref , 0.2 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i t1 rtclock prints \"Dur UDO pass by ref input = %.8f \\n \" , i t1 - i t0 i Zs [] genarray 0 , i num i Out [] init lenarray ( i Zs ) i t0 rtclock i refZ = ref ( i Zs ) i refOut = ref ( i Out ) arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 i t1 rtclock prints \"Dur UDO pass by ref in and out= %.8f \\n \" , i t1 - i t0 ; printarray iOut endin instr 7 i In [] genarray 0 , 1000 i Out [] init lenarray ( i In ) arrayadd_byref_inout ref ( i In ), ref ( i Out ), 0.5 turnoff endin instr 8 ; test k arrays ; 1. A way to convert a i-array to a k-array by taking a reference i Xs [] genarray 0 , 99 k Xs [] deref ref ( i Xs ) k Xs [ 0 ] = timeinsts () printarray k Xs , metro ( 8 ) endin instr 9 ; we need genarray_i because otherwise kXs is not initialized at i-time k Xs [] genarray 0 , 9 i Xs [] deref ref ( k Xs ) i Xs += 10 printarray i Xs printarray k Xs turnoff endin ; schedule 1, 0, 1 ; schedule 3, 0, 1 ; schedule 5, 0, 0.1 schedule \"testUdoPerformance1\" , 0 , 0.1 ; schedule 8, 0, 4 </ CsInstruments > < CsScore > e 10 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/ref.html#see-also","text":"deref defer schedule event release","title":"See also"},{"location":"opcodes/ref.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/refvalid.html","text":"refvalid Abstract Queries if a reference is valid Description ref and deref implement a mechanism to pass a reference to any object, allowing to share a variable across instruments, with opcodes, etc. A reference is a proxy to an axisting variable / array. A reference is reference counted and deallocates itself when it falls out of scope without being referenced by any object. Since a reference is just an integer, refvalid can be used to check if the given reference index corresponds to a valid reference Syntax i out refvalid i ref k out refvalid k ref Arguments iref / kout : an integer identifying the reference handle, as passed via ref Output \u00ecout / kout : 1 if the reference is valid, 0 otherwise Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > - m0 - d </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 k freq linseg 0 , p3 , 1 schedule 2 , 0 , p3 , ref ( k freq ) endin instr 2 if refvalid ( p4 ) == 1 then k freq = deref ( p4 ) else k freq = 1000 endif a sig vco2 0.2 , k freq schedule 3 , 0 , p3 , ref ( a sig ) endin instr 3 if refvalid ( p4 ) == 1 then a in deref p4 else a in = 0 endif a out lpf18 a in , 2000 , 0.9 , 0.2 outs a out , a out endin See also deref ref defer schedule event release Credits Eduardo Moguillansky, 2019","title":"refvalid"},{"location":"opcodes/refvalid.html#refvalid","text":"","title":"refvalid"},{"location":"opcodes/refvalid.html#abstract","text":"Queries if a reference is valid","title":"Abstract"},{"location":"opcodes/refvalid.html#description","text":"ref and deref implement a mechanism to pass a reference to any object, allowing to share a variable across instruments, with opcodes, etc. A reference is a proxy to an axisting variable / array. A reference is reference counted and deallocates itself when it falls out of scope without being referenced by any object. Since a reference is just an integer, refvalid can be used to check if the given reference index corresponds to a valid reference","title":"Description"},{"location":"opcodes/refvalid.html#syntax","text":"i out refvalid i ref k out refvalid k ref","title":"Syntax"},{"location":"opcodes/refvalid.html#arguments","text":"iref / kout : an integer identifying the reference handle, as passed via ref","title":"Arguments"},{"location":"opcodes/refvalid.html#output","text":"\u00ecout / kout : 1 if the reference is valid, 0 otherwise","title":"Output"},{"location":"opcodes/refvalid.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/refvalid.html#examples","text":"< CsoundSynthesizer > < CsOptions > - m0 - d </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 k freq linseg 0 , p3 , 1 schedule 2 , 0 , p3 , ref ( k freq ) endin instr 2 if refvalid ( p4 ) == 1 then k freq = deref ( p4 ) else k freq = 1000 endif a sig vco2 0.2 , k freq schedule 3 , 0 , p3 , ref ( a sig ) endin instr 3 if refvalid ( p4 ) == 1 then a in deref p4 else a in = 0 endif a out lpf18 a in , 2000 , 0.9 , 0.2 outs a out , a out endin","title":"Examples"},{"location":"opcodes/refvalid.html#see-also","text":"deref ref defer schedule event release","title":"See also"},{"location":"opcodes/refvalid.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/schmitt.html","text":"schmitt Abstract A schmitt trigger (a comparator with hysteresis). Description Implements a schmitt trigger, which is a comparator with hysteresis. Whenever the input is higher than khigh , output is 1 and stays 1 until input drops beneath klow . Output is 1 if the input is higher than khigh if signal is increasing Output is 0 if the input is lower than klow if signal is decreasing Note schmitt is particularly useful for implementing effects like a noise gate, to avoid fast opening and closing at the threshold. It can be further refined together with lagud to add attack / release times to the opening of the gate or with trighold to assure a minimum open time for the gate Port of pd/else's schmitt Syntax xout schmitt xin , k high , k low Arguments xin : input signal (k- or audio rate). The rate of xin must match the rate of xout khigh : high value of the comparator, output is 1 whenever input is higher than this klow : low value of the comparator, output is 0 whenever input is lower than this Output xout : output value of the comparator (0 or 1). Rate of xout is the same as xin Execution Time Performance (k or audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 /* Example file for schmitt opcode aout schmitt ain, khigh, klow kout schmitt kin, khigh, klow schmitt is a schmitt trigger (a gate with hysteresis), out is 1 if higher than khigh, 0 if lower than klow */ FLpanel \"schmitt\" , 400 , 300 , 50 , 50 i disp1 FLvalue \"\" , 40 , 30 , 322 , 20 i disp2 FLvalue \"\" , 40 , 30 , 322 , 80 i disp3 FLvalue \"\" , 40 , 30 , 322 , 140 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk signal , gi h1 FLslider \"signal\" , - 1 , 1 , 0 , 1 , i disp1 , 300 , 30 , 20 , 20 gk low , gi h2 FLslider \"low\" , - 1 , 1 , 0 , 3 , i disp2 , 300 , 30 , 20 , 80 gk high , gi h3 FLslider \"high\" , - 1 , 1 , 0 , 3 , i disp3 , 300 , 30 , 20 , 140 k schmitt , gi h4 FLbutton \"out\" , 1 , 0 , 3 , 50 , 50 , 20 , 200 , - 1 FLpanelEnd FLrun FLsetVal_i - 0.5 , gi h2 FLsetVal_i 0.5 , gi h3 instr 1 a in oscili 1 , 0.25 a out schmitt a in , gk high , gk low k guitrig metro 24 FLsetVal k guitrig , k ( a in ), gi h1 FLsetVal k guitrig , k ( a out ), gi h4 endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer > See also lagud trighold Credits Eduardo Moguillansky, 2019","title":"schmitt"},{"location":"opcodes/schmitt.html#schmitt","text":"","title":"schmitt"},{"location":"opcodes/schmitt.html#abstract","text":"A schmitt trigger (a comparator with hysteresis).","title":"Abstract"},{"location":"opcodes/schmitt.html#description","text":"Implements a schmitt trigger, which is a comparator with hysteresis. Whenever the input is higher than khigh , output is 1 and stays 1 until input drops beneath klow . Output is 1 if the input is higher than khigh if signal is increasing Output is 0 if the input is lower than klow if signal is decreasing Note schmitt is particularly useful for implementing effects like a noise gate, to avoid fast opening and closing at the threshold. It can be further refined together with lagud to add attack / release times to the opening of the gate or with trighold to assure a minimum open time for the gate Port of pd/else's schmitt","title":"Description"},{"location":"opcodes/schmitt.html#syntax","text":"xout schmitt xin , k high , k low","title":"Syntax"},{"location":"opcodes/schmitt.html#arguments","text":"xin : input signal (k- or audio rate). The rate of xin must match the rate of xout khigh : high value of the comparator, output is 1 whenever input is higher than this klow : low value of the comparator, output is 0 whenever input is lower than this","title":"Arguments"},{"location":"opcodes/schmitt.html#output","text":"xout : output value of the comparator (0 or 1). Rate of xout is the same as xin","title":"Output"},{"location":"opcodes/schmitt.html#execution-time","text":"Performance (k or audio)","title":"Execution Time"},{"location":"opcodes/schmitt.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 /* Example file for schmitt opcode aout schmitt ain, khigh, klow kout schmitt kin, khigh, klow schmitt is a schmitt trigger (a gate with hysteresis), out is 1 if higher than khigh, 0 if lower than klow */ FLpanel \"schmitt\" , 400 , 300 , 50 , 50 i disp1 FLvalue \"\" , 40 , 30 , 322 , 20 i disp2 FLvalue \"\" , 40 , 30 , 322 , 80 i disp3 FLvalue \"\" , 40 , 30 , 322 , 140 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk signal , gi h1 FLslider \"signal\" , - 1 , 1 , 0 , 1 , i disp1 , 300 , 30 , 20 , 20 gk low , gi h2 FLslider \"low\" , - 1 , 1 , 0 , 3 , i disp2 , 300 , 30 , 20 , 80 gk high , gi h3 FLslider \"high\" , - 1 , 1 , 0 , 3 , i disp3 , 300 , 30 , 20 , 140 k schmitt , gi h4 FLbutton \"out\" , 1 , 0 , 3 , 50 , 50 , 20 , 200 , - 1 FLpanelEnd FLrun FLsetVal_i - 0.5 , gi h2 FLsetVal_i 0.5 , gi h3 instr 1 a in oscili 1 , 0.25 a out schmitt a in , gk high , gk low k guitrig metro 24 FLsetVal k guitrig , k ( a in ), gi h1 FLsetVal k guitrig , k ( a out ), gi h4 endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/schmitt.html#see-also","text":"lagud trighold","title":"See also"},{"location":"opcodes/schmitt.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/scriptDir.html","text":"scriptDir Abstract Get the directory of the loaded orc/csd file Description Get the directory of the loaded script (orc/csd). This is not necessarily the same as the current working directory (which can be queried via the opcode pwd ). The pwd points at the directory from which csound was launched, the script directory is always the directory of the script being run. For example, if csound is launched as: $ /home/foo/> csound subdir/myscript.csd The current working dir is /home/foo , whereas the script directory is /home/foo/subdir This is useful when communicating to another process which is not aware of csound's environment and needs an absolute path to some file relative to the script being run Syntax Spath scriptDir Arguments Output Spath : the path of the loaded script Execution Time Init Examples S path scriptDir prints \"The script is being run from this folder: %s \\n \" , S path See also pathAbsolute findFileInPath pwd Credits Eduardo Moguillansky, 2020","title":"scriptDir"},{"location":"opcodes/scriptDir.html#scriptdir","text":"","title":"scriptDir"},{"location":"opcodes/scriptDir.html#abstract","text":"Get the directory of the loaded orc/csd file","title":"Abstract"},{"location":"opcodes/scriptDir.html#description","text":"Get the directory of the loaded script (orc/csd). This is not necessarily the same as the current working directory (which can be queried via the opcode pwd ). The pwd points at the directory from which csound was launched, the script directory is always the directory of the script being run. For example, if csound is launched as: $ /home/foo/> csound subdir/myscript.csd The current working dir is /home/foo , whereas the script directory is /home/foo/subdir This is useful when communicating to another process which is not aware of csound's environment and needs an absolute path to some file relative to the script being run","title":"Description"},{"location":"opcodes/scriptDir.html#syntax","text":"Spath scriptDir","title":"Syntax"},{"location":"opcodes/scriptDir.html#arguments","text":"","title":"Arguments"},{"location":"opcodes/scriptDir.html#output","text":"Spath : the path of the loaded script","title":"Output"},{"location":"opcodes/scriptDir.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/scriptDir.html#examples","text":"S path scriptDir prints \"The script is being run from this folder: %s \\n \" , S path","title":"Examples"},{"location":"opcodes/scriptDir.html#see-also","text":"pathAbsolute findFileInPath pwd","title":"See also"},{"location":"opcodes/scriptDir.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/sderef.html","text":"sderef Abstract Retrieves a read-only string from the cache Description sref / sderef implement a global string cache. This can be useful in situations where a string needs to be stored/passed but only numbers are allowed (for example, when using the event opcode, or to be able to mix numbers and strings inside an array). It behaves similar to the strset / strget opcodes but automatically assigns an index to each distinct string inside the cache. The string returned by sderef should not be modified. This is not enforced. Syntax Sstr sderef idx Sstr sderef kdx Arguments idx / kdx : the numeric id representing the string Sstr : the string inside the cache, corresponding to idx Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for sref / sderef */ ; Use sref to pass multiple strings between instruments instr 1 event_i \"i\" , 2 , 0 , - 1 , sref ( \"foo\" ), sref ( \"bar\" ) turnoff endin instr 2 ;; get a read-only string from the cache S 1 sderef p4 S 2 sderef p5 prints \"S1= %s S2= %s \\n \" , S 1 , S 2 turnoff endin ;; Use sref to store strings inside a numeric array instr 3 i Struct [] fillarray sref ( \"Bach\" ), 1675 , 1750 prints \"Name = %s \\n \" , sderef ( i Struct [ 0 ]) endin ;; If the string does not need to be modified, sderef ;; can be used instead of sref to retrieve a string ;; from the cache. In this case, the string is not allocated, ;; it only points to the version inside the cache. instr 4 S 1 = \"foo bar\" i S1 = sref ( S 1 ) ;; S2 is a read-only view of the cached S1. S 2 = sderef ( i S1 ) prints \"S2 = %s \\n \" , S 2 turnoff endin instr test_same_idx i dx1 = sref ( \"foo\" ) i dx2 = sref ( \"foo\" ) prints \"These indices should be the same: idx1= %d , idx2= %d \\n \" , i dx1 , i dx2 turnoff endin instr test_sderef S 1 = \"uniquestring\" i dx1 = sref ( S 1 ) S view = sderef ( i dx1 ) prints \"Sview = ' %s ' (should be ' %s ') \\n \" , S view , S 1 turnoff endin </ CsInstruments > < CsScore > ; i 1 0 0.1 ; i 3 + 0.1 ; i 4 + 0.1 i \"test_same_idx\" 0 1 ; i \"test_sderef\" 0 1 </ CsScore > </ CsoundSynthesizer > Credits Eduardo Moguillansky, 2020","title":"sderef"},{"location":"opcodes/sderef.html#sderef","text":"","title":"sderef"},{"location":"opcodes/sderef.html#abstract","text":"Retrieves a read-only string from the cache","title":"Abstract"},{"location":"opcodes/sderef.html#description","text":"sref / sderef implement a global string cache. This can be useful in situations where a string needs to be stored/passed but only numbers are allowed (for example, when using the event opcode, or to be able to mix numbers and strings inside an array). It behaves similar to the strset / strget opcodes but automatically assigns an index to each distinct string inside the cache. The string returned by sderef should not be modified. This is not enforced.","title":"Description"},{"location":"opcodes/sderef.html#syntax","text":"Sstr sderef idx Sstr sderef kdx","title":"Syntax"},{"location":"opcodes/sderef.html#arguments","text":"idx / kdx : the numeric id representing the string Sstr : the string inside the cache, corresponding to idx","title":"Arguments"},{"location":"opcodes/sderef.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/sderef.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for sref / sderef */ ; Use sref to pass multiple strings between instruments instr 1 event_i \"i\" , 2 , 0 , - 1 , sref ( \"foo\" ), sref ( \"bar\" ) turnoff endin instr 2 ;; get a read-only string from the cache S 1 sderef p4 S 2 sderef p5 prints \"S1= %s S2= %s \\n \" , S 1 , S 2 turnoff endin ;; Use sref to store strings inside a numeric array instr 3 i Struct [] fillarray sref ( \"Bach\" ), 1675 , 1750 prints \"Name = %s \\n \" , sderef ( i Struct [ 0 ]) endin ;; If the string does not need to be modified, sderef ;; can be used instead of sref to retrieve a string ;; from the cache. In this case, the string is not allocated, ;; it only points to the version inside the cache. instr 4 S 1 = \"foo bar\" i S1 = sref ( S 1 ) ;; S2 is a read-only view of the cached S1. S 2 = sderef ( i S1 ) prints \"S2 = %s \\n \" , S 2 turnoff endin instr test_same_idx i dx1 = sref ( \"foo\" ) i dx2 = sref ( \"foo\" ) prints \"These indices should be the same: idx1= %d , idx2= %d \\n \" , i dx1 , i dx2 turnoff endin instr test_sderef S 1 = \"uniquestring\" i dx1 = sref ( S 1 ) S view = sderef ( i dx1 ) prints \"Sview = ' %s ' (should be ' %s ') \\n \" , S view , S 1 turnoff endin </ CsInstruments > < CsScore > ; i 1 0 0.1 ; i 3 + 0.1 ; i 4 + 0.1 i \"test_same_idx\" 0 1 ; i \"test_sderef\" 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/sderef.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/setslice.html","text":"setslice Abstract Set a slice of an array to a given value Description setslice sets the elements of an array or a slice of it to a given value. This operation is done in place. It is the equivalent of this code: array [ start : end : step ] = value Syntax setslice i Array [], i value [, i start = 0 , i end = 0 , i step = 1 ] setslice k Array [], k value [, k start = 0 , k end = 0 , k step = 1 ] setslice i Array [], i Source [], i start = 0 setslice k Array [], k Source [], k start = 0 setslice S Array [], S Source [], k start = 0 Arguments value : the value to set the elements to start : the start index of the slice. Defaults to 0 end : the end index of the slice. Defaults to 0 which means until the end of the slice step : the number of steps to jump between elements. Default to 1 (all elements in the slice) xSource[] : the array used as source. In this case, all elements of the source array are copied to the destination array (xArray) starting at the given offset Output Execution Time Init (if all arguments are of i type) Performance (if any argument is of k type) Examples i A [] fillarray 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 setslice i A , 0.5 ; will set all elements of iA to 0.5 printarray i A k B [] init 10 ; if the condition is met setslice will set the even indexes ; between 0 to 6 of kB to -1 if k value = 1 then setslice k B , - 1 , 0 , 6 , 2 endif if changed2 ( k B ) == 1 then printarray k B endif ; kB: -1, 0, -1, 0, -1, 0, 0, 0, 0, 0 See also ftset ftslice slicearray Credits Eduardo Moguillansky, 2020","title":"setslice"},{"location":"opcodes/setslice.html#setslice","text":"","title":"setslice"},{"location":"opcodes/setslice.html#abstract","text":"Set a slice of an array to a given value","title":"Abstract"},{"location":"opcodes/setslice.html#description","text":"setslice sets the elements of an array or a slice of it to a given value. This operation is done in place. It is the equivalent of this code: array [ start : end : step ] = value","title":"Description"},{"location":"opcodes/setslice.html#syntax","text":"setslice i Array [], i value [, i start = 0 , i end = 0 , i step = 1 ] setslice k Array [], k value [, k start = 0 , k end = 0 , k step = 1 ] setslice i Array [], i Source [], i start = 0 setslice k Array [], k Source [], k start = 0 setslice S Array [], S Source [], k start = 0","title":"Syntax"},{"location":"opcodes/setslice.html#arguments","text":"value : the value to set the elements to start : the start index of the slice. Defaults to 0 end : the end index of the slice. Defaults to 0 which means until the end of the slice step : the number of steps to jump between elements. Default to 1 (all elements in the slice) xSource[] : the array used as source. In this case, all elements of the source array are copied to the destination array (xArray) starting at the given offset","title":"Arguments"},{"location":"opcodes/setslice.html#output","text":"","title":"Output"},{"location":"opcodes/setslice.html#execution-time","text":"Init (if all arguments are of i type) Performance (if any argument is of k type)","title":"Execution Time"},{"location":"opcodes/setslice.html#examples","text":"i A [] fillarray 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 setslice i A , 0.5 ; will set all elements of iA to 0.5 printarray i A k B [] init 10 ; if the condition is met setslice will set the even indexes ; between 0 to 6 of kB to -1 if k value = 1 then setslice k B , - 1 , 0 , 6 , 2 endif if changed2 ( k B ) == 1 then printarray k B endif ; kB: -1, 0, -1, 0, -1, 0, 0, 0, 0, 0","title":"Examples"},{"location":"opcodes/setslice.html#see-also","text":"ftset ftslice slicearray","title":"See also"},{"location":"opcodes/setslice.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/sfreadmeta.html","text":"sfreadmeta Abstract Read metadata from a soundfile Description Reads metadata from a soundfile via libsndfile. Only a subset of keys, standardized across different fileformats is supported: title comment artist album tracknumber software The opcode has two forms: 1) a specific key is queried, in which case the opcode returns the string for that key, or an empty string if that key is not present; 2) no key is given and all the metadata is returned in two string arrays, one with all the keys and second with their corresponding values. Syntax Svalue sfreadmeta Ssndfile, Skey Skeys[], Svalues[] sfreadmeta Ssndfile Arguments Ssndfile : the path to a soundfile Skey : a metadata key to query Output Svalue : the string value for the given metadata key. It will be empty if the key is not present Skeys : the keys present in the metadata Svalues : the string values corresponding to each key in Skeys Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Svalue sfeadmeta Ssndfile, Skey Read metadata from sndfile. Skey can be one of \"comment\", \"title\", \"artist\", \"album\", \"tracknumber\". If the given key is not present an empty value is returned. */ instr 1 S comment sfreadmeta \"sfwithmeta.flac\" , \"comment\" prints \"Comment: %s \\n \" , S comment S title sfreadmeta \"sfwithmeta.flac\" , \"artist\" prints \"Artist: %s \\n \" , S title turnoff endin instr 2 S keys [], S values [] sfreadmeta \"sfwithmeta.flac\" i 0 = 0 while i 0 < lenarray ( S keys ) do prints \" %s = %s \\n \" , S keys [ i 0 ], S values [ i 0 ] i 0 += 1 od endin </ CsInstruments > < CsScore > i 1 0 0.1 i 2 0 0.1 </ CsScore > </ CsoundSynthesizer > See also filesr filenchnls filenlen pathAbsolute findFileInPath Credits Eduardo Moguillansky, 2021","title":"sfreadmeta"},{"location":"opcodes/sfreadmeta.html#sfreadmeta","text":"","title":"sfreadmeta"},{"location":"opcodes/sfreadmeta.html#abstract","text":"Read metadata from a soundfile","title":"Abstract"},{"location":"opcodes/sfreadmeta.html#description","text":"Reads metadata from a soundfile via libsndfile. Only a subset of keys, standardized across different fileformats is supported: title comment artist album tracknumber software The opcode has two forms: 1) a specific key is queried, in which case the opcode returns the string for that key, or an empty string if that key is not present; 2) no key is given and all the metadata is returned in two string arrays, one with all the keys and second with their corresponding values.","title":"Description"},{"location":"opcodes/sfreadmeta.html#syntax","text":"Svalue sfreadmeta Ssndfile, Skey Skeys[], Svalues[] sfreadmeta Ssndfile","title":"Syntax"},{"location":"opcodes/sfreadmeta.html#arguments","text":"Ssndfile : the path to a soundfile Skey : a metadata key to query","title":"Arguments"},{"location":"opcodes/sfreadmeta.html#output","text":"Svalue : the string value for the given metadata key. It will be empty if the key is not present Skeys : the keys present in the metadata Svalues : the string values corresponding to each key in Skeys","title":"Output"},{"location":"opcodes/sfreadmeta.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/sfreadmeta.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Svalue sfeadmeta Ssndfile, Skey Read metadata from sndfile. Skey can be one of \"comment\", \"title\", \"artist\", \"album\", \"tracknumber\". If the given key is not present an empty value is returned. */ instr 1 S comment sfreadmeta \"sfwithmeta.flac\" , \"comment\" prints \"Comment: %s \\n \" , S comment S title sfreadmeta \"sfwithmeta.flac\" , \"artist\" prints \"Artist: %s \\n \" , S title turnoff endin instr 2 S keys [], S values [] sfreadmeta \"sfwithmeta.flac\" i 0 = 0 while i 0 < lenarray ( S keys ) do prints \" %s = %s \\n \" , S keys [ i 0 ], S values [ i 0 ] i 0 += 1 od endin </ CsInstruments > < CsScore > i 1 0 0.1 i 2 0 0.1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/sfreadmeta.html#see-also","text":"filesr filenchnls filenlen pathAbsolute findFileInPath","title":"See also"},{"location":"opcodes/sfreadmeta.html#credits","text":"Eduardo Moguillansky, 2021","title":"Credits"},{"location":"opcodes/sigmdrive.html","text":"sigmdrive Abstract Analog \"soft clipping\" distortion by applying non-linear transfer functions. Description sigmdrive simulates analog \"soft clipping\" by applying non-linear transfer functions. Two different sigmoid equations are implemented. mode 0 out = tanh ( in * drivefactor ) mode 1 if in > 0 -> out = 1.0 - pow(1. - in, drivefactor) if in <= 0 -> out = pow(1. + x, drivefactor) - 1.0 Syntax a out sigmdrive a in , xdrivefactor , k mode = 0 Arguments ain : the input audio signal xdrivefactor : a k- or a- value, normally greater than 1. A higher value implies more distortion kmode : the distortion mode. 0=tanh, 1=pow (see above) Output aout : the distorted audio Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* sigmdrive: a sigmoid distortion aout sigmdrive ain, kdrive, kmode=0 kdrive: how much distortion (range 0-1) kmode: 0 = tanh, 1 = pow */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 FLpanel \"sigmdrive\" , 400 , 200 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 322 , 20 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk drive , i drivehandle1 FLslider \"drive\" , 0 , 10 , 0 , 3 , i disp1 , 300 , 30 , 20 , 20 gk mode , i drivehandle2 FLbutton \"mode\" , 1 , 0 , 3 , 60 , 50 , 20 , 80 , - 1 FLpanelEnd FLrun instr 1 a in oscili 0.2 , 440 a out sigmdrive a in , port : k ( gk drive , 0.2 ), gk mode outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer > See also tubeharmonics distort1 tanh powershape Credits Eduardo Moguillansky, 2019 (based on pd/else's drive~ - https://github.com/porres/pd-else)","title":"sigmdrive"},{"location":"opcodes/sigmdrive.html#sigmdrive","text":"","title":"sigmdrive"},{"location":"opcodes/sigmdrive.html#abstract","text":"Analog \"soft clipping\" distortion by applying non-linear transfer functions.","title":"Abstract"},{"location":"opcodes/sigmdrive.html#description","text":"sigmdrive simulates analog \"soft clipping\" by applying non-linear transfer functions. Two different sigmoid equations are implemented.","title":"Description"},{"location":"opcodes/sigmdrive.html#mode-0","text":"out = tanh ( in * drivefactor )","title":"mode 0"},{"location":"opcodes/sigmdrive.html#mode-1","text":"if in > 0 -> out = 1.0 - pow(1. - in, drivefactor) if in <= 0 -> out = pow(1. + x, drivefactor) - 1.0","title":"mode 1"},{"location":"opcodes/sigmdrive.html#syntax","text":"a out sigmdrive a in , xdrivefactor , k mode = 0","title":"Syntax"},{"location":"opcodes/sigmdrive.html#arguments","text":"ain : the input audio signal xdrivefactor : a k- or a- value, normally greater than 1. A higher value implies more distortion kmode : the distortion mode. 0=tanh, 1=pow (see above)","title":"Arguments"},{"location":"opcodes/sigmdrive.html#output","text":"aout : the distorted audio","title":"Output"},{"location":"opcodes/sigmdrive.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/sigmdrive.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* sigmdrive: a sigmoid distortion aout sigmdrive ain, kdrive, kmode=0 kdrive: how much distortion (range 0-1) kmode: 0 = tanh, 1 = pow */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 FLpanel \"sigmdrive\" , 400 , 200 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 322 , 20 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk drive , i drivehandle1 FLslider \"drive\" , 0 , 10 , 0 , 3 , i disp1 , 300 , 30 , 20 , 20 gk mode , i drivehandle2 FLbutton \"mode\" , 1 , 0 , 3 , 60 , 50 , 20 , 80 , - 1 FLpanelEnd FLrun instr 1 a in oscili 0.2 , 440 a out sigmdrive a in , port : k ( gk drive , 0.2 ), gk mode outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/sigmdrive.html#see-also","text":"tubeharmonics distort1 tanh powershape","title":"See also"},{"location":"opcodes/sigmdrive.html#credits","text":"Eduardo Moguillansky, 2019 (based on pd/else's drive~ - https://github.com/porres/pd-else)","title":"Credits"},{"location":"opcodes/sref.html","text":"sref Abstract Insert a string into a global registry and return a reference to it Description sref implements a global string cache. This can be useful in any situation where a string needs to be stored/passed but only numbers are allowed (for example, when using the event opcode, or to be able to mix numbers and strings inside an array). It behaves similar to the strset / strget opcodes but automatically assigns an index to each distinct string inside the cache. To retrieve an internalized string, use sderef . The returned string should not be modified since it is a \"view\" of the original string. Note It is guaranteed that passing twice the same string will return the same index. Syntax i dx sref S str k dx sref S str Arguments idx / kdx : the numeric id representing the string Sstr : the string inside the cache, corresponding to idx Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for sref / sderef */ ; Use sref to pass multiple strings between instruments instr 1 event_i \"i\" , 2 , 0 , - 1 , sref ( \"foo\" ), sref ( \"bar\" ) turnoff endin instr 2 ;; get a read-only string from the cache S 1 sderef p4 S 2 sderef p5 prints \"S1= %s S2= %s \\n \" , S 1 , S 2 turnoff endin ;; Use sref to store strings inside a numeric array instr 3 i Struct [] fillarray sref ( \"Bach\" ), 1675 , 1750 prints \"Name = %s \\n \" , sderef ( i Struct [ 0 ]) endin ;; If the string does not need to be modified, sderef ;; can be used instead of sref to retrieve a string ;; from the cache. In this case, the string is not allocated, ;; it only points to the version inside the cache. instr 4 S 1 = \"foo bar\" i S1 = sref ( S 1 ) ;; S2 is a read-only view of the cached S1. S 2 = sderef ( i S1 ) prints \"S2 = %s \\n \" , S 2 turnoff endin instr test_same_idx i dx1 = sref ( \"foo\" ) i dx2 = sref ( \"foo\" ) prints \"These indices should be the same: idx1= %d , idx2= %d \\n \" , i dx1 , i dx2 turnoff endin instr test_sderef S 1 = \"uniquestring\" i dx1 = sref ( S 1 ) S view = sderef ( i dx1 ) prints \"Sview = ' %s ' (should be ' %s ') \\n \" , S view , S 1 turnoff endin </ CsInstruments > < CsScore > ; i 1 0 0.1 ; i 3 + 0.1 ; i 4 + 0.1 i \"test_same_idx\" 0 1 ; i \"test_sderef\" 0 1 </ CsScore > </ CsoundSynthesizer > Credits Eduardo Moguillansky, 2019","title":"sref"},{"location":"opcodes/sref.html#sref","text":"","title":"sref"},{"location":"opcodes/sref.html#abstract","text":"Insert a string into a global registry and return a reference to it","title":"Abstract"},{"location":"opcodes/sref.html#description","text":"sref implements a global string cache. This can be useful in any situation where a string needs to be stored/passed but only numbers are allowed (for example, when using the event opcode, or to be able to mix numbers and strings inside an array). It behaves similar to the strset / strget opcodes but automatically assigns an index to each distinct string inside the cache. To retrieve an internalized string, use sderef . The returned string should not be modified since it is a \"view\" of the original string. Note It is guaranteed that passing twice the same string will return the same index.","title":"Description"},{"location":"opcodes/sref.html#syntax","text":"i dx sref S str k dx sref S str","title":"Syntax"},{"location":"opcodes/sref.html#arguments","text":"idx / kdx : the numeric id representing the string Sstr : the string inside the cache, corresponding to idx","title":"Arguments"},{"location":"opcodes/sref.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/sref.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for sref / sderef */ ; Use sref to pass multiple strings between instruments instr 1 event_i \"i\" , 2 , 0 , - 1 , sref ( \"foo\" ), sref ( \"bar\" ) turnoff endin instr 2 ;; get a read-only string from the cache S 1 sderef p4 S 2 sderef p5 prints \"S1= %s S2= %s \\n \" , S 1 , S 2 turnoff endin ;; Use sref to store strings inside a numeric array instr 3 i Struct [] fillarray sref ( \"Bach\" ), 1675 , 1750 prints \"Name = %s \\n \" , sderef ( i Struct [ 0 ]) endin ;; If the string does not need to be modified, sderef ;; can be used instead of sref to retrieve a string ;; from the cache. In this case, the string is not allocated, ;; it only points to the version inside the cache. instr 4 S 1 = \"foo bar\" i S1 = sref ( S 1 ) ;; S2 is a read-only view of the cached S1. S 2 = sderef ( i S1 ) prints \"S2 = %s \\n \" , S 2 turnoff endin instr test_same_idx i dx1 = sref ( \"foo\" ) i dx2 = sref ( \"foo\" ) prints \"These indices should be the same: idx1= %d , idx2= %d \\n \" , i dx1 , i dx2 turnoff endin instr test_sderef S 1 = \"uniquestring\" i dx1 = sref ( S 1 ) S view = sderef ( i dx1 ) prints \"Sview = ' %s ' (should be ' %s ') \\n \" , S view , S 1 turnoff endin </ CsInstruments > < CsScore > ; i 1 0 0.1 ; i 3 + 0.1 ; i 4 + 0.1 i \"test_same_idx\" 0 1 ; i \"test_sderef\" 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/sref.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/standardchaos.html","text":"standardchaos Abstract Standard map chaotic generator Description standardchaos is a chaotic generator, the sound is generated with the following difference equations; y[n] = (y[n-1] + k * sin(x[n-1])) % 2pi; x[n] = (x[n-1] + y[n]) % 2pi; out = (x[n] - pi) / pi Syntax a out standardchaos k rate , k k = 1 , i x = 0.5 , i y = 0 Arguments krate : from 0 to nyquist kk : a value for k in the above equation ix : initial value for x iy : initial value for y Output aout : audio output of the chaotic generator Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 /* Example file for standardchaos opcode aout standardchaos krate, kk, ix=0.5, iy=0 Standard map chaotic generator, the sound is generated with the difference equations; y[n] = (y[n-1] + k * sin(x[n-1])) % 2pi; x[n] = (x[n-1] + y[n]) % 2pi; out = (x[n] - pi) / pi; */ FLpanel \"standardchaos\" , 600 , 300 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 522 , 20 i disp2 FLvalue \"\" , 50 , 30 , 522 , 80 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk rate , gi h1 FLslider \"rate\" , 0 , 20000 , 0 , 3 , i disp1 , 500 , 30 , 20 , 20 gk k , gi h2 FLslider \"k\" , 0 , 10 , 0 , 3 , i disp2 , 500 , 30 , 20 , 80 FLpanelEnd FLrun FLsetVal_i 1618 , gi h1 FLsetVal_i 1 , gi h2 instr 1 i x = 0.5 i y = 1 i gain = 0.3 a out standardchaos gk rate , gk k , i x , i y a out *= i gain outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer > < bsbPanel > < label > Widgets </ label > < objectName /> < x > 100 </ x > < y > 100 </ y > < w idth > 320 </ w idth > < height > 240 </ height > < visible > true </ visible > < uuid /> < bgcolor mode = \"nobackground\" > < r > 255 </ r > < g > 255 </ g > < b > 255 </ b > </ bgcolor > </ bsbPanel > < bsbPresets > </ bsbPresets > See also crackle chuap dust2 Credits Eduardo Moguillansky, 2019 (based on pd/else's standard~ - https://github.com/porres/pd-else)","title":"standardchaos"},{"location":"opcodes/standardchaos.html#standardchaos","text":"","title":"standardchaos"},{"location":"opcodes/standardchaos.html#abstract","text":"Standard map chaotic generator","title":"Abstract"},{"location":"opcodes/standardchaos.html#description","text":"standardchaos is a chaotic generator, the sound is generated with the following difference equations; y[n] = (y[n-1] + k * sin(x[n-1])) % 2pi; x[n] = (x[n-1] + y[n]) % 2pi; out = (x[n] - pi) / pi","title":"Description"},{"location":"opcodes/standardchaos.html#syntax","text":"a out standardchaos k rate , k k = 1 , i x = 0.5 , i y = 0","title":"Syntax"},{"location":"opcodes/standardchaos.html#arguments","text":"krate : from 0 to nyquist kk : a value for k in the above equation ix : initial value for x iy : initial value for y","title":"Arguments"},{"location":"opcodes/standardchaos.html#output","text":"aout : audio output of the chaotic generator","title":"Output"},{"location":"opcodes/standardchaos.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/standardchaos.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 /* Example file for standardchaos opcode aout standardchaos krate, kk, ix=0.5, iy=0 Standard map chaotic generator, the sound is generated with the difference equations; y[n] = (y[n-1] + k * sin(x[n-1])) % 2pi; x[n] = (x[n-1] + y[n]) % 2pi; out = (x[n] - pi) / pi; */ FLpanel \"standardchaos\" , 600 , 300 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 522 , 20 i disp2 FLvalue \"\" , 50 , 30 , 522 , 80 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk rate , gi h1 FLslider \"rate\" , 0 , 20000 , 0 , 3 , i disp1 , 500 , 30 , 20 , 20 gk k , gi h2 FLslider \"k\" , 0 , 10 , 0 , 3 , i disp2 , 500 , 30 , 20 , 80 FLpanelEnd FLrun FLsetVal_i 1618 , gi h1 FLsetVal_i 1 , gi h2 instr 1 i x = 0.5 i y = 1 i gain = 0.3 a out standardchaos gk rate , gk k , i x , i y a out *= i gain outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer > < bsbPanel > < label > Widgets </ label > < objectName /> < x > 100 </ x > < y > 100 </ y > < w idth > 320 </ w idth > < height > 240 </ height > < visible > true </ visible > < uuid /> < bgcolor mode = \"nobackground\" > < r > 255 </ r > < g > 255 </ g > < b > 255 </ b > </ bgcolor > </ bsbPanel > < bsbPresets > </ bsbPresets >","title":"Examples"},{"location":"opcodes/standardchaos.html#see-also","text":"crackle chuap dust2","title":"See also"},{"location":"opcodes/standardchaos.html#credits","text":"Eduardo Moguillansky, 2019 (based on pd/else's standard~ - https://github.com/porres/pd-else)","title":"Credits"},{"location":"opcodes/strsplit.html","text":"strsplit Abstract Split a string at a given separator Description Split a string into parts at a given separator. The separator is not included in any of the parts Syntax Sparts[] strsplit Sstring, Sseparator Arguments Sstring : The string to split Sseparator : the delimiter used to split the string Output Sparts : an array of strings, holding the parts. Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Sparts[] strsplit Sstring, Sseparator Split a string into parts at the given separator */ instr 1 S parts [] strsplit \"This;is;a;string!\" , \";\" printarray S parts S lines [] strsplit {{ Line 0 Line 1 Line 2 Line 3 Line 5}} , \" \\n \" printarray S lines turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also strstrip strsub strindex pathSplit [O] pathSplitExt Credits Eduardo Moguillansky, 2021","title":"strsplit"},{"location":"opcodes/strsplit.html#strsplit","text":"","title":"strsplit"},{"location":"opcodes/strsplit.html#abstract","text":"Split a string at a given separator","title":"Abstract"},{"location":"opcodes/strsplit.html#description","text":"Split a string into parts at a given separator. The separator is not included in any of the parts","title":"Description"},{"location":"opcodes/strsplit.html#syntax","text":"Sparts[] strsplit Sstring, Sseparator","title":"Syntax"},{"location":"opcodes/strsplit.html#arguments","text":"Sstring : The string to split Sseparator : the delimiter used to split the string","title":"Arguments"},{"location":"opcodes/strsplit.html#output","text":"Sparts : an array of strings, holding the parts.","title":"Output"},{"location":"opcodes/strsplit.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/strsplit.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Sparts[] strsplit Sstring, Sseparator Split a string into parts at the given separator */ instr 1 S parts [] strsplit \"This;is;a;string!\" , \";\" printarray S parts S lines [] strsplit {{ Line 0 Line 1 Line 2 Line 3 Line 5}} , \" \\n \" printarray S lines turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/strsplit.html#see-also","text":"strstrip strsub strindex pathSplit [O] pathSplitExt","title":"See also"},{"location":"opcodes/strsplit.html#credits","text":"Eduardo Moguillansky, 2021","title":"Credits"},{"location":"opcodes/sysPlatform.html","text":"sysPlatform Abstract Get a string description of the current system platform Description Possible values depending on the platform: * windows * linux * macos * android * unix For unknown platforms, this opcode returns an empty string Syntax Splatform sysPlatform Arguments Output Splatform : a string describing the current platform Execution Time Init Examples S platform sysPlatform prints \"Csound is runnign on platform: %s \\n \" , S platform See also pathNative Credits Eduardo Moguillansky, 2020","title":"sysPlatform"},{"location":"opcodes/sysPlatform.html#sysplatform","text":"","title":"sysPlatform"},{"location":"opcodes/sysPlatform.html#abstract","text":"Get a string description of the current system platform","title":"Abstract"},{"location":"opcodes/sysPlatform.html#description","text":"Possible values depending on the platform: * windows * linux * macos * android * unix For unknown platforms, this opcode returns an empty string","title":"Description"},{"location":"opcodes/sysPlatform.html#syntax","text":"Splatform sysPlatform","title":"Syntax"},{"location":"opcodes/sysPlatform.html#arguments","text":"","title":"Arguments"},{"location":"opcodes/sysPlatform.html#output","text":"Splatform : a string describing the current platform","title":"Output"},{"location":"opcodes/sysPlatform.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/sysPlatform.html#examples","text":"S platform sysPlatform prints \"Csound is runnign on platform: %s \\n \" , S platform","title":"Examples"},{"location":"opcodes/sysPlatform.html#see-also","text":"pathNative","title":"See also"},{"location":"opcodes/sysPlatform.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/throwerror.html","text":"throwerror Abstract Throws an error message at performance or init Description Use throwerror to stop the current event with a performance error. Alternatively throwerror can just issue a warning. Without a type, a performance error is thrown. Syntax throwerror Smessage throwerror Stype, Smessage Arguments Stype : one of \"error\", \"init\", \"warning\", \"info\". If absent, type defaults to \"error\" Smessage : the text message to show. Use sprintf / sprintfk to construct a message if needed Output Execution Time Init (if Stype == \"init\") Performance (otherwise) Examples if k midi > 128 then throwerror \"Received an invalid midi value, stopping current event\" endif See also Credits Eduardo Moguillansky, 2019","title":"throwerror"},{"location":"opcodes/throwerror.html#throwerror","text":"","title":"throwerror"},{"location":"opcodes/throwerror.html#abstract","text":"Throws an error message at performance or init","title":"Abstract"},{"location":"opcodes/throwerror.html#description","text":"Use throwerror to stop the current event with a performance error. Alternatively throwerror can just issue a warning. Without a type, a performance error is thrown.","title":"Description"},{"location":"opcodes/throwerror.html#syntax","text":"throwerror Smessage throwerror Stype, Smessage","title":"Syntax"},{"location":"opcodes/throwerror.html#arguments","text":"Stype : one of \"error\", \"init\", \"warning\", \"info\". If absent, type defaults to \"error\" Smessage : the text message to show. Use sprintf / sprintfk to construct a message if needed","title":"Arguments"},{"location":"opcodes/throwerror.html#output","text":"","title":"Output"},{"location":"opcodes/throwerror.html#execution-time","text":"Init (if Stype == \"init\") Performance (otherwise)","title":"Execution Time"},{"location":"opcodes/throwerror.html#examples","text":"if k midi > 128 then throwerror \"Received an invalid midi value, stopping current event\" endif","title":"Examples"},{"location":"opcodes/throwerror.html#see-also","text":"","title":"See also"},{"location":"opcodes/throwerror.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/trigExpseg.html","text":"trigExpseg Abstract Trace a series of exponential segments between specified points. Description Trace a series of exponential segments between specified points. Unlike the expseg opcode, this opcode can be triggered during perf time. Syntax a res trigExpseg k Trig , i a , i dur1 , i b [, i dur2 ] [, i c ] [ ... ] k res trigExpseg k Trig , i a , i dur1 , i b [, i dur2 ] [, i c ] [ ... ] Initialization kTrig -- trigger signal. When kTrig is greater or equal to one, it will trigger the breakpoint envelope. If you trigger the envelop before it has finished, it will result in clicks. ia -- starting value. Zero is illegal for exponentials. ib, ic, etc. -- value after dur1 seconds, etc. For exponentials, must be non-zero and must agree in sign with ia. idur1 -- duration in seconds of first segment. A zero or negative value will cause all initialization to be skipped. idur2, idur3, etc. -- duration in seconds of subsequent segments. A zero or negative value will terminate the initialization process with the preceding point, permitting the last-defined line or curve to be continued indefinitely in performance. The default is zero. Performance These units generate control or audio signals whose values can pass through 2 or more specified points. The sum of dur values may or may not equal the instrument's performance time: a shorter performance will truncate the specified pattern, while a longer one will cause the last-defined segment to continue on in the same direction. Example < CsoundSynthesizer > < CsOptions > ; Select audio/midi flags here according to platform - odac -- opcode - lib =../bu i ld/l i bs t rRem o ve.dyl i b ;-iadc ;;;uncomment -iadc if RT audio input is needed too ; For Non-realtime ouput leave only the line below: ; -o diskin.wav -W ;;; for file output any platform </ CsOptions > < CsInstruments > 0dbfs = 1 instr 1 k Trig init 1 a Env trigExpseg k Trig , 0 , 1 , 1 , 1 , .001 a 1 oscili a Env , 400 outs a 1 , a 1 k Trig = 0 endin </ CsInstruments > < CsScore > i 1 0 10 </ CsScore > </ CsoundSynthesizer > See Also trigLinseg Credits Author: Rory Walsh 2018","title":"trigExpseg"},{"location":"opcodes/trigExpseg.html#trigexpseg","text":"","title":"trigExpseg"},{"location":"opcodes/trigExpseg.html#abstract","text":"Trace a series of exponential segments between specified points.","title":"Abstract"},{"location":"opcodes/trigExpseg.html#description","text":"Trace a series of exponential segments between specified points. Unlike the expseg opcode, this opcode can be triggered during perf time.","title":"Description"},{"location":"opcodes/trigExpseg.html#syntax","text":"a res trigExpseg k Trig , i a , i dur1 , i b [, i dur2 ] [, i c ] [ ... ] k res trigExpseg k Trig , i a , i dur1 , i b [, i dur2 ] [, i c ] [ ... ]","title":"Syntax"},{"location":"opcodes/trigExpseg.html#initialization","text":"kTrig -- trigger signal. When kTrig is greater or equal to one, it will trigger the breakpoint envelope. If you trigger the envelop before it has finished, it will result in clicks. ia -- starting value. Zero is illegal for exponentials. ib, ic, etc. -- value after dur1 seconds, etc. For exponentials, must be non-zero and must agree in sign with ia. idur1 -- duration in seconds of first segment. A zero or negative value will cause all initialization to be skipped. idur2, idur3, etc. -- duration in seconds of subsequent segments. A zero or negative value will terminate the initialization process with the preceding point, permitting the last-defined line or curve to be continued indefinitely in performance. The default is zero.","title":"Initialization"},{"location":"opcodes/trigExpseg.html#performance","text":"These units generate control or audio signals whose values can pass through 2 or more specified points. The sum of dur values may or may not equal the instrument's performance time: a shorter performance will truncate the specified pattern, while a longer one will cause the last-defined segment to continue on in the same direction.","title":"Performance"},{"location":"opcodes/trigExpseg.html#example","text":"< CsoundSynthesizer > < CsOptions > ; Select audio/midi flags here according to platform - odac -- opcode - lib =../bu i ld/l i bs t rRem o ve.dyl i b ;-iadc ;;;uncomment -iadc if RT audio input is needed too ; For Non-realtime ouput leave only the line below: ; -o diskin.wav -W ;;; for file output any platform </ CsOptions > < CsInstruments > 0dbfs = 1 instr 1 k Trig init 1 a Env trigExpseg k Trig , 0 , 1 , 1 , 1 , .001 a 1 oscili a Env , 400 outs a 1 , a 1 k Trig = 0 endin </ CsInstruments > < CsScore > i 1 0 10 </ CsScore > </ CsoundSynthesizer >","title":"Example"},{"location":"opcodes/trigExpseg.html#see-also","text":"trigLinseg","title":"See Also"},{"location":"opcodes/trigExpseg.html#credits","text":"Author: Rory Walsh 2018","title":"Credits"},{"location":"opcodes/trigLinseg.html","text":"trigLinseg Abstract Trace a series of line segments between specified points. Description Trace a series of line segments between specified points. Unlike the linseg opcode, this opcode can be triggered during perf time. Syntax a res trigLinseg k Trig , i a , i dur1 , i b [, i dur2 ] [, i c ] [ ... ] k res trigLinseg k Trig , i a , i dur1 , i b [, i dur2 ] [, i c ] [ ... ] Initialization kTrig -- trigger signal. When kTrig is greater or equal to one, it will trigger the breakpoint envelope. If you trigger the envelop before it has finished, it will result in clicks. ia -- starting value. ib , ic , etc. -- value after dur1 seconds, etc. idur1 -- duration in seconds of first segment. A zero or negative value will cause all initialization to be skipped. idur2 , idur3 , etc. -- duration in seconds of subsequent segments. A zero or negative value will terminate the initialization process with the preceding point, permitting the last-defined line or curve to be continued indefinitely in performance. The default is zero. Performance These units generate control or audio signals whose values can pass through 2 or more specified points. The sum of dur values may or may not equal the instrument's performance time: a shorter performance will truncate the specified pattern, while a longer one will cause the last value to be repeated until the end of the note. Example Here is an example of the trigLinseg opcode. < CsoundSynthesizer > < CsOptions > ; Select audio/midi flags here according to platform - odac ;-iadc ;;;uncomment -iadc if RT audio input is needed too ; For Non-realtime ouput leave only the line below: ; -o diskin.wav -W ;;; for file output any platform </ CsOptions > < CsInstruments > 0dbfs = 1 instr 1 k Trig metro .5 a Env trigLinseg k Trig , 0 , 1 , 1 , 1 , 0 a 1 oscili a Env , 400 outs a 1 , a 1 endin </ CsInstruments > < CsScore > i 1 0 10 </ CsScore > </ CsoundSynthesizer > See Also trigExpseg Credits Author: Rory Walsh 2018","title":"trigLinseg"},{"location":"opcodes/trigLinseg.html#triglinseg","text":"","title":"trigLinseg"},{"location":"opcodes/trigLinseg.html#abstract","text":"Trace a series of line segments between specified points.","title":"Abstract"},{"location":"opcodes/trigLinseg.html#description","text":"Trace a series of line segments between specified points. Unlike the linseg opcode, this opcode can be triggered during perf time.","title":"Description"},{"location":"opcodes/trigLinseg.html#syntax","text":"a res trigLinseg k Trig , i a , i dur1 , i b [, i dur2 ] [, i c ] [ ... ] k res trigLinseg k Trig , i a , i dur1 , i b [, i dur2 ] [, i c ] [ ... ]","title":"Syntax"},{"location":"opcodes/trigLinseg.html#initialization","text":"kTrig -- trigger signal. When kTrig is greater or equal to one, it will trigger the breakpoint envelope. If you trigger the envelop before it has finished, it will result in clicks. ia -- starting value. ib , ic , etc. -- value after dur1 seconds, etc. idur1 -- duration in seconds of first segment. A zero or negative value will cause all initialization to be skipped. idur2 , idur3 , etc. -- duration in seconds of subsequent segments. A zero or negative value will terminate the initialization process with the preceding point, permitting the last-defined line or curve to be continued indefinitely in performance. The default is zero.","title":"Initialization"},{"location":"opcodes/trigLinseg.html#performance","text":"These units generate control or audio signals whose values can pass through 2 or more specified points. The sum of dur values may or may not equal the instrument's performance time: a shorter performance will truncate the specified pattern, while a longer one will cause the last value to be repeated until the end of the note.","title":"Performance"},{"location":"opcodes/trigLinseg.html#example","text":"Here is an example of the trigLinseg opcode. < CsoundSynthesizer > < CsOptions > ; Select audio/midi flags here according to platform - odac ;-iadc ;;;uncomment -iadc if RT audio input is needed too ; For Non-realtime ouput leave only the line below: ; -o diskin.wav -W ;;; for file output any platform </ CsOptions > < CsInstruments > 0dbfs = 1 instr 1 k Trig metro .5 a Env trigLinseg k Trig , 0 , 1 , 1 , 1 , 0 a 1 oscili a Env , 400 outs a 1 , a 1 endin </ CsInstruments > < CsScore > i 1 0 10 </ CsScore > </ CsoundSynthesizer >","title":"Example"},{"location":"opcodes/trigLinseg.html#see-also","text":"trigExpseg","title":"See Also"},{"location":"opcodes/trigLinseg.html#credits","text":"Author: Rory Walsh 2018","title":"Credits"},{"location":"opcodes/tubeharmonics.html","text":"tubeharmonics Abstract A distortion with control for odd/even harmonics Description Simulates the behaviour of a vacuum tube circuit stage. Adds odd and even harmonics to the signal. Has flux and program dependent saturation. A port of REAPER 's \"Tube Harmonics\" jsfx plugin Syntax a out tubeharmonics a in , k even , k odd , k fluctuation = 0 , k indrive = 0 , k outdrive = 0 , k gain = 0 Arguments ain : the input signal keven : amount of even harmonics (between 0-1) kodd : amount of odd harmonics (between 0-1) kfluctuation : non linearities (between 0-1, default 0) kindrive : amount of input drive (in dB, default=0 dB) koutdrive : amount of output drive (in dB, default=0 dB) koutgain : output gain, in dB (default=0 dB) Output aout : audio output Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for tubeharmonics opcode gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i gain = 0 a 1 , a 2 tubeharmonics a sig , a sig , gk even , gk odd , gk flct , gk inpt , gk out , i gain outs a 1 , a 2 endin </ CsInstruments > < CsScore > i 1 0 300 </ CsScore > </ CsoundSynthesizer > See also sigmdrive tanh distort1 Credits Eduardo Moguillansky, 2019","title":"tubeharmonics"},{"location":"opcodes/tubeharmonics.html#tubeharmonics","text":"","title":"tubeharmonics"},{"location":"opcodes/tubeharmonics.html#abstract","text":"A distortion with control for odd/even harmonics","title":"Abstract"},{"location":"opcodes/tubeharmonics.html#description","text":"Simulates the behaviour of a vacuum tube circuit stage. Adds odd and even harmonics to the signal. Has flux and program dependent saturation. A port of REAPER 's \"Tube Harmonics\" jsfx plugin","title":"Description"},{"location":"opcodes/tubeharmonics.html#syntax","text":"a out tubeharmonics a in , k even , k odd , k fluctuation = 0 , k indrive = 0 , k outdrive = 0 , k gain = 0","title":"Syntax"},{"location":"opcodes/tubeharmonics.html#arguments","text":"ain : the input signal keven : amount of even harmonics (between 0-1) kodd : amount of odd harmonics (between 0-1) kfluctuation : non linearities (between 0-1, default 0) kindrive : amount of input drive (in dB, default=0 dB) koutdrive : amount of output drive (in dB, default=0 dB) koutgain : output gain, in dB (default=0 dB)","title":"Arguments"},{"location":"opcodes/tubeharmonics.html#output","text":"aout : audio output","title":"Output"},{"location":"opcodes/tubeharmonics.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/tubeharmonics.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for tubeharmonics opcode gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i gain = 0 a 1 , a 2 tubeharmonics a sig , a sig , gk even , gk odd , gk flct , gk inpt , gk out , i gain outs a 1 , a 2 endin </ CsInstruments > < CsScore > i 1 0 300 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/tubeharmonics.html#see-also","text":"sigmdrive tanh distort1","title":"See also"},{"location":"opcodes/tubeharmonics.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/uniqinstance.html","text":"uniqinstance Abstract Return an fractional instrument number which is not in use Description Given an integer instrument number, uniqinstance a fractional instrument number which is not active now and can be used as p1 for event , schedule or similar opcodes to create a unique instance of the given instrument Note This opcode DOES NOT create a new instance. It just returns an instr number which can be used to create one Syntax i nstrnum uniqinstance i nteger_instrnum i nstrnum uniqinstance S instrname Arguments integer_instrnum : the integer instrument number Sinstrname : the name of a named instrument Output instrnum : a fractional instrument number which is guaranteed not to be active at the moment Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > /* Example file for uniqinstance instrnum uniqinstance intinstr Returns a unique fractional instrument number which is not active at the moment and can be assigned to a new instance */ instr exit exitnow endin instr 1 ; generate new instances manually, to check that ; uniqinstance does not collide with existing instances ; scheduled via other means k counter init 0 k trig metro 20 if k trig == 1 then k counter += 1 k inst = 10 + k counter / 100 printsk \"kinst= %f \\n \" , k inst schedulek ( k inst , 0 , 1 ) endif endin instr 2 i nstrnum10 uniqinstance 10 prints \"Unique instance of 10= %f \\n \" , i nstrnum10 i nstrnum11 uniqinstance 11 , 1000 prints \"Unique instance of 11= %f \\n \" , i nstrnum11 turnoff endin instr 10 print p1 endin instr 11 print p1 endin instr example1 printf \">>>>>>>>>>>>>>>>>>> example1 \\n \" , 1 schedule 1 , 0 , 0.5 schedule 2 , 0.5 , 0.1 schedule 10.150 , 0 , 0.1 schedule 11 , 0 , 2 turnoff endin ; -------------------------------------- ; Test that instances get recycled instr example2 prints \">>>>>>>>>>>>>>>>>>> example2 \\n \" i 0 = 0 i step = 0.01 i maxinstances = 100 i dur = i step * i maxinstances while i 0 < 1000 do schedule \"scheduniq\" , i 0 * i step , i dur , 20 , i maxinstances i 0 += 1 od i maxdur = 2000 * i step + i dur turnoff endin instr scheduniq i num = p4 i max = p5 i num2 = uniqinstance ( i num , i max ) if i num2 < 0 then prints \"<<<<< Could not find unique instance >>>>> \\n \" else schedule i num2 , 0 , p3 prints \"active now= %d , inum= %f \\n \" , active ( i num ), i num2 endif turnoff endin instr 20 prints \"started %f \\n \" , p1 defer \"prints\" , \"finished %f \\n \" , p1 endin ; ----------------------- ; Text what happens if called with a non-existent instr instr example3 i num = uniqinstance ( 234 ) print i num turnoff endin </ CsInstruments > < CsScore > ; i \"example1\" 0 10 ; i \"example2\" 0 10 i \"example3\" 0 0.1 </ CsScore > </ CsoundSynthesizer > See also pread pset p passign nstrnum Credits Eduardo Moguillansky, 2019","title":"uniqinstance"},{"location":"opcodes/uniqinstance.html#uniqinstance","text":"","title":"uniqinstance"},{"location":"opcodes/uniqinstance.html#abstract","text":"Return an fractional instrument number which is not in use","title":"Abstract"},{"location":"opcodes/uniqinstance.html#description","text":"Given an integer instrument number, uniqinstance a fractional instrument number which is not active now and can be used as p1 for event , schedule or similar opcodes to create a unique instance of the given instrument Note This opcode DOES NOT create a new instance. It just returns an instr number which can be used to create one","title":"Description"},{"location":"opcodes/uniqinstance.html#syntax","text":"i nstrnum uniqinstance i nteger_instrnum i nstrnum uniqinstance S instrname","title":"Syntax"},{"location":"opcodes/uniqinstance.html#arguments","text":"integer_instrnum : the integer instrument number Sinstrname : the name of a named instrument","title":"Arguments"},{"location":"opcodes/uniqinstance.html#output","text":"instrnum : a fractional instrument number which is guaranteed not to be active at the moment","title":"Output"},{"location":"opcodes/uniqinstance.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/uniqinstance.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > /* Example file for uniqinstance instrnum uniqinstance intinstr Returns a unique fractional instrument number which is not active at the moment and can be assigned to a new instance */ instr exit exitnow endin instr 1 ; generate new instances manually, to check that ; uniqinstance does not collide with existing instances ; scheduled via other means k counter init 0 k trig metro 20 if k trig == 1 then k counter += 1 k inst = 10 + k counter / 100 printsk \"kinst= %f \\n \" , k inst schedulek ( k inst , 0 , 1 ) endif endin instr 2 i nstrnum10 uniqinstance 10 prints \"Unique instance of 10= %f \\n \" , i nstrnum10 i nstrnum11 uniqinstance 11 , 1000 prints \"Unique instance of 11= %f \\n \" , i nstrnum11 turnoff endin instr 10 print p1 endin instr 11 print p1 endin instr example1 printf \">>>>>>>>>>>>>>>>>>> example1 \\n \" , 1 schedule 1 , 0 , 0.5 schedule 2 , 0.5 , 0.1 schedule 10.150 , 0 , 0.1 schedule 11 , 0 , 2 turnoff endin ; -------------------------------------- ; Test that instances get recycled instr example2 prints \">>>>>>>>>>>>>>>>>>> example2 \\n \" i 0 = 0 i step = 0.01 i maxinstances = 100 i dur = i step * i maxinstances while i 0 < 1000 do schedule \"scheduniq\" , i 0 * i step , i dur , 20 , i maxinstances i 0 += 1 od i maxdur = 2000 * i step + i dur turnoff endin instr scheduniq i num = p4 i max = p5 i num2 = uniqinstance ( i num , i max ) if i num2 < 0 then prints \"<<<<< Could not find unique instance >>>>> \\n \" else schedule i num2 , 0 , p3 prints \"active now= %d , inum= %f \\n \" , active ( i num ), i num2 endif turnoff endin instr 20 prints \"started %f \\n \" , p1 defer \"prints\" , \"finished %f \\n \" , p1 endin ; ----------------------- ; Text what happens if called with a non-existent instr instr example3 i num = uniqinstance ( 234 ) print i num turnoff endin </ CsInstruments > < CsScore > ; i \"example1\" 0 10 ; i \"example2\" 0 10 i \"example3\" 0 0.1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/uniqinstance.html#see-also","text":"pread pset p passign nstrnum","title":"See also"},{"location":"opcodes/uniqinstance.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/zeroarray.html","text":"zeroarray Abstract Zero all elements in an array Description zeroarray sets all elements in an array to 0. Syntax zeroarray i Arr zeroarray k Arr zeroarray a Arr Arguments iArr / kArr / aArr : The array to zero Output Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > /* Description =========== zeroarr zeroes all elements in an array of any (numeric) kind Syntax ====== zeroarr karr zeroarr arr */ ksmps = 32 nchnls = 2 0dbfs = 1 ga buses [] init 4 instr 10 a sig vco2 0.1 , 1000 ga buses [ 0 ] = ga buses [ 0 ] + a sig endin instr 20 a sig = ga buses [ 0 ] outch 1 , a sig zeroarray ga buses endin </ CsInstruments > < CsScore > i 10 0 10 i 20 0 10 </ CsScore > </ CsoundSynthesizer > See also ftset setslice ftslice Credits Eduardo Moguillansky, 2021","title":"zeroarray"},{"location":"opcodes/zeroarray.html#zeroarray","text":"","title":"zeroarray"},{"location":"opcodes/zeroarray.html#abstract","text":"Zero all elements in an array","title":"Abstract"},{"location":"opcodes/zeroarray.html#description","text":"zeroarray sets all elements in an array to 0.","title":"Description"},{"location":"opcodes/zeroarray.html#syntax","text":"zeroarray i Arr zeroarray k Arr zeroarray a Arr","title":"Syntax"},{"location":"opcodes/zeroarray.html#arguments","text":"iArr / kArr / aArr : The array to zero","title":"Arguments"},{"location":"opcodes/zeroarray.html#output","text":"","title":"Output"},{"location":"opcodes/zeroarray.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/zeroarray.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > /* Description =========== zeroarr zeroes all elements in an array of any (numeric) kind Syntax ====== zeroarr karr zeroarr arr */ ksmps = 32 nchnls = 2 0dbfs = 1 ga buses [] init 4 instr 10 a sig vco2 0.1 , 1000 ga buses [ 0 ] = ga buses [ 0 ] + a sig endin instr 20 a sig = ga buses [ 0 ] outch 1 , a sig zeroarray ga buses endin </ CsInstruments > < CsScore > i 10 0 10 i 20 0 10 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/zeroarray.html#see-also","text":"ftset setslice ftslice","title":"See also"},{"location":"opcodes/zeroarray.html#credits","text":"Eduardo Moguillansky, 2021","title":"Credits"}]}