{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Csound Plugins Welcome to the csound-plugins wiki! This is a collection of plugins for csound Installation See Installation klib A hashtable for csound dict_new : Create a hashtable dict_free : Free a hashtable dict_get : Get a value from a hashtable dict_set : Set (or remove) a value from a hashtable dict_size : Returns the number of key:value pairs in a dict dict_query : Query different properties of a dict dict_exists : Returns 1 if the dict exists, 0 otherwise dict_print : Prints the contents of a dict dict_iter : Iterate over the key-value pairs of a dict strcache : Put a string into the global cache or retrieve a string from the cache strview : Retrieves a read-only string from the cache pool_new : Create an empty pool pool_gen : Create a pool and fill it with values pool_pop : Pop (get) an item from a pool pool_push : Push an item into a pool pool_size : Returns the size of a pool pool_capacity : Returns the capacity of a pool pool_at : Returns the item of a pool at a given index poly Multiple (parallel or sequential) instances of an opcode poly : poly creates and controls multiple parallel version of an opcode polyseq : polyseq creates and controls multiple sequential version of an opcode poly0 : poly0 creates and controls multiple parallel version of an opcode with no outputs defer : Run an opcode at the end of current event jsfx A csound interface to the opensource implementation of jsfx jsfx : Instantiates and runs a jsfx script jsfx_new : Instantiates a jsfx script jsfx_play : Processes audio through a jsfx script jsfx_getslider : Gets a slider value of a jsfx instance jsfx_setslider : Sets the slider values of a jsfx script tubeharmonics : A distortion with control for odd/even harmonics else Collection of miscellaneous plugins, most ports of supercollider, puredata/else or jsfx crackle : generates noise based on a chaotic equation ramptrig : A triggerable ramp between 0 and 1 sigmdrive : Analog \"soft clipping\" distortion by applying non-linear transfer functions. lfnoise : low frequency, band-limited noise schmitt : A schmitt trigger (a comparator with hysteresis). standardchaos : Standard map chaotic generator linenv : A triggerable linear envelope with sustain segment diode_ringmod : A ring modulator with optional non-linearities file_exists : Returns 1 if a file exists and can be read pwrite : Modify pfield values of an active instrument instance pread : Read pfield values from any active instrument instance uniqinstance : Return an fractional instrument number which is not in use atstop : Schedule an instrument at the end of the current instrument accum : Simple accumulator of scalar values frac2int : Convert the fractional part of a number into an integer ref : Get a reference to a variable deref : Dereference a previously created reference to a variable refvalid : Queries if a reference is valid memview : Create a view into a table or another array xtracycles : Returns the number of extra performance cycles for an event","title":"Csound Plugins"},{"location":"index.html#csound-plugins","text":"Welcome to the csound-plugins wiki! This is a collection of plugins for csound","title":"Csound Plugins"},{"location":"index.html#installation","text":"See Installation","title":"Installation"},{"location":"index.html#klib","text":"A hashtable for csound dict_new : Create a hashtable dict_free : Free a hashtable dict_get : Get a value from a hashtable dict_set : Set (or remove) a value from a hashtable dict_size : Returns the number of key:value pairs in a dict dict_query : Query different properties of a dict dict_exists : Returns 1 if the dict exists, 0 otherwise dict_print : Prints the contents of a dict dict_iter : Iterate over the key-value pairs of a dict strcache : Put a string into the global cache or retrieve a string from the cache strview : Retrieves a read-only string from the cache pool_new : Create an empty pool pool_gen : Create a pool and fill it with values pool_pop : Pop (get) an item from a pool pool_push : Push an item into a pool pool_size : Returns the size of a pool pool_capacity : Returns the capacity of a pool pool_at : Returns the item of a pool at a given index","title":"klib"},{"location":"index.html#poly","text":"Multiple (parallel or sequential) instances of an opcode poly : poly creates and controls multiple parallel version of an opcode polyseq : polyseq creates and controls multiple sequential version of an opcode poly0 : poly0 creates and controls multiple parallel version of an opcode with no outputs defer : Run an opcode at the end of current event","title":"poly"},{"location":"index.html#jsfx","text":"A csound interface to the opensource implementation of jsfx jsfx : Instantiates and runs a jsfx script jsfx_new : Instantiates a jsfx script jsfx_play : Processes audio through a jsfx script jsfx_getslider : Gets a slider value of a jsfx instance jsfx_setslider : Sets the slider values of a jsfx script tubeharmonics : A distortion with control for odd/even harmonics","title":"jsfx"},{"location":"index.html#else","text":"Collection of miscellaneous plugins, most ports of supercollider, puredata/else or jsfx crackle : generates noise based on a chaotic equation ramptrig : A triggerable ramp between 0 and 1 sigmdrive : Analog \"soft clipping\" distortion by applying non-linear transfer functions. lfnoise : low frequency, band-limited noise schmitt : A schmitt trigger (a comparator with hysteresis). standardchaos : Standard map chaotic generator linenv : A triggerable linear envelope with sustain segment diode_ringmod : A ring modulator with optional non-linearities file_exists : Returns 1 if a file exists and can be read pwrite : Modify pfield values of an active instrument instance pread : Read pfield values from any active instrument instance uniqinstance : Return an fractional instrument number which is not in use atstop : Schedule an instrument at the end of the current instrument accum : Simple accumulator of scalar values frac2int : Convert the fractional part of a number into an integer ref : Get a reference to a variable deref : Dereference a previously created reference to a variable refvalid : Queries if a reference is valid memview : Create a view into a table or another array xtracycles : Returns the number of extra performance cycles for an event","title":"else"},{"location":"Contributing.html","text":"Contributing To submit an opcode clone this repository and make a pull request Organisation An opcode is normally implemented as part of a library, to allow for different versions and related opcodes to share functionality. Each library lives in its own directory. The tree can be structured as follows: mylib/ CMakeLists.txt manifest.json [ README.md ] src/ mylib.c examples/ foo.csd bar.csd docs/ foo.md bar.md For each opcode defined in mylib.c there should be an example opcode.csd and a manual page opcode.md . Optionally it is possible to include a README.md where a short description of the opcodes in this library is given Put your tree under src and you should be able to build your plugin. Build We use cmake as a build tool. For simple opcodes with no extra dependencies, a simple CMakeLists.txt would suffice: make_plugin(mylib src/mylib.c) Installation At the root folder of this repository, do mkdir build cd build cmake .. make sudo make install Manifest A manifest is used to automate documentation of the opcodes (wiki, pdf documentation, etc). The manifest is a .json file. It should have the minimal form: { \"name\" : \"mylib\" , \"opcodes\" : [ \"foo\" , \"bar\" ], \"author\" : \"name\" , \"author_email\" : \"name@email.com\" , \"license\" : \"LGPL\" , \"description\" : \"Description of this package\" , \"url\" : \"http://github.com/...\" } In this case, three opcodes are defined, and these names should correspond to the .csd example living inside of the examples folder, and a .md file living inside the docs folder.","title":"Contributing"},{"location":"Contributing.html#contributing","text":"To submit an opcode clone this repository and make a pull request","title":"Contributing"},{"location":"Contributing.html#organisation","text":"An opcode is normally implemented as part of a library, to allow for different versions and related opcodes to share functionality. Each library lives in its own directory. The tree can be structured as follows: mylib/ CMakeLists.txt manifest.json [ README.md ] src/ mylib.c examples/ foo.csd bar.csd docs/ foo.md bar.md For each opcode defined in mylib.c there should be an example opcode.csd and a manual page opcode.md . Optionally it is possible to include a README.md where a short description of the opcodes in this library is given Put your tree under src and you should be able to build your plugin.","title":"Organisation"},{"location":"Contributing.html#build","text":"We use cmake as a build tool. For simple opcodes with no extra dependencies, a simple CMakeLists.txt would suffice: make_plugin(mylib src/mylib.c)","title":"Build"},{"location":"Contributing.html#installation","text":"At the root folder of this repository, do mkdir build cd build cmake .. make sudo make install","title":"Installation"},{"location":"Contributing.html#manifest","text":"A manifest is used to automate documentation of the opcodes (wiki, pdf documentation, etc). The manifest is a .json file. It should have the minimal form: { \"name\" : \"mylib\" , \"opcodes\" : [ \"foo\" , \"bar\" ], \"author\" : \"name\" , \"author_email\" : \"name@email.com\" , \"license\" : \"LGPL\" , \"description\" : \"Description of this package\" , \"url\" : \"http://github.com/...\" } In this case, three opcodes are defined, and these names should correspond to the .csd example living inside of the examples folder, and a .md file living inside the docs folder.","title":"Manifest"},{"location":"Installation.html","text":"Installation From Source The source lives at https://github.com/csound-plugins/csound-plugins Dependencies a compiler cmake csound >= 6.13 git clone https://github.com/csound-plugins/csound-plugins cd csound-plugins mkdir build cd build cmake .. make sudo make install","title":"Installation"},{"location":"Installation.html#installation","text":"","title":"Installation"},{"location":"Installation.html#from-source","text":"The source lives at https://github.com/csound-plugins/csound-plugins","title":"From Source"},{"location":"Installation.html#dependencies","text":"a compiler cmake csound >= 6.13 git clone https://github.com/csound-plugins/csound-plugins cd csound-plugins mkdir build cd build cmake .. make sudo make install","title":"Dependencies"},{"location":"opcodes/accum.html","text":"accum Abstract Simple accumulator of scalar values Description accum can be used together with changed , changed2 , metro , etc, to convert a binary trigger to an incremental one. Incremental triggers are used by many opcodes ( printf , for example), so by doing accum(changed(kvar)) it is possible to use binary triggers wherever an incremental trigger is expected. Syntax kout accum kin, initial=0 Arguments `kin': the step to add. This value will be added each k-cycle initial : initial value of the accumulator Output kout : accumulated value Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > instr 1 k x linseg 0 , p3 , 1 printf \"kx= %f \\n \" , a ccum ( changed ( k x )), k x ; the same without accum would only print the first time, ; since changed would return always 1 but printf expects an ever ; increasing trigger endin </ CsInstruments > < CsScore > i 1 0 0.1 </ CsScore > </ CsoundSynthesizer > See also metro changed sc_trig printf Credits Eduardo Moguillansky, 2019","title":"accum"},{"location":"opcodes/accum.html#accum","text":"","title":"accum"},{"location":"opcodes/accum.html#abstract","text":"Simple accumulator of scalar values","title":"Abstract"},{"location":"opcodes/accum.html#description","text":"accum can be used together with changed , changed2 , metro , etc, to convert a binary trigger to an incremental one. Incremental triggers are used by many opcodes ( printf , for example), so by doing accum(changed(kvar)) it is possible to use binary triggers wherever an incremental trigger is expected.","title":"Description"},{"location":"opcodes/accum.html#syntax","text":"kout accum kin, initial=0","title":"Syntax"},{"location":"opcodes/accum.html#arguments","text":"`kin': the step to add. This value will be added each k-cycle initial : initial value of the accumulator","title":"Arguments"},{"location":"opcodes/accum.html#output","text":"kout : accumulated value","title":"Output"},{"location":"opcodes/accum.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/accum.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > instr 1 k x linseg 0 , p3 , 1 printf \"kx= %f \\n \" , a ccum ( changed ( k x )), k x ; the same without accum would only print the first time, ; since changed would return always 1 but printf expects an ever ; increasing trigger endin </ CsInstruments > < CsScore > i 1 0 0.1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/accum.html#see-also","text":"metro changed sc_trig printf","title":"See also"},{"location":"opcodes/accum.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/atstop.html","text":"atstop Abstract Schedule an instrument at the end of the current instrument Description atstop can be used to schedule an instrument event as the last action of a given instrument, during the process of being deallocated. This can be used to notify when the note has actually stopped, or to schedule a chain of events, free any table or dict allocated, etc. The advantage over the release opcode is that atstop is guaranteed to be run after the note has stopped, so there is no danger in deallocating resources being used by this note, there are no conflicts with release envelopes, etc. Release time vs deinit time The event is not scheduled at release time (see below \"Release time vs Deinit time\") but at the moment the note is freed. Release time is when the note is within its release phase , which will only happen if the note has an envelope with a release segment (like linsegr ), or if it has setup extra time with xtratim . The opcode release can be used to query if the current note is being released. The instrument keeps running in release phase as long as the release part of the envelope is finished or the extra time allocated via xtratim is through. Deinit time is the moment the note is actually being freed, so the instrument is not running anymore at this point. Syntax atstop instrnum [, idelay=0, idur=-1, p4, p5, ...] atstop Sinstrname [, idelay=0, idur=-1, p4, p5, ...] atstop executes only at init time . Arguments instrnum / Sintrname : the number or the name of the instr to be scheduled idelay : the time offset after the stop time of this note to start this instrument idur : the duration of the event p4 , p5 , ...: any other p-arguments, as used with similar opcodes like schedule , event , etc. Execution Time Init Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* # This is the example file for the atstop opcode atstop schedules an instrument at the end of the note This might be useful to notify that a note stopped, or to schedule a chain of notes, etc. NB: the scheduled event is NOT triggered at release time, which might be when this note is still playing, if the note has some release envelope, but when the note is being deleted ## Syntax atstop Sinstrname, idelay, idur, ... atstop instrnum, idelay, idur, ... * Sinstrname / instrnum: the name or the instrument number to schedule * idelay: time offset to this note stop * idur: duration of the scheduled event (-1 = forever) */ sr = 44100 ksmps = 64 0dbfs = 1 nchnls = 2 opcode myvco , a , ii i amp , i freq xin a 0 vco2 , i amp , i freq a 0 += vco2 ( i amp , i freq + 2 ) a 0 += vco2 ( i amp , i freq / 2 ) xout a 0 endop ; brownian walk instr 1 i midi = p4 a 0 myvco 0.1 , mtof : i ( i midi ) outs a 0 , a 0 i delta = round (( rnd ( 4 ) - 1 ) * 2 ) / 2 i delta = i delta != 0 ? i delta : - 0.5 i midi2 = i midi + i delta i midi2 = i midi2 < 96 ? i midi2 : 48 i durnext = round ( rnd ( 0.25 ) * 8 ) / 8 a tstop 1 , 0 , i durnext , i midi2 endin ; ping-pong instr 2 i midi = p4 i midi = i midi < 96 ? i midi : 48 a 0 myvco 0.1 , mtof : i ( i midi ) a 0 *= linsegr ( 0 , 0.05 , 1 , 0.05 , 0 ) outs a 0 , a 0 a tstop 3 , 0 , p3 * 0.97 , i midi + 1 endin instr 3 i midi = p4 i midi = i midi < 88 ? i midi : 48 a 0 oscili 0.8 , mtof : i ( i midi ) a 0 *= linsegr ( 0 , 0.05 , 1 , 0.050 , 0 ) outs a 0 , a 0 a tstop 2 , 0 , p3 * 0.95 , i midi + 1 endin ; test calling a named instr at stop instr 10 a 0 oscili 0.1 , 440 outs a 0 , a 0 a tstop \"foo\" , 0.5 , 1 , 1000 endin instr foo i freq = p4 a 0 oscili 0.1 , i freq outs a 0 , a 0 endin ; test simple case with optional pargs instr first a tstop \"second\" , 1 , - 1 , 0.5 a tstop \"second\" , 0.5 a tstop 200 endin instr second printf \"second! p4 = %f \\n \" , 1 , p4 turnoff endin instr 200 printf \"200! \\n \" , 1 turnoff endin instr StopPerformance exitnow endin </ CsInstruments > < CsScore > ; i 1 0 0.25 36 ; i 2 0 0.25 48 ; i 10 0 1 ; i \"StopPerformance\" 10 1 i \"first\" 1 0.5 f 0 5 </ CsScore > </ CsoundSynthesizer > See also defer schedule event release xtratim Credits Eduardo Moguillansky, 2019","title":"atstop"},{"location":"opcodes/atstop.html#atstop","text":"","title":"atstop"},{"location":"opcodes/atstop.html#abstract","text":"Schedule an instrument at the end of the current instrument","title":"Abstract"},{"location":"opcodes/atstop.html#description","text":"atstop can be used to schedule an instrument event as the last action of a given instrument, during the process of being deallocated. This can be used to notify when the note has actually stopped, or to schedule a chain of events, free any table or dict allocated, etc. The advantage over the release opcode is that atstop is guaranteed to be run after the note has stopped, so there is no danger in deallocating resources being used by this note, there are no conflicts with release envelopes, etc. Release time vs deinit time The event is not scheduled at release time (see below \"Release time vs Deinit time\") but at the moment the note is freed. Release time is when the note is within its release phase , which will only happen if the note has an envelope with a release segment (like linsegr ), or if it has setup extra time with xtratim . The opcode release can be used to query if the current note is being released. The instrument keeps running in release phase as long as the release part of the envelope is finished or the extra time allocated via xtratim is through. Deinit time is the moment the note is actually being freed, so the instrument is not running anymore at this point.","title":"Description"},{"location":"opcodes/atstop.html#syntax","text":"atstop instrnum [, idelay=0, idur=-1, p4, p5, ...] atstop Sinstrname [, idelay=0, idur=-1, p4, p5, ...] atstop executes only at init time .","title":"Syntax"},{"location":"opcodes/atstop.html#arguments","text":"instrnum / Sintrname : the number or the name of the instr to be scheduled idelay : the time offset after the stop time of this note to start this instrument idur : the duration of the event p4 , p5 , ...: any other p-arguments, as used with similar opcodes like schedule , event , etc.","title":"Arguments"},{"location":"opcodes/atstop.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/atstop.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* # This is the example file for the atstop opcode atstop schedules an instrument at the end of the note This might be useful to notify that a note stopped, or to schedule a chain of notes, etc. NB: the scheduled event is NOT triggered at release time, which might be when this note is still playing, if the note has some release envelope, but when the note is being deleted ## Syntax atstop Sinstrname, idelay, idur, ... atstop instrnum, idelay, idur, ... * Sinstrname / instrnum: the name or the instrument number to schedule * idelay: time offset to this note stop * idur: duration of the scheduled event (-1 = forever) */ sr = 44100 ksmps = 64 0dbfs = 1 nchnls = 2 opcode myvco , a , ii i amp , i freq xin a 0 vco2 , i amp , i freq a 0 += vco2 ( i amp , i freq + 2 ) a 0 += vco2 ( i amp , i freq / 2 ) xout a 0 endop ; brownian walk instr 1 i midi = p4 a 0 myvco 0.1 , mtof : i ( i midi ) outs a 0 , a 0 i delta = round (( rnd ( 4 ) - 1 ) * 2 ) / 2 i delta = i delta != 0 ? i delta : - 0.5 i midi2 = i midi + i delta i midi2 = i midi2 < 96 ? i midi2 : 48 i durnext = round ( rnd ( 0.25 ) * 8 ) / 8 a tstop 1 , 0 , i durnext , i midi2 endin ; ping-pong instr 2 i midi = p4 i midi = i midi < 96 ? i midi : 48 a 0 myvco 0.1 , mtof : i ( i midi ) a 0 *= linsegr ( 0 , 0.05 , 1 , 0.05 , 0 ) outs a 0 , a 0 a tstop 3 , 0 , p3 * 0.97 , i midi + 1 endin instr 3 i midi = p4 i midi = i midi < 88 ? i midi : 48 a 0 oscili 0.8 , mtof : i ( i midi ) a 0 *= linsegr ( 0 , 0.05 , 1 , 0.050 , 0 ) outs a 0 , a 0 a tstop 2 , 0 , p3 * 0.95 , i midi + 1 endin ; test calling a named instr at stop instr 10 a 0 oscili 0.1 , 440 outs a 0 , a 0 a tstop \"foo\" , 0.5 , 1 , 1000 endin instr foo i freq = p4 a 0 oscili 0.1 , i freq outs a 0 , a 0 endin ; test simple case with optional pargs instr first a tstop \"second\" , 1 , - 1 , 0.5 a tstop \"second\" , 0.5 a tstop 200 endin instr second printf \"second! p4 = %f \\n \" , 1 , p4 turnoff endin instr 200 printf \"200! \\n \" , 1 turnoff endin instr StopPerformance exitnow endin </ CsInstruments > < CsScore > ; i 1 0 0.25 36 ; i 2 0 0.25 48 ; i 10 0 1 ; i \"StopPerformance\" 10 1 i \"first\" 1 0.5 f 0 5 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/atstop.html#see-also","text":"defer schedule event release xtratim","title":"See also"},{"location":"opcodes/atstop.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/crackle.html","text":"crackle Abstract generates noise based on a chaotic equation Description crackle is a chaotic generator, the sound is generated with the following equation y[n] = p * y[n-1]- y[n-2] - 0.05 Port of supercollider's Crackle Syntax aout crackle kp Arguments kp : the p parameter in the equation, a value between 1.0 and 2.0 Output aout : audio output of the chaotic generator Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* # This is the example file for the crackle opcode crackle is a port of supercollider's crackle (taken from pd/else) crackle is a chaotic noise generator based on the equation: y[n] = p * y[n-1] - y[n-2] - 0.05 ## Syntax aout crackle kp=0.5 * kp: value for p in the equation (default = 0.5) * aout: noise signal */ sr = 44100 ksmps = 64 0dbfs = 1 nchnls = 2 instr 1 k P [] fillarray 1.0 , 1.2 , 1.3 , 1.35 , 1.4 , 1.5 , 1.8 , 1.9 , 1.97 , 2.0 k idx = int ( line ( 0 , p3 , lenarray ( k P ))) k p = k P [ k idx ] printk2 k p a out crackle k p a out *= 0.5 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 15 </ CsScore > </ CsoundSynthesizer > See also standardchaos chuap dust2 Credits Eduardo Moguillansky, 2019","title":"crackle"},{"location":"opcodes/crackle.html#crackle","text":"","title":"crackle"},{"location":"opcodes/crackle.html#abstract","text":"generates noise based on a chaotic equation","title":"Abstract"},{"location":"opcodes/crackle.html#description","text":"crackle is a chaotic generator, the sound is generated with the following equation y[n] = p * y[n-1]- y[n-2] - 0.05 Port of supercollider's Crackle","title":"Description"},{"location":"opcodes/crackle.html#syntax","text":"aout crackle kp","title":"Syntax"},{"location":"opcodes/crackle.html#arguments","text":"kp : the p parameter in the equation, a value between 1.0 and 2.0","title":"Arguments"},{"location":"opcodes/crackle.html#output","text":"aout : audio output of the chaotic generator","title":"Output"},{"location":"opcodes/crackle.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/crackle.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* # This is the example file for the crackle opcode crackle is a port of supercollider's crackle (taken from pd/else) crackle is a chaotic noise generator based on the equation: y[n] = p * y[n-1] - y[n-2] - 0.05 ## Syntax aout crackle kp=0.5 * kp: value for p in the equation (default = 0.5) * aout: noise signal */ sr = 44100 ksmps = 64 0dbfs = 1 nchnls = 2 instr 1 k P [] fillarray 1.0 , 1.2 , 1.3 , 1.35 , 1.4 , 1.5 , 1.8 , 1.9 , 1.97 , 2.0 k idx = int ( line ( 0 , p3 , lenarray ( k P ))) k p = k P [ k idx ] printk2 k p a out crackle k p a out *= 0.5 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 15 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/crackle.html#see-also","text":"standardchaos chuap dust2","title":"See also"},{"location":"opcodes/crackle.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/defer.html","text":"defer Abstract Run an opcode at the end of current event Description defer runs an opcode as the last action of a given event, during the process of being deallocated. This can be used together with opcodes which release resources back which are being used during the event. At the moment defer works only with builtin opcodes. For complex release actions, it is nonetheless possible to bundle the actions in a separate instrument and use schedule together with defer (or simpler, use atstop instead). Release time vs deinit time The event is not scheduled at release time (see below \"Release time vs Deinit time\") but at the moment the note is freed. Release time is when the note is within its release phase , which will only happen if the note has an envelope with a release segment (like linsegr ), or if it has setup extra time with xtratim . The opcode release can be used to query if the current note is being released. The instrument keeps running in release phase as long as the release part of the envelope is finished or the extra time allocated via xtratim is through. Deinit time is the moment the note is actually being freed, so the instrument is not running anymore at this point. Syntax defer Sopcode, [arg1, arg2, ...] Any arguments passed after the name of the opcode (which must be within quotations) are passed directly to the opcode itself. Notice that only opcodes without output make sense in this context. Useful opcodes are print , prints , pool_push , dict_free , etc Note defer evaluates at init time but acts at deacllocation time. The arguments passed are evaluated at deallocation time Arguments Sopcode : the name of the opcode to defer args : any args (i, k, S) are passed to the opcodes. They are evaluated at deallocation time. Execution Time Init Deallocation Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; Example 1 instr 1 printk2 timeinsts () ;; this will be called at the end of this instrument defer \"event_i\" , \"i\" , 2 , 0 , 1 , 93 endin instr 2 print p4 turnoff endin instr example1 schedule 1 , 0 , 0.1 turnoff endin ;; ------------------------------------------- ;; Example 2 instr 10 i dict dict_new \"*sf\" , \"foo\" , 100 , \"bar\" , 200 ;; delete this key at the end of the note defer \"dict_set\" , i dict , \"foo\" dict_print i dict schedule 11 , 0.5 , 1 , i dict turnoff endin instr 11 printf \"Instr 11 \\n \" , 1 i dict = p4 ;; by now the dict should have deleted the key \"foo\" dict_print i dict turnoff endin instr example2 schedule 10 , 0 , 1 endin schedule \"example2\" , 0 , 0.1 </ CsInstruments > < CsScore > e 3 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also atstop schedule event release xtratim Credits Eduardo Moguillansky, 2019","title":"defer"},{"location":"opcodes/defer.html#defer","text":"","title":"defer"},{"location":"opcodes/defer.html#abstract","text":"Run an opcode at the end of current event","title":"Abstract"},{"location":"opcodes/defer.html#description","text":"defer runs an opcode as the last action of a given event, during the process of being deallocated. This can be used together with opcodes which release resources back which are being used during the event. At the moment defer works only with builtin opcodes. For complex release actions, it is nonetheless possible to bundle the actions in a separate instrument and use schedule together with defer (or simpler, use atstop instead). Release time vs deinit time The event is not scheduled at release time (see below \"Release time vs Deinit time\") but at the moment the note is freed. Release time is when the note is within its release phase , which will only happen if the note has an envelope with a release segment (like linsegr ), or if it has setup extra time with xtratim . The opcode release can be used to query if the current note is being released. The instrument keeps running in release phase as long as the release part of the envelope is finished or the extra time allocated via xtratim is through. Deinit time is the moment the note is actually being freed, so the instrument is not running anymore at this point.","title":"Description"},{"location":"opcodes/defer.html#syntax","text":"defer Sopcode, [arg1, arg2, ...] Any arguments passed after the name of the opcode (which must be within quotations) are passed directly to the opcode itself. Notice that only opcodes without output make sense in this context. Useful opcodes are print , prints , pool_push , dict_free , etc Note defer evaluates at init time but acts at deacllocation time. The arguments passed are evaluated at deallocation time","title":"Syntax"},{"location":"opcodes/defer.html#arguments","text":"Sopcode : the name of the opcode to defer args : any args (i, k, S) are passed to the opcodes. They are evaluated at deallocation time.","title":"Arguments"},{"location":"opcodes/defer.html#execution-time","text":"Init Deallocation","title":"Execution Time"},{"location":"opcodes/defer.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; Example 1 instr 1 printk2 timeinsts () ;; this will be called at the end of this instrument defer \"event_i\" , \"i\" , 2 , 0 , 1 , 93 endin instr 2 print p4 turnoff endin instr example1 schedule 1 , 0 , 0.1 turnoff endin ;; ------------------------------------------- ;; Example 2 instr 10 i dict dict_new \"*sf\" , \"foo\" , 100 , \"bar\" , 200 ;; delete this key at the end of the note defer \"dict_set\" , i dict , \"foo\" dict_print i dict schedule 11 , 0.5 , 1 , i dict turnoff endin instr 11 printf \"Instr 11 \\n \" , 1 i dict = p4 ;; by now the dict should have deleted the key \"foo\" dict_print i dict turnoff endin instr example2 schedule 10 , 0 , 1 endin schedule \"example2\" , 0 , 0.1 </ CsInstruments > < CsScore > e 3 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/defer.html#see-also","text":"atstop schedule event release xtratim","title":"See also"},{"location":"opcodes/defer.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/deref.html","text":"deref Abstract Dereference a previously created reference to a variable Description ref and deref implement a mechanism to pass a reference to any object, allowing to share a variable across instruments, with opcodes, etc. A reference is a proxy to an axisting variable / array. A reference is reference counted and deallocates itself when it falls out of scope without being referenced by any object. It makes it possible to pass arrays by reference to user defined opcodes, allowing to modify an array inplace, to skip copying memory, etc. With a reference it is possible also to control an event from another event. Syntax xArray deref iref xvar deref iref Arguments iref : a reference index as created via ref Output xArray / xvar : are created as a view of the object originally passed to ref Execution Time Init Examples < CsoundSynthesizer > < CsOptions > - m0 - d </ CsOptions > < CsInstruments > /* Example file for ref / deref */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gi A [] fillarray 0 , 1000 , 2000 , 3000 ; Example 1: take a ref from an array, deref it to create a second view of it instr 1 ; a source array i X [] fillarray 0 , 10 , 20 , 30 , 40 ; create a ref of iXs, return the index i ref ref i X ; now iYs points to iXs i Y [] deref i ref printarray i Y , \"\" , \"instrument 1, iY\" i Z [] fillarray 0 , 1 , 3 , 5 , 7 ; create a ref, pass it to instr. 2 schedule 2 , 0 , 1 , ref ( i Z ) ; create another ref of iZ. In this case the event is scheduled ; in the future, so the source will not exist anymore when instr. 2 ; is scheduled. This should fail. schedule 2 , 1 , 1 , ref ( i Z ) turnoff endin instr 2 i ref = p4 if refvalid ( i ref ) == 1 then i Zs [] deref i ref printarray i Zs , \"\" , \"p1=2, iZs\" else prints \" \\n >>> The reference has become invalid <<< \\n \" endif turnoff endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; Example 2: move semantics for arrays instr 3 ; create a source array k Xs [] fillarray 1 , 1 , 2 , 3 , 5 , 8 , 13 ; In order to bridge the time gap between the end of life of the source ; of a ref and the scheduled event where a deref is taken, it is possible ; to create a forward reference, a \"promise\" that one deref has been scheduled ; in the future. ; short lived event, ends before this event schedule 4 , 0 , 0.1 , ref ( k Xs ) ; starts before we end, but survives us schedule 4 , p3 - 0.1 , 0.2 , ref ( k Xs ) ; starts after we end, we need a move schedule 4 , p3 + 1 , 0.1 , ref ( k Xs , 1 ) defer \"prints\" , \" <<< instr. 3 finished >>> \\n \" endin instr 4 prints \"instr. 4 \\n \" k View [] deref p4 printarray k View defer \"prints\" , \" <<< instr. 4 finished >>> \\n \" ; At deinition time the memory of the `iView` array is marked as deallocated. ; The handle (a global structure created by the `ref` opcode) which owns the memory, ; is signaled that no other clients of this data are alive. It deallocates the ; original memory and frees itself endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; test: multiple derefs instr 5 i Xs [] fillarray 0 , 1 , 4 , 9 i ref ref i Xs i Ys [] deref i ref i Zs [] deref i ref printarray i Ys printarray i Zs i Xs [ 0 ] = 100 printarray i Zs turnoff endin ; test performance of pass-by-value vs pass-by-reference opcode arrayadd , i[] , i[]i ; pass by value in and out i In [], i x xin i Out [] = i In + i x xout i Out endop opcode arrayaddref , i[] , ii ; pass by ref in, by value out i ref , i x xin i In [] deref i ref i Out [] = i In + i x xout i Out endop opcode arrayadd_inplace , 0 , ii ; in place i ref , i x xin i In [] deref i ref i In += i x endop opcode arrayadd_byref_inout , 0 , iii ; pass by ref in and out i refin , i refout , i x xin i In [] deref i refin i Out [] deref i refout if lenarray ( i Out ) >= lenarray ( i In ) then i Out = i In + i x endif endop instr testUdoPerformance1 ; Here we test the performance gain of passing arrays by reference. ; Passing the input array by reference seems to produce a speedup of ~25%, i num = 100000 i Xs [] genarray 0 , i num i i = 0 i t0 rtclock while i i < 20 do i Ys [] arrayadd i Xs , 2.0 i i += 1 od i t1 rtclock prints \"Dur UDO pass by value = %.8f \\n \" , i t1 - i t0 i t0 rtclock i Ys [] arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i t1 rtclock prints \"Dur UDO pass by value unroll = %.8f \\n \" , i t1 - i t0 i ref = ref ( i Xs ) i t0 rtclock i Y0 [] arrayaddref i ref , 0.1 i Y0 arrayaddref i ref , 0.2 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i t1 rtclock prints \"Dur UDO pass by ref input = %.8f \\n \" , i t1 - i t0 i Zs [] genarray 0 , i num i Out [] init lenarray ( i Zs ) i t0 rtclock i refZ = ref ( i Zs ) i refOut = ref ( i Out ) arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 i t1 rtclock prints \"Dur UDO pass by ref in and out= %.8f \\n \" , i t1 - i t0 ; printarray iOut endin instr 7 i In [] genarray 0 , 1000 i Out [] init lenarray ( i In ) arrayadd_byref_inout ref ( i In ), ref ( i Out ), 0.5 turnoff endin instr 8 ; test / k arrays ; 1. A way to convert a i-array to a k-array by taking a reference i Xs [] genarray 0 , 99 k Xs [] deref ref ( i Xs ) k Xs [ 0 ] = timeinsts () printarray k Xs , metro ( 8 ) endin instr 9 ; we need genarray_i because otherwise kXs is not initialized at i-time k Xs [] genarray 0 , 9 i Xs [] deref ref ( k Xs ) i Xs += 10 printarray i Xs printarray k Xs turnoff endin ; schedule 1, 0, 1 ; schedule 3, 0, 1 ; schedule 5, 0, 0.1 schedule \"testUdoPerformance1\" , 0 , 0.1 ; schedule 8, 0, 4 </ CsInstruments > < CsScore > e 10 </ CsScore > </ CsoundSynthesizer > See also ref defer schedule event release Credits Eduardo Moguillansky, 2019","title":"deref"},{"location":"opcodes/deref.html#deref","text":"","title":"deref"},{"location":"opcodes/deref.html#abstract","text":"Dereference a previously created reference to a variable","title":"Abstract"},{"location":"opcodes/deref.html#description","text":"ref and deref implement a mechanism to pass a reference to any object, allowing to share a variable across instruments, with opcodes, etc. A reference is a proxy to an axisting variable / array. A reference is reference counted and deallocates itself when it falls out of scope without being referenced by any object. It makes it possible to pass arrays by reference to user defined opcodes, allowing to modify an array inplace, to skip copying memory, etc. With a reference it is possible also to control an event from another event.","title":"Description"},{"location":"opcodes/deref.html#syntax","text":"xArray deref iref xvar deref iref","title":"Syntax"},{"location":"opcodes/deref.html#arguments","text":"iref : a reference index as created via ref","title":"Arguments"},{"location":"opcodes/deref.html#output","text":"xArray / xvar : are created as a view of the object originally passed to ref","title":"Output"},{"location":"opcodes/deref.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/deref.html#examples","text":"< CsoundSynthesizer > < CsOptions > - m0 - d </ CsOptions > < CsInstruments > /* Example file for ref / deref */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gi A [] fillarray 0 , 1000 , 2000 , 3000 ; Example 1: take a ref from an array, deref it to create a second view of it instr 1 ; a source array i X [] fillarray 0 , 10 , 20 , 30 , 40 ; create a ref of iXs, return the index i ref ref i X ; now iYs points to iXs i Y [] deref i ref printarray i Y , \"\" , \"instrument 1, iY\" i Z [] fillarray 0 , 1 , 3 , 5 , 7 ; create a ref, pass it to instr. 2 schedule 2 , 0 , 1 , ref ( i Z ) ; create another ref of iZ. In this case the event is scheduled ; in the future, so the source will not exist anymore when instr. 2 ; is scheduled. This should fail. schedule 2 , 1 , 1 , ref ( i Z ) turnoff endin instr 2 i ref = p4 if refvalid ( i ref ) == 1 then i Zs [] deref i ref printarray i Zs , \"\" , \"p1=2, iZs\" else prints \" \\n >>> The reference has become invalid <<< \\n \" endif turnoff endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; Example 2: move semantics for arrays instr 3 ; create a source array k Xs [] fillarray 1 , 1 , 2 , 3 , 5 , 8 , 13 ; In order to bridge the time gap between the end of life of the source ; of a ref and the scheduled event where a deref is taken, it is possible ; to create a forward reference, a \"promise\" that one deref has been scheduled ; in the future. ; short lived event, ends before this event schedule 4 , 0 , 0.1 , ref ( k Xs ) ; starts before we end, but survives us schedule 4 , p3 - 0.1 , 0.2 , ref ( k Xs ) ; starts after we end, we need a move schedule 4 , p3 + 1 , 0.1 , ref ( k Xs , 1 ) defer \"prints\" , \" <<< instr. 3 finished >>> \\n \" endin instr 4 prints \"instr. 4 \\n \" k View [] deref p4 printarray k View defer \"prints\" , \" <<< instr. 4 finished >>> \\n \" ; At deinition time the memory of the `iView` array is marked as deallocated. ; The handle (a global structure created by the `ref` opcode) which owns the memory, ; is signaled that no other clients of this data are alive. It deallocates the ; original memory and frees itself endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; test: multiple derefs instr 5 i Xs [] fillarray 0 , 1 , 4 , 9 i ref ref i Xs i Ys [] deref i ref i Zs [] deref i ref printarray i Ys printarray i Zs i Xs [ 0 ] = 100 printarray i Zs turnoff endin ; test performance of pass-by-value vs pass-by-reference opcode arrayadd , i[] , i[]i ; pass by value in and out i In [], i x xin i Out [] = i In + i x xout i Out endop opcode arrayaddref , i[] , ii ; pass by ref in, by value out i ref , i x xin i In [] deref i ref i Out [] = i In + i x xout i Out endop opcode arrayadd_inplace , 0 , ii ; in place i ref , i x xin i In [] deref i ref i In += i x endop opcode arrayadd_byref_inout , 0 , iii ; pass by ref in and out i refin , i refout , i x xin i In [] deref i refin i Out [] deref i refout if lenarray ( i Out ) >= lenarray ( i In ) then i Out = i In + i x endif endop instr testUdoPerformance1 ; Here we test the performance gain of passing arrays by reference. ; Passing the input array by reference seems to produce a speedup of ~25%, i num = 100000 i Xs [] genarray 0 , i num i i = 0 i t0 rtclock while i i < 20 do i Ys [] arrayadd i Xs , 2.0 i i += 1 od i t1 rtclock prints \"Dur UDO pass by value = %.8f \\n \" , i t1 - i t0 i t0 rtclock i Ys [] arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i t1 rtclock prints \"Dur UDO pass by value unroll = %.8f \\n \" , i t1 - i t0 i ref = ref ( i Xs ) i t0 rtclock i Y0 [] arrayaddref i ref , 0.1 i Y0 arrayaddref i ref , 0.2 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i t1 rtclock prints \"Dur UDO pass by ref input = %.8f \\n \" , i t1 - i t0 i Zs [] genarray 0 , i num i Out [] init lenarray ( i Zs ) i t0 rtclock i refZ = ref ( i Zs ) i refOut = ref ( i Out ) arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 i t1 rtclock prints \"Dur UDO pass by ref in and out= %.8f \\n \" , i t1 - i t0 ; printarray iOut endin instr 7 i In [] genarray 0 , 1000 i Out [] init lenarray ( i In ) arrayadd_byref_inout ref ( i In ), ref ( i Out ), 0.5 turnoff endin instr 8 ; test / k arrays ; 1. A way to convert a i-array to a k-array by taking a reference i Xs [] genarray 0 , 99 k Xs [] deref ref ( i Xs ) k Xs [ 0 ] = timeinsts () printarray k Xs , metro ( 8 ) endin instr 9 ; we need genarray_i because otherwise kXs is not initialized at i-time k Xs [] genarray 0 , 9 i Xs [] deref ref ( k Xs ) i Xs += 10 printarray i Xs printarray k Xs turnoff endin ; schedule 1, 0, 1 ; schedule 3, 0, 1 ; schedule 5, 0, 0.1 schedule \"testUdoPerformance1\" , 0 , 0.1 ; schedule 8, 0, 4 </ CsInstruments > < CsScore > e 10 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/deref.html#see-also","text":"ref defer schedule event release","title":"See also"},{"location":"opcodes/deref.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_exists.html","text":"dict_exists Abstract Returns 1 if the dict exists, 0 otherwise Description dict_exists checks if the index passed refers to an existing dict and returns 1 if it does, 0 otherwise. It works at i-time only Syntax iexists dict_exists idict Arguments \u00ecdict : the handle of the dict, as returned by dict_new Output iexists : 1 of the dict exists, 0 otherwise Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for dict_exists iexists dict_exists idict */ opcode accum , k , ko k step , i val xin k now init i val xout k now k now += k step endop instr 1 i dict = p4 print i dict if ( dict_exists ( i dict ) == 1 ) then k foo dict_get i dict , \"foo\" k bar dict_get i dict , \"bar\" ; dict_free idict, 1 else k foo init 10 k bar init 20 endif printf \"$$$ foo= %f bar= %f \\n \" , accum ( changed ( k foo , k bar )), k foo , k bar endin instr 2 i dict dict_new \"*str:float\" , \"foo\" , 1 , \"bar\" , 2 schedule 1 , 0 , p3 , i dict dict_set i dict , \"foo\" , linseg : k ( 1 , p3 , 2 ) dict_set i dict , \"bar\" , linseg : k ( 2 , p3 , 3 ) endin instr 3 schedule 1 , 0 , p3 , - 1 endin </ CsInstruments > < CsScore > i 2 0 1 i 3 4 4 </ CsScore > </ CsoundSynthesizer > See also dict_iter dict_size dict_query Credits Eduardo Moguillansky, 2019","title":"dict_exists"},{"location":"opcodes/dict_exists.html#dict_exists","text":"","title":"dict_exists"},{"location":"opcodes/dict_exists.html#abstract","text":"Returns 1 if the dict exists, 0 otherwise","title":"Abstract"},{"location":"opcodes/dict_exists.html#description","text":"dict_exists checks if the index passed refers to an existing dict and returns 1 if it does, 0 otherwise. It works at i-time only","title":"Description"},{"location":"opcodes/dict_exists.html#syntax","text":"iexists dict_exists idict","title":"Syntax"},{"location":"opcodes/dict_exists.html#arguments","text":"\u00ecdict : the handle of the dict, as returned by dict_new","title":"Arguments"},{"location":"opcodes/dict_exists.html#output","text":"iexists : 1 of the dict exists, 0 otherwise","title":"Output"},{"location":"opcodes/dict_exists.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/dict_exists.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for dict_exists iexists dict_exists idict */ opcode accum , k , ko k step , i val xin k now init i val xout k now k now += k step endop instr 1 i dict = p4 print i dict if ( dict_exists ( i dict ) == 1 ) then k foo dict_get i dict , \"foo\" k bar dict_get i dict , \"bar\" ; dict_free idict, 1 else k foo init 10 k bar init 20 endif printf \"$$$ foo= %f bar= %f \\n \" , accum ( changed ( k foo , k bar )), k foo , k bar endin instr 2 i dict dict_new \"*str:float\" , \"foo\" , 1 , \"bar\" , 2 schedule 1 , 0 , p3 , i dict dict_set i dict , \"foo\" , linseg : k ( 1 , p3 , 2 ) dict_set i dict , \"bar\" , linseg : k ( 2 , p3 , 3 ) endin instr 3 schedule 1 , 0 , p3 , - 1 endin </ CsInstruments > < CsScore > i 2 0 1 i 3 4 4 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_exists.html#see-also","text":"dict_iter dict_size dict_query","title":"See also"},{"location":"opcodes/dict_exists.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_free.html","text":"dict_free Abstract Free a hashtable Description frees the hashtable either at init time or at the end of the note (similar to ftfree) A dict can only be freed if it was created as global (see dict_new ). To be able to pass a dict between notes, a note can create a global dict and pass its handle to another note. When the first note is released, the dict lives on (because it is global), and it will be either freed at the end of the performance or explicitely by calling dict_free dict_free executes only at init time . Syntax dict_free idict [, iwhen=0] Arguments idict : the handle of the dict to be freed iwhen : similar to ftfree if iwhen == 0 : free the dict now if iwhen == 1 : free the dict at the end of this note Execution Time Init Examples < CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > See also dict_new Credits Eduardo Moguillansky, 2019","title":"dict_free"},{"location":"opcodes/dict_free.html#dict_free","text":"","title":"dict_free"},{"location":"opcodes/dict_free.html#abstract","text":"Free a hashtable","title":"Abstract"},{"location":"opcodes/dict_free.html#description","text":"frees the hashtable either at init time or at the end of the note (similar to ftfree) A dict can only be freed if it was created as global (see dict_new ). To be able to pass a dict between notes, a note can create a global dict and pass its handle to another note. When the first note is released, the dict lives on (because it is global), and it will be either freed at the end of the performance or explicitely by calling dict_free dict_free executes only at init time .","title":"Description"},{"location":"opcodes/dict_free.html#syntax","text":"dict_free idict [, iwhen=0]","title":"Syntax"},{"location":"opcodes/dict_free.html#arguments","text":"idict : the handle of the dict to be freed iwhen : similar to ftfree if iwhen == 0 : free the dict now if iwhen == 1 : free the dict at the end of this note","title":"Arguments"},{"location":"opcodes/dict_free.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/dict_free.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_free.html#see-also","text":"dict_new","title":"See also"},{"location":"opcodes/dict_free.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_get.html","text":"dict_get Abstract Get a value from a hashtable Description A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_get returns the value for a given key. If the key is not present, a default value is returned (the empty string for string values, or an user given default for number values) Syntax kvalue dict_get idict, Skeym, idefault=0 kvalue dict_get idict, kkey, idefault=0 Svalue dict_get idict, Skey Svalue dict_get idict, kkey The type of key and value depend on the type definition of the dict , see dict_new dict_get executes both at i-time and k-time . Note In the case of a dict of type \"str:str\", dict_get returns an empty string if the key is not found Arguments \u00ecdict : the handle of the dict, as returned by dict_new Skey / kkey : the key to be queries, as previously set by dict_set idefault : if the key is not present, this value is returned (defaults to 0) Output kvalue / Svalue : the value corresponding to the key, or a default if the key is not found For dicts with a string value, an empty string is returned when the key is not found. For dicts with a numeric value, a user given default is returned (default=0) Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > < CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > /* # Example file for dict_get ## dict_get kvalue dict_get idict, \"key\" [, kdefault=0] Get the value at a given key. For string values, an empty string is returned when the key is not found. For int values, a default value given by the user is returned when the key is not found. */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve teh value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, mapping strings to strings i dict2 dict_new \"ss\" dict_set i dict2 , \"baz\" , \"bazvalue\" dict_set i dict2 , \"hoo\" , \"hoovalue\" S baz dict_get i dict2 , \"baz\" S hoo dict_get i dict2 , \"hoo\" printf \">>>> baz: %s , hoo: %s \\n \" , 1 , S baz , S hoo turnoff endin instr 2 ;; set and get if timeinstk () > 1 kgoto perf ;; this starts at 1 i maxcnt = 100 i dict dict_new \"ss\" k cnt = 0 while k cnt < i maxcnt do S key sprintfk \"key_ %d \" , k cnt S value sprintfk \"value_ %d \" , k cnt dict_set i dict , S key , S value k cnt += 1 od perf : k cnt = 0 while k cnt < i maxcnt do S key sprintfk \"key_ %d \" , k cnt ; the same for get, the key can change at k-time S value dict_get i dict , S key printf \"key: %s , value: %s \\n \" , k cnt , S key , S value k cnt += 1 od endin instr 3 /* dict_iter xkey, xvalue, kidx dict_iter ihandle [,kreset=1] kidx: holds the number of pairs yielded since last reset. It is set to -1 when iteration has stopped (in this case, xkey and xvalue are invalid and should not be used) kreset = 0 -> after iterating over all pairs iteration stops In this mode, iteration happens at most once 1 -> iteration starts over every k-cycle 2 -> iteration restarts after stopping */ k t timeinstk if k t > 1 kgoto perf i dict dict_new \"sf\" dict_set i dict , \"foo\" , 1 dict_set i dict , \"bar\" , 2 dict_set i dict , \"baz\" , 15 dict_set i dict , \"bee\" , 9 perf : ; iterate with a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"while) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value od ; the same but with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"loop) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value kgoto loop break : endin instr 4 ; test deleting a key ; ~~~~~~~~~~~~~~~~~~~ i dict dict_new \"ss\" ; set a key:value pair dict_set i dict , \"foo\" , \"foovalue\" ; get the value, print it S foo dict_get i dict , \"foo\" printf \"key: foo value: %s \\n \" , 1 , S foo ; dict_set without value deletes the key:value pair dict_set i dict , \"foo\" ; now check that the pair is gone S foo dict_get i dict , \"foo\" if ( strlen ( S foo ) == 0 ) then printf \"key does not exist \\n \" , 1 endif turnoff endin instr 5 ; dicts can be passed between instruments ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ if timeinstk () > 1 goto perf ; create a dict which survives this note i dict1 dict_new \"sf\" , 1 ; set some initial values once dict_set i dict1 , \"foo\" , 1 dict_set i dict1 , \"bar\" , 2 ; launch instr 6, which will outlive this note, pass idict as p4 event \"i\" , \"midifydict\" , 0 , p3 + 1 , i dict1 perf : k foo dict_get i dict1 , \"foo\" printk2 k foo endin instr modifydict ; here we modify instr 5's dictionary ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; the dict was created by instr 5 i dict = p4 k foo line 0 , p3 - 1 , 10 dict_set i dict , \"foo\" , k foo dict_free i dict , 1 ; 1 = free dict when note ends endin instr 7 ; it is possible to create a new dict and set initial ; values at once. This is only executed at i-time i dict dict_new \"sf\" , 0 , \"foo\" , 10 , \"bar\" , 20 , \"baz\" , 30 k baz dict_get i dict , \"baz\" k bar dict_get i dict , \"bar\" k xx dict_get i dict , \"xx\" , 99 printf \"baz: %f bar: %f xx: %f \\n \" , 1 , k baz , k bar , k xx turnoff endin instr 8 ; get all the keys as an array i dict1 dict_new \"sf\" , 0 , \"keyA\" , 1 , \"keyB\" , 2 , \"keyC\" , 3 S Keys [] dict_query i dict1 , \"keys\" printarray S Keys i dict2 dict_new \"if\" , 0 , 1 , 100 , 10 , 1000 , 2 , 200 k Keys [] dict_query i dict2 , \"keys\" printarray k Keys , 1 , \" %.0f \" ; get values as an array i dict3 dict_new \"is\" , 0 , 10 , \"foo\" , 20 , \"bar\" , 30 , \"baz\" S vals [] dict_query i dict3 , \"values\" printarray S vals k Vals [] dict_query i dict2 , \"values\" printarray k Vals turnoff endin ; One convenient use of dicts is to pass arguments to an instr instr 100 ; create our communication dict, set initial values i dict dict_new \"sf\" , \"amp\" , 0.1 , \"freq\" , 1000 ; the launched instr will last longer, so will have to deal with ; this dict ceasing to exist event_i \"i\" , 101 , 0 , p3 + 1 , i dict ; now we can control the synth with the dict dict_set i dict , \"freq\" , linseg : k ( 440 , p3 , 455 ) a 0 oscili 0.1 , 440 outch 1 , a 0 endin ; a variation on dict_get where we either get the value corresponding to a key, ; or the last value, if the dict does not exist opcode dict_receive , k , iSi i dict , S key , i val0 xin k last init i val0 if ( dict_size ( i dict ) > 0 ) then k val dict_get i dict , S key , i val0 k last = k val else k val = k last endif xout k val endop instr 101 i dict = p4 ; get the value for a given key. when the dict does not exist, just ; outputs the last value k amp dict_receive i dict , \"amp\" , 0.1 k freq dict_receive i dict , \"freq\" , 1000 a 0 oscili k amp , k freq outch 2 , a 0 endin instr 200 i dict dict_new \"str:any\" , \"foo\" , \"fooval\" , \"bar\" , 10 dict_print i dict S foo dict_get i dict , \"foo\" k bar dict_get i dict , \"bar\" printf \"foo= %s , bar= %f \\n \" , 1 , S foo , k bar dict_set i dict , \"baz\" , 0.5 i baz dict_get i dict , \"baz\" S moo = \"moo!\" dict_set i dict , \"moo\" , S moo printf \"baz= %f , moo= %s \\n \" , 1 , i baz , S moo turnoff endin </ CsInstruments > < CsScore > ; i 1 0 0.01 ; i 2 0 0.01 ; i 8 0 0.1 ; i 100 0 10 i 200 0 1 f 0 1 </ CsScore > </ CsoundSynthesizer > See also dict_new dict_set Credits Eduardo Moguillansky, 2019","title":"dict_get"},{"location":"opcodes/dict_get.html#dict_get","text":"","title":"dict_get"},{"location":"opcodes/dict_get.html#abstract","text":"Get a value from a hashtable","title":"Abstract"},{"location":"opcodes/dict_get.html#description","text":"A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_get returns the value for a given key. If the key is not present, a default value is returned (the empty string for string values, or an user given default for number values)","title":"Description"},{"location":"opcodes/dict_get.html#syntax","text":"kvalue dict_get idict, Skeym, idefault=0 kvalue dict_get idict, kkey, idefault=0 Svalue dict_get idict, Skey Svalue dict_get idict, kkey The type of key and value depend on the type definition of the dict , see dict_new dict_get executes both at i-time and k-time . Note In the case of a dict of type \"str:str\", dict_get returns an empty string if the key is not found","title":"Syntax"},{"location":"opcodes/dict_get.html#arguments","text":"\u00ecdict : the handle of the dict, as returned by dict_new Skey / kkey : the key to be queries, as previously set by dict_set idefault : if the key is not present, this value is returned (defaults to 0)","title":"Arguments"},{"location":"opcodes/dict_get.html#output","text":"kvalue / Svalue : the value corresponding to the key, or a default if the key is not found For dicts with a string value, an empty string is returned when the key is not found. For dicts with a numeric value, a user given default is returned (default=0)","title":"Output"},{"location":"opcodes/dict_get.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/dict_get.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > < CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > /* # Example file for dict_get ## dict_get kvalue dict_get idict, \"key\" [, kdefault=0] Get the value at a given key. For string values, an empty string is returned when the key is not found. For int values, a default value given by the user is returned when the key is not found. */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve teh value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, mapping strings to strings i dict2 dict_new \"ss\" dict_set i dict2 , \"baz\" , \"bazvalue\" dict_set i dict2 , \"hoo\" , \"hoovalue\" S baz dict_get i dict2 , \"baz\" S hoo dict_get i dict2 , \"hoo\" printf \">>>> baz: %s , hoo: %s \\n \" , 1 , S baz , S hoo turnoff endin instr 2 ;; set and get if timeinstk () > 1 kgoto perf ;; this starts at 1 i maxcnt = 100 i dict dict_new \"ss\" k cnt = 0 while k cnt < i maxcnt do S key sprintfk \"key_ %d \" , k cnt S value sprintfk \"value_ %d \" , k cnt dict_set i dict , S key , S value k cnt += 1 od perf : k cnt = 0 while k cnt < i maxcnt do S key sprintfk \"key_ %d \" , k cnt ; the same for get, the key can change at k-time S value dict_get i dict , S key printf \"key: %s , value: %s \\n \" , k cnt , S key , S value k cnt += 1 od endin instr 3 /* dict_iter xkey, xvalue, kidx dict_iter ihandle [,kreset=1] kidx: holds the number of pairs yielded since last reset. It is set to -1 when iteration has stopped (in this case, xkey and xvalue are invalid and should not be used) kreset = 0 -> after iterating over all pairs iteration stops In this mode, iteration happens at most once 1 -> iteration starts over every k-cycle 2 -> iteration restarts after stopping */ k t timeinstk if k t > 1 kgoto perf i dict dict_new \"sf\" dict_set i dict , \"foo\" , 1 dict_set i dict , \"bar\" , 2 dict_set i dict , \"baz\" , 15 dict_set i dict , \"bee\" , 9 perf : ; iterate with a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"while) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value od ; the same but with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"loop) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value kgoto loop break : endin instr 4 ; test deleting a key ; ~~~~~~~~~~~~~~~~~~~ i dict dict_new \"ss\" ; set a key:value pair dict_set i dict , \"foo\" , \"foovalue\" ; get the value, print it S foo dict_get i dict , \"foo\" printf \"key: foo value: %s \\n \" , 1 , S foo ; dict_set without value deletes the key:value pair dict_set i dict , \"foo\" ; now check that the pair is gone S foo dict_get i dict , \"foo\" if ( strlen ( S foo ) == 0 ) then printf \"key does not exist \\n \" , 1 endif turnoff endin instr 5 ; dicts can be passed between instruments ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ if timeinstk () > 1 goto perf ; create a dict which survives this note i dict1 dict_new \"sf\" , 1 ; set some initial values once dict_set i dict1 , \"foo\" , 1 dict_set i dict1 , \"bar\" , 2 ; launch instr 6, which will outlive this note, pass idict as p4 event \"i\" , \"midifydict\" , 0 , p3 + 1 , i dict1 perf : k foo dict_get i dict1 , \"foo\" printk2 k foo endin instr modifydict ; here we modify instr 5's dictionary ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; the dict was created by instr 5 i dict = p4 k foo line 0 , p3 - 1 , 10 dict_set i dict , \"foo\" , k foo dict_free i dict , 1 ; 1 = free dict when note ends endin instr 7 ; it is possible to create a new dict and set initial ; values at once. This is only executed at i-time i dict dict_new \"sf\" , 0 , \"foo\" , 10 , \"bar\" , 20 , \"baz\" , 30 k baz dict_get i dict , \"baz\" k bar dict_get i dict , \"bar\" k xx dict_get i dict , \"xx\" , 99 printf \"baz: %f bar: %f xx: %f \\n \" , 1 , k baz , k bar , k xx turnoff endin instr 8 ; get all the keys as an array i dict1 dict_new \"sf\" , 0 , \"keyA\" , 1 , \"keyB\" , 2 , \"keyC\" , 3 S Keys [] dict_query i dict1 , \"keys\" printarray S Keys i dict2 dict_new \"if\" , 0 , 1 , 100 , 10 , 1000 , 2 , 200 k Keys [] dict_query i dict2 , \"keys\" printarray k Keys , 1 , \" %.0f \" ; get values as an array i dict3 dict_new \"is\" , 0 , 10 , \"foo\" , 20 , \"bar\" , 30 , \"baz\" S vals [] dict_query i dict3 , \"values\" printarray S vals k Vals [] dict_query i dict2 , \"values\" printarray k Vals turnoff endin ; One convenient use of dicts is to pass arguments to an instr instr 100 ; create our communication dict, set initial values i dict dict_new \"sf\" , \"amp\" , 0.1 , \"freq\" , 1000 ; the launched instr will last longer, so will have to deal with ; this dict ceasing to exist event_i \"i\" , 101 , 0 , p3 + 1 , i dict ; now we can control the synth with the dict dict_set i dict , \"freq\" , linseg : k ( 440 , p3 , 455 ) a 0 oscili 0.1 , 440 outch 1 , a 0 endin ; a variation on dict_get where we either get the value corresponding to a key, ; or the last value, if the dict does not exist opcode dict_receive , k , iSi i dict , S key , i val0 xin k last init i val0 if ( dict_size ( i dict ) > 0 ) then k val dict_get i dict , S key , i val0 k last = k val else k val = k last endif xout k val endop instr 101 i dict = p4 ; get the value for a given key. when the dict does not exist, just ; outputs the last value k amp dict_receive i dict , \"amp\" , 0.1 k freq dict_receive i dict , \"freq\" , 1000 a 0 oscili k amp , k freq outch 2 , a 0 endin instr 200 i dict dict_new \"str:any\" , \"foo\" , \"fooval\" , \"bar\" , 10 dict_print i dict S foo dict_get i dict , \"foo\" k bar dict_get i dict , \"bar\" printf \"foo= %s , bar= %f \\n \" , 1 , S foo , k bar dict_set i dict , \"baz\" , 0.5 i baz dict_get i dict , \"baz\" S moo = \"moo!\" dict_set i dict , \"moo\" , S moo printf \"baz= %f , moo= %s \\n \" , 1 , i baz , S moo turnoff endin </ CsInstruments > < CsScore > ; i 1 0 0.01 ; i 2 0 0.01 ; i 8 0 0.1 ; i 100 0 10 i 200 0 1 f 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_get.html#see-also","text":"dict_new dict_set","title":"See also"},{"location":"opcodes/dict_get.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_iter.html","text":"dict_iter Abstract Iterate over the key-value pairs of a dict Description Iterates over the key:value pairs. Whenever kreset is 1, iteration starts over If kreset is -1 (the default), iteration is autotriggered when it reaches the end of the collection. dict_loop executes only at Performance Time . Note dict_iter is meant to be used in a loop at k-time Syntax xkey, xvalue, kidx dict_iter idict [, kreset = -1] Arguments idict : the handle to the dict as returned by dict_new kreset : the reset policy kreset effect 0 no reset, iteration stops at the end of the collection. There will be at most 1 iteration 1 (default) Iteration starts over at every k-cycle 2 Reset at the end of iteration (independent of k-cycle) Output xkey / xvalue : the key and value for this pair. The types are determined by the type of this dict, as defined via dict_new kidx : the index of this pair. It will be 0 for the first pair, 1 for the second, etc. When no more pairs, kidx will be -1. In this case, xkey and xvalue do not hold valid values Execution time Performance Usage There are two ways to use dict_iter , either in a while loop, or using gotos ; iterate in a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"key: %s value: %f \" , k idx , S key , k value od ; iterate with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"key: %s value: %f \" , k idx , S key , k value kgoto loop break : Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* # Example file for dict_iter opcode */ instr 1 /* dict_iter xkey, xvalue, kidx dict_iter ihandle [,kreset=1] kidx: holds the number of pairs yielded since last reset. It is set to -1 when iteration has stopped (in this case, xkey and xvalue are invalid and should not be used) kreset = 0 -> after iterating over all pairs iteration stops In this mode, iteration happens at most once 1 -> iteration starts over every k-cycle 2 -> iteration restarts after stopping */ i dict dict_new \"str:float\" , 0 , \"foo\" , 1 , \"bar\" , 2 , \"baz\" , 15 , \"bee\" , 9 k t timeinstk ; iterate with a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"while) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value od ; the same but with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"loop) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value kgoto loop break : endin </ CsInstruments > < CsScore > i 1 0 0.05 </ CsScore > </ CsoundSynthesizer > See also dict_new dict_size Credits Eduardo Moguillansky, 2019","title":"dict_iter"},{"location":"opcodes/dict_iter.html#dict_iter","text":"","title":"dict_iter"},{"location":"opcodes/dict_iter.html#abstract","text":"Iterate over the key-value pairs of a dict","title":"Abstract"},{"location":"opcodes/dict_iter.html#description","text":"Iterates over the key:value pairs. Whenever kreset is 1, iteration starts over If kreset is -1 (the default), iteration is autotriggered when it reaches the end of the collection. dict_loop executes only at Performance Time . Note dict_iter is meant to be used in a loop at k-time","title":"Description"},{"location":"opcodes/dict_iter.html#syntax","text":"xkey, xvalue, kidx dict_iter idict [, kreset = -1]","title":"Syntax"},{"location":"opcodes/dict_iter.html#arguments","text":"idict : the handle to the dict as returned by dict_new kreset : the reset policy kreset effect 0 no reset, iteration stops at the end of the collection. There will be at most 1 iteration 1 (default) Iteration starts over at every k-cycle 2 Reset at the end of iteration (independent of k-cycle)","title":"Arguments"},{"location":"opcodes/dict_iter.html#output","text":"xkey / xvalue : the key and value for this pair. The types are determined by the type of this dict, as defined via dict_new kidx : the index of this pair. It will be 0 for the first pair, 1 for the second, etc. When no more pairs, kidx will be -1. In this case, xkey and xvalue do not hold valid values","title":"Output"},{"location":"opcodes/dict_iter.html#execution-time","text":"Performance","title":"Execution time"},{"location":"opcodes/dict_iter.html#usage","text":"There are two ways to use dict_iter , either in a while loop, or using gotos ; iterate in a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"key: %s value: %f \" , k idx , S key , k value od ; iterate with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"key: %s value: %f \" , k idx , S key , k value kgoto loop break :","title":"Usage"},{"location":"opcodes/dict_iter.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* # Example file for dict_iter opcode */ instr 1 /* dict_iter xkey, xvalue, kidx dict_iter ihandle [,kreset=1] kidx: holds the number of pairs yielded since last reset. It is set to -1 when iteration has stopped (in this case, xkey and xvalue are invalid and should not be used) kreset = 0 -> after iterating over all pairs iteration stops In this mode, iteration happens at most once 1 -> iteration starts over every k-cycle 2 -> iteration restarts after stopping */ i dict dict_new \"str:float\" , 0 , \"foo\" , 1 , \"bar\" , 2 , \"baz\" , 15 , \"bee\" , 9 k t timeinstk ; iterate with a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"while) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value od ; the same but with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"loop) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value kgoto loop break : endin </ CsInstruments > < CsScore > i 1 0 0.05 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_iter.html#see-also","text":"dict_new dict_size","title":"See also"},{"location":"opcodes/dict_iter.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_new.html","text":"dict_new Abstract Create a hashtable Description A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. Local vs Global A hashtable can be either local , in which case its lifespan is fixed to the lifespan of the note it was created in; or it can be global , in which case it is not deallocated when the note is released and is kept alive until either the end of the performance, or until freed via dict_free dict_new runs only at i-time Syntax idict dict_new Stype idict dict_new Stype, key0, value0, key1, value1, ... Note With the second variant it is possible to create a dict and give it initial values at init-time. Types The types of a dict are fixed at creation time and are specified via the Stype argument. To declare a dict as global , prefix the type with a \"*\". type shortform as global key value str:float sf str:float or sf string float str:str ss str:str or ss string string int:float if int:float or if int float int:str is int:str or is int string str:any sa str:any or sa string any any type A dict of the form str:any accepts strings as keys and can have both strings and numbers as values. This can be used to pass arguments to an instrument like i args dict_new \"*sa\" , \"name\" , \"foo\" , \"freq\" , 1000 , \"amp\" , 0.5 schedule \"myinstr\" , 0 , - 1 , i args ; then, inside myinstr instr myinstr i args = p4 S name dict_get i args , \"name\" k freq dict_get i args , \"freq\" k amp dict_get i args , \"amp\" ; ... do something with this endin Arguments Stype : a string describing the type of the key and the value. See the table above. NB : to declare the dict as global, prepend the type string with a \"*\". key0 , value0 , key1 , value1 , etc: initial pairs can be set at creation time, matching the types declared with Stype Output idict : identifies this dict with an integer. This integer can be passed around to another instrument and will always resolve to the same dict, as long as this dict is still alive. This can be checked via dict_query idict, \"exists\" Execution Time Init Examples < CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"*str:str\" , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > See also dict_free dict_set Credits Eduardo Moguillansky, 2019","title":"dict_new"},{"location":"opcodes/dict_new.html#dict_new","text":"","title":"dict_new"},{"location":"opcodes/dict_new.html#abstract","text":"Create a hashtable","title":"Abstract"},{"location":"opcodes/dict_new.html#description","text":"A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats.","title":"Description"},{"location":"opcodes/dict_new.html#local-vs-global","text":"A hashtable can be either local , in which case its lifespan is fixed to the lifespan of the note it was created in; or it can be global , in which case it is not deallocated when the note is released and is kept alive until either the end of the performance, or until freed via dict_free dict_new runs only at i-time","title":"Local vs Global"},{"location":"opcodes/dict_new.html#syntax","text":"idict dict_new Stype idict dict_new Stype, key0, value0, key1, value1, ... Note With the second variant it is possible to create a dict and give it initial values at init-time.","title":"Syntax"},{"location":"opcodes/dict_new.html#types","text":"The types of a dict are fixed at creation time and are specified via the Stype argument. To declare a dict as global , prefix the type with a \"*\". type shortform as global key value str:float sf str:float or sf string float str:str ss str:str or ss string string int:float if int:float or if int float int:str is int:str or is int string str:any sa str:any or sa string any","title":"Types"},{"location":"opcodes/dict_new.html#any-type","text":"A dict of the form str:any accepts strings as keys and can have both strings and numbers as values. This can be used to pass arguments to an instrument like i args dict_new \"*sa\" , \"name\" , \"foo\" , \"freq\" , 1000 , \"amp\" , 0.5 schedule \"myinstr\" , 0 , - 1 , i args ; then, inside myinstr instr myinstr i args = p4 S name dict_get i args , \"name\" k freq dict_get i args , \"freq\" k amp dict_get i args , \"amp\" ; ... do something with this endin","title":"any type"},{"location":"opcodes/dict_new.html#arguments","text":"Stype : a string describing the type of the key and the value. See the table above. NB : to declare the dict as global, prepend the type string with a \"*\". key0 , value0 , key1 , value1 , etc: initial pairs can be set at creation time, matching the types declared with Stype","title":"Arguments"},{"location":"opcodes/dict_new.html#output","text":"idict : identifies this dict with an integer. This integer can be passed around to another instrument and will always resolve to the same dict, as long as this dict is still alive. This can be checked via dict_query idict, \"exists\"","title":"Output"},{"location":"opcodes/dict_new.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/dict_new.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"*str:str\" , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_new.html#see-also","text":"dict_free dict_set","title":"See also"},{"location":"opcodes/dict_new.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_print.html","text":"dict_print Abstract Prints the contents of a dict Description dict_print can be used to print the contents of a dict, mostly for debugging purposes dict_print can print both at i-time or k-time Syntax dict_print idict [, ktrig=1] Arguments \u00ecdict : the handle of the dict, as returned by dict_new ktrig : when to print the dict. Printing will take place whenever ktrig is -1 or if ktrig is a positive and higher than the last trig Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" , \"foo\" , 10 , \"bar\" , 20 , \"baz\" , 30 print_dict i dict , 1 ; print with a metro i dict2 dict_new \"ss\" , \"foo\" , \"foofoo\" , \"bar\" , \"barbar\" , \"baz\" , \"bazbaz\" k trig metro 2 print_dict i dict2 , k trig turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer > See also dict_iter dict_set dict_query Credits Eduardo Moguillansky, 2019","title":"dict_print"},{"location":"opcodes/dict_print.html#dict_print","text":"","title":"dict_print"},{"location":"opcodes/dict_print.html#abstract","text":"Prints the contents of a dict","title":"Abstract"},{"location":"opcodes/dict_print.html#description","text":"dict_print can be used to print the contents of a dict, mostly for debugging purposes dict_print can print both at i-time or k-time","title":"Description"},{"location":"opcodes/dict_print.html#syntax","text":"dict_print idict [, ktrig=1]","title":"Syntax"},{"location":"opcodes/dict_print.html#arguments","text":"\u00ecdict : the handle of the dict, as returned by dict_new ktrig : when to print the dict. Printing will take place whenever ktrig is -1 or if ktrig is a positive and higher than the last trig","title":"Arguments"},{"location":"opcodes/dict_print.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/dict_print.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" , \"foo\" , 10 , \"bar\" , 20 , \"baz\" , 30 print_dict i dict , 1 ; print with a metro i dict2 dict_new \"ss\" , \"foo\" , \"foofoo\" , \"bar\" , \"barbar\" , \"baz\" , \"bazbaz\" k trig metro 2 print_dict i dict2 , k trig turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_print.html#see-also","text":"dict_iter dict_set dict_query","title":"See also"},{"location":"opcodes/dict_print.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_query.html","text":"dict_query Abstract Query different properties of a dict Description Properties of a dict which do not need a separate opcode (because they are not used very frequently) are merged togehter in this opcode. Possible properties are: exists : return 1 if the handle points to a valid dict size : returns the size of this dict (similar to dict_size) type : returns an integer identifying the type of this dict 11 : number -> number 12 : number -> string 21 : string -> number 22 : string -> string keys : returns an array with all the keys defined in this dict (the type of the returned array depends on the type of the keys) values : returns an array with all the values (the type of the returned array depends on the type of the values). NB : the order in which keys and values are returned represents the corresponding pairs, so keys[i] and values[i] belong to the same pair. dict_query executes at k-time . Syntax kexists dict_query idict, \"exists\" ksize dict_query idict, \"size\" ktype dict_query idict, \"type\" SKeys[] dict_query idict, \"keys\" kKeys[] dict_query idict, \"keys\" kValues[] dict_query idict, \"values\" SValues[] dict_query idict, \"values\" Arguments idict : the handle of the dict, as returned by dict_new Output NB : the arrays returned from keys and values can have either an S- or a k-type, depending on the type definition of the array Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for dict_query ... dict_query idict, Scmd where Scmd can be: 'size', 'type', 'exists', 'keys', 'values' */ instr 1 ; get all the keys as an array i dict1 dict_new \"sf\" , 0 , \"keyA\" , 1 , \"keyB\" , 2 , \"keyC\" , 3 ; check that the dict exists k exists dict_query i dict1 , \"exists\" k type dict_query i dict1 , \"type\" printf \"dict exists = %d , type = %d \\n \" , 1 , k exists , k type S Keys [] dict_query i dict1 , \"keys\" printarray S Keys ; now check a bogus handle k exists999 dict_query 999 , \"exists\" printf \"dict 999 exists = %d \\n \" , 1 , k exists999 ; get the keys from a different dict i dict2 dict_new \"if\" , 0 , 1 , 100 , 10 , 1000 , 2 , 200 k Keys [] dict_query i dict2 , \"keys\" printarray k Keys , 1 , \" %.0f \" printf \"idict2 has size= %d \\n \" , 1 , dict_query ( i dict2 , \"size\" ) ; get values as an array i dict3 dict_new \"is\" , 0 , 10 , \"foo\" , 20 , \"bar\" , 30 , \"baz\" S vals [] dict_query i dict3 , \"values\" printarray S vals k Vals [] dict_query i dict2 , \"values\" printarray k Vals ; query the type of the dict k type dict_query i dict2 , \"type\" printf \"the type of dict %d is %d \\n \" , 1 , i dict2 , k type turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 </ CsScore > </ CsoundSynthesizer > See also dict_iter dict_size Credits Eduardo Moguillansky, 2019","title":"dict_query"},{"location":"opcodes/dict_query.html#dict_query","text":"","title":"dict_query"},{"location":"opcodes/dict_query.html#abstract","text":"Query different properties of a dict","title":"Abstract"},{"location":"opcodes/dict_query.html#description","text":"Properties of a dict which do not need a separate opcode (because they are not used very frequently) are merged togehter in this opcode. Possible properties are: exists : return 1 if the handle points to a valid dict size : returns the size of this dict (similar to dict_size) type : returns an integer identifying the type of this dict 11 : number -> number 12 : number -> string 21 : string -> number 22 : string -> string keys : returns an array with all the keys defined in this dict (the type of the returned array depends on the type of the keys) values : returns an array with all the values (the type of the returned array depends on the type of the values). NB : the order in which keys and values are returned represents the corresponding pairs, so keys[i] and values[i] belong to the same pair. dict_query executes at k-time .","title":"Description"},{"location":"opcodes/dict_query.html#syntax","text":"kexists dict_query idict, \"exists\" ksize dict_query idict, \"size\" ktype dict_query idict, \"type\" SKeys[] dict_query idict, \"keys\" kKeys[] dict_query idict, \"keys\" kValues[] dict_query idict, \"values\" SValues[] dict_query idict, \"values\"","title":"Syntax"},{"location":"opcodes/dict_query.html#arguments","text":"idict : the handle of the dict, as returned by dict_new","title":"Arguments"},{"location":"opcodes/dict_query.html#output","text":"NB : the arrays returned from keys and values can have either an S- or a k-type, depending on the type definition of the array","title":"Output"},{"location":"opcodes/dict_query.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/dict_query.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for dict_query ... dict_query idict, Scmd where Scmd can be: 'size', 'type', 'exists', 'keys', 'values' */ instr 1 ; get all the keys as an array i dict1 dict_new \"sf\" , 0 , \"keyA\" , 1 , \"keyB\" , 2 , \"keyC\" , 3 ; check that the dict exists k exists dict_query i dict1 , \"exists\" k type dict_query i dict1 , \"type\" printf \"dict exists = %d , type = %d \\n \" , 1 , k exists , k type S Keys [] dict_query i dict1 , \"keys\" printarray S Keys ; now check a bogus handle k exists999 dict_query 999 , \"exists\" printf \"dict 999 exists = %d \\n \" , 1 , k exists999 ; get the keys from a different dict i dict2 dict_new \"if\" , 0 , 1 , 100 , 10 , 1000 , 2 , 200 k Keys [] dict_query i dict2 , \"keys\" printarray k Keys , 1 , \" %.0f \" printf \"idict2 has size= %d \\n \" , 1 , dict_query ( i dict2 , \"size\" ) ; get values as an array i dict3 dict_new \"is\" , 0 , 10 , \"foo\" , 20 , \"bar\" , 30 , \"baz\" S vals [] dict_query i dict3 , \"values\" printarray S vals k Vals [] dict_query i dict2 , \"values\" printarray k Vals ; query the type of the dict k type dict_query i dict2 , \"type\" printf \"the type of dict %d is %d \\n \" , 1 , i dict2 , k type turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_query.html#see-also","text":"dict_iter dict_size","title":"See also"},{"location":"opcodes/dict_query.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_set.html","text":"dict_set Abstract Set (or remove) a value from a hashtable Description A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_set sets the value corresponding to a key if the key is already present, or inserts a key:value pair otherwise. NB : Without a value, dict_set deletes the key:value pair from the dict. dict_set executes can execute at i-time and k-time . Tip It is possible to set multiple values at i-time directly with dict_new Note If xvalue is not given, dict_set removes the key from the dict Syntax dict_set idict, xkey, xvalue dict_set idict, xkey Arguments idict : the handle of the dict, as returned by dict_new xkey : the key to set. Its type must match the type definition of the dict. (a string or a possitive integer) xvalue : the value to set. Its type must match the type definition of the dict (a str or a numeric value) Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"*str:str\" , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; Remove a key dict_set i dict2 , \"foo\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 print_dict i dict S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > < CsoundSynthesizer > < CsOptions > - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gi dict dict_new \"*sf\" opcode argset , 0 , iSk i p1 , S param , k value xin S key sprintf \" %.4f : %s \" , i p1 , S param dict_set gi dict , S key , k value endop opcode argget , k , Si S param , i default xin S key sprintf \" %.4f : %s \" , p1 , S param k out dict_get gi dict , S key , i default xout k out ;; delete key at end of event defer \"dict_set\" , gi dict , S param endop instr exit exitnow endin instr 1 i num uniqinstance 2 k freq = linseg ( random ( 4000 , 2000 ), p3 , random ( 300 , 350 )) argset i num , \"freq\" , k freq schedule i num , 0 , 3 k size dict_size gi dict printk2 k size a tstop p1 , 0 , p3 endin instr 2 k freq argget \"freq\" , 1000 a 0 oscili 0.02 , k freq a 0 *= linsegr : a ( 0 , 0.1 , 1 , 0.1 , 0 ) outs a 0 , a 0 endin instr example_dict schedule 1 , 0 , 0.01 schedule \"exit\" , 10 , 0.1 turnoff endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ instr 10 i num uniqinstance 11 , 10000 k freq = linseg ( 4000 , p3 , random ( 300 , 350 )) S chan = sprintf ( \" %f _freq\" , i num ) dict_set gi dict , S chan , k freq schedule i num , 0 , p3 endin instr 11 S key sprintf \" %f _freq\" , p1 printf \"p1= %.6f \\n \" , 1 , p1 k freq dict_get gi dict , S key , 1000 ;; delete key at end of event defer \"dict_set\" , gi dict , S key a 0 oscili 0.02 , k freq a 0 *= linsegr : a ( 0 , p3 * 0.1 , 1 , p3 * 0.9 , 0 ) outs a 0 , a 0 endin instr dictsize i size = dict_size : i ( gi dict ) print i size turnoff endin instr example2 i 0 = 0 i step = 0.01 i dur = 0.3 while i 0 < 10000 do schedule 10 , i 0 * i step , i dur i 0 += 1 print i 0 od i endtime = ( i 0 + 2 ) * i step + i dur schedule \"dictsize\" , i endtime - 0.005 , - 1 schedule \"exit\" , i endtime , - 1 turnoff endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ instr 20 i num uniqinstance 21 , 10000 k freq = linseg ( 4000 , p3 , random ( 300 , 350 )) S chan = sprintf ( \" %f _freq\" , i num ) ; printf \"%s \\n\", 1, Schan chnset k freq , S chan schedule i num , 0 , p3 endin instr 21 S key sprintf \" %f _freq\" , p1 printf \"p1= %.6f \\n \" , 1 , p1 k freq chnget S key a 0 oscili 0.02 , k freq a 0 *= linsegr : a ( 0 , p3 * 0.1 , 1 , p3 * 0.9 , 0 ) outs a 0 , a 0 endin instr example3 ; the same as example2 but with channels i 0 = 0 i step = 0. 01 i dur = 0.3 while i 0 < 10000 do schedule 20 , i 0 * i step , i dur i 0 += 1 print i 0 od schedule \"exit\" , ( i 0 + 1 ) * i step + i dur , - 1 turnoff endin ; schedule \"example_dict\", 0, 1 schedule \"example2\" , 0 , 1 ; schedule \"example3\", 0, 1 </ CsInstruments > e 10 < CsScore > </ CsScore > </ CsoundSynthesizer > See also dict_new dict_get defer dict_free Credits Eduardo Moguillansky, 2019","title":"dict_set"},{"location":"opcodes/dict_set.html#dict_set","text":"","title":"dict_set"},{"location":"opcodes/dict_set.html#abstract","text":"Set (or remove) a value from a hashtable","title":"Abstract"},{"location":"opcodes/dict_set.html#description","text":"A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_set sets the value corresponding to a key if the key is already present, or inserts a key:value pair otherwise. NB : Without a value, dict_set deletes the key:value pair from the dict. dict_set executes can execute at i-time and k-time . Tip It is possible to set multiple values at i-time directly with dict_new Note If xvalue is not given, dict_set removes the key from the dict","title":"Description"},{"location":"opcodes/dict_set.html#syntax","text":"dict_set idict, xkey, xvalue dict_set idict, xkey","title":"Syntax"},{"location":"opcodes/dict_set.html#arguments","text":"idict : the handle of the dict, as returned by dict_new xkey : the key to set. Its type must match the type definition of the dict. (a string or a possitive integer) xvalue : the value to set. Its type must match the type definition of the dict (a str or a numeric value)","title":"Arguments"},{"location":"opcodes/dict_set.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/dict_set.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"*str:str\" , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; Remove a key dict_set i dict2 , \"foo\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 print_dict i dict S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > < CsoundSynthesizer > < CsOptions > - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gi dict dict_new \"*sf\" opcode argset , 0 , iSk i p1 , S param , k value xin S key sprintf \" %.4f : %s \" , i p1 , S param dict_set gi dict , S key , k value endop opcode argget , k , Si S param , i default xin S key sprintf \" %.4f : %s \" , p1 , S param k out dict_get gi dict , S key , i default xout k out ;; delete key at end of event defer \"dict_set\" , gi dict , S param endop instr exit exitnow endin instr 1 i num uniqinstance 2 k freq = linseg ( random ( 4000 , 2000 ), p3 , random ( 300 , 350 )) argset i num , \"freq\" , k freq schedule i num , 0 , 3 k size dict_size gi dict printk2 k size a tstop p1 , 0 , p3 endin instr 2 k freq argget \"freq\" , 1000 a 0 oscili 0.02 , k freq a 0 *= linsegr : a ( 0 , 0.1 , 1 , 0.1 , 0 ) outs a 0 , a 0 endin instr example_dict schedule 1 , 0 , 0.01 schedule \"exit\" , 10 , 0.1 turnoff endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ instr 10 i num uniqinstance 11 , 10000 k freq = linseg ( 4000 , p3 , random ( 300 , 350 )) S chan = sprintf ( \" %f _freq\" , i num ) dict_set gi dict , S chan , k freq schedule i num , 0 , p3 endin instr 11 S key sprintf \" %f _freq\" , p1 printf \"p1= %.6f \\n \" , 1 , p1 k freq dict_get gi dict , S key , 1000 ;; delete key at end of event defer \"dict_set\" , gi dict , S key a 0 oscili 0.02 , k freq a 0 *= linsegr : a ( 0 , p3 * 0.1 , 1 , p3 * 0.9 , 0 ) outs a 0 , a 0 endin instr dictsize i size = dict_size : i ( gi dict ) print i size turnoff endin instr example2 i 0 = 0 i step = 0.01 i dur = 0.3 while i 0 < 10000 do schedule 10 , i 0 * i step , i dur i 0 += 1 print i 0 od i endtime = ( i 0 + 2 ) * i step + i dur schedule \"dictsize\" , i endtime - 0.005 , - 1 schedule \"exit\" , i endtime , - 1 turnoff endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ instr 20 i num uniqinstance 21 , 10000 k freq = linseg ( 4000 , p3 , random ( 300 , 350 )) S chan = sprintf ( \" %f _freq\" , i num ) ; printf \"%s \\n\", 1, Schan chnset k freq , S chan schedule i num , 0 , p3 endin instr 21 S key sprintf \" %f _freq\" , p1 printf \"p1= %.6f \\n \" , 1 , p1 k freq chnget S key a 0 oscili 0.02 , k freq a 0 *= linsegr : a ( 0 , p3 * 0.1 , 1 , p3 * 0.9 , 0 ) outs a 0 , a 0 endin instr example3 ; the same as example2 but with channels i 0 = 0 i step = 0. 01 i dur = 0.3 while i 0 < 10000 do schedule 20 , i 0 * i step , i dur i 0 += 1 print i 0 od schedule \"exit\" , ( i 0 + 1 ) * i step + i dur , - 1 turnoff endin ; schedule \"example_dict\", 0, 1 schedule \"example2\" , 0 , 1 ; schedule \"example3\", 0, 1 </ CsInstruments > e 10 < CsScore > </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_set.html#see-also","text":"dict_new dict_get defer dict_free","title":"See also"},{"location":"opcodes/dict_set.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_size.html","text":"dict_size Abstract Returns the number of key:value pairs in a dict Description A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_size returns the number of such key:value pairs inside a dict. If the handle passed does not point to a valid dict, dict_size returns -1. It is thus possible to use it to check that the passed handle is valid (similar to dict_query idict \"exists\" , see dict_query ) dict_size can be used together with dict_iter to iterate over the key:value pairs Syntax isize dict_size idict ksize dict_size idict dict_size executes both at i-time and k-time . Arguments \u00ecdict : the handle of the dict, as returned by dict_new Output ksize : the number of key:value pairs in the dict Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size dict_set i dict , \"foo\" , 4 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size ; size does not change now dict_set i dict , \"foo\" , 10 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size ; we delete a key, size is reduced dict_set i dict , \"foo\" k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer > See also dict_iter dict_set Credits Eduardo Moguillansky, 2019","title":"dict_size"},{"location":"opcodes/dict_size.html#dict_size","text":"","title":"dict_size"},{"location":"opcodes/dict_size.html#abstract","text":"Returns the number of key:value pairs in a dict","title":"Abstract"},{"location":"opcodes/dict_size.html#description","text":"A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_size returns the number of such key:value pairs inside a dict. If the handle passed does not point to a valid dict, dict_size returns -1. It is thus possible to use it to check that the passed handle is valid (similar to dict_query idict \"exists\" , see dict_query ) dict_size can be used together with dict_iter to iterate over the key:value pairs","title":"Description"},{"location":"opcodes/dict_size.html#syntax","text":"isize dict_size idict ksize dict_size idict dict_size executes both at i-time and k-time .","title":"Syntax"},{"location":"opcodes/dict_size.html#arguments","text":"\u00ecdict : the handle of the dict, as returned by dict_new","title":"Arguments"},{"location":"opcodes/dict_size.html#output","text":"ksize : the number of key:value pairs in the dict","title":"Output"},{"location":"opcodes/dict_size.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/dict_size.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size dict_set i dict , \"foo\" , 4 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size ; size does not change now dict_set i dict , \"foo\" , 10 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size ; we delete a key, size is reduced dict_set i dict , \"foo\" k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_size.html#see-also","text":"dict_iter dict_set","title":"See also"},{"location":"opcodes/dict_size.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/diode_ringmod.html","text":"diode_ringmod Abstract A ring modulator with optional non-linearities Description diode_ringmod is a ring modulator with optional non-linearities. It implements a built-in sinusoidal carrier signal. The carrier is passed through a diode simulation prior to being multiplied with the input. This signal passes through a feedback stage. Sinewave : Diode Rect ( abs ( x )* 2 - 0.2 ) : _ * Input : Feedback knonlinearities controls the amount of jitter in the carrier's freq and feedback amount. diode_ringmod is a port of Loser's ringmodulator jsfx plugin distributed with REAPER Syntax aout diode_ringmod ain, kfreq, kdiode=0, kfeedback=0, knonlinear=0, koversample=0 Arguments ain : the input signal kfreq : the carrier's frequency (a sine wave) kdiode : if 1, the carrier is passed through a diode rectification stage kfeedback : the amount of feedback (between 0 and 1, 0=no feedback) knonlinear : the amount of non linearities (between 0 and 1, 0=no non linearities) koversample : if 1, oversampling x 2 is performed Output aout : audio output of the ring modulator Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac - d - m0 -+ rtmidi = virtual - M0 </ CsOptions > < CsInstruments > /* This is the example file for diode_ringmod NB: diode_ringmod is a port of the jsfx plugin Loser/ringmodulator, which implements diode rectification and non linear behavior in the feedback path. aout diode_ringmode a1, kmodfreq, kdiode=1, kfeedback=0, knonlin=0.2, koversample=0 kmodfreq: frequency of the mod. signal kdiode: if 1, a diode rectification stage is applied to the mod. signal kfeedback: range is 0 to 1. knonlin: range 0 to 1, implements non-linearities in feedback and mod. freq (for the first case only, which used the builtin oscillator) koversample: if 1, 2x oversampling is used. */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ga Outs [] init 2 FLpanel \"dioderingmod\" , 443 , 360 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i __w , i __h , i __line = 300 , 30 , 60 i y , i __marginx = 30 , 30 i _v1 FLvalue \"\" , 50 , 30 , 333 , i y gk ModFrequency , i _s1 FLslider \"Mod Frequency (Hz)\" , 20.0 , 3000.0 , 0 , 3 , \\ i _v1 , i __w , i __h , i __marginx , i y i y += i __line i _v2 FLvalue \"\" , 50 , 30 , 333 , i y gk Diode , i _s2 FLslider \"Diode\" , 0.0 , 1.0 , 0 , 3 , \\ i _v2 , i __w , i __h , i __marginx , i y i y += i __line i _v3 FLvalue \"\" , 50 , 30 , 333 , i y gk Feedback , i _s3 FLslider \"Feedback\" , 0.0 , 1.0 , 0 , 3 , \\ i _v3 , i __w , i __h , i __marginx , i y i y += i __line i _v4 FLvalue \"\" , 50 , 30 , 333 , i y gk Nonlinearities , i _s4 FLslider \"Non-Linearities\" , 0.0 , 1.0 , 0 , 3 , \\ i _v4 , i __w , i __h , i __marginx , i y i y += i __line i _v5 FLvalue \"\" , 50 , 30 , 333 , i y gk Oversample , i _s5 FLslider \"Oversample (x2)\" , 0.0 , 1.0 , 0 , 3 , \\ i _v5 , i __w , i __h , i __marginx , i y FLpanelEnd FLrun FLsetVal_i 440.0 , i _s1 ; Mod Frequency (Hz) FLsetVal_i 0.0 , i _s2 ; Diode FLsetVal_i 0.0 , i _s3 ; Feedback FLsetVal_i 0.1 , i _s4 ; Non-Linearities FLsetVal_i 0.0 , i _s5 ; Oversample (x2); --- end ui massign 1 , 1 instr 1 i midinote notnum i freq mtof i midinote i vel1 ampmidi 127 i db bpf i vel1 , 0 , - 120 , 64 , - 20 , 90 , - 12 , 127 , 0 i amp = ampdb ( i db ) * 0.2 a sig vco2 i amp , i freq ; asig oscili iamp, ifreq a env adsr 0.01 , 0.1 , 0.8 , 0.2 a sig *= a env ga Outs [ 0 ] = ga Outs [ 0 ] + a sig endin instr 100 a 1 = ga Outs [ 0 ] a 2 diode_ringmod a 1 , gk ModFrequency , gk Diode , gk Feedback , gk Nonlinearities , gk Oversample outs a 2 , a 2 ga Outs [ 0 ] = 0 endin </ CsInstruments > < CsScore > i 100 0 3600 </ CsScore > </ CsoundSynthesizer > < bsbPanel > < label > Widgets </ label > < objectName /> < x > 100 </ x > < y > 100 </ y > < w idth > 320 </ w idth > < height > 240 </ height > < visible > true </ visible > < uuid /> < bgcolor mode = \"nobackground\" > < r > 255 </ r > < g > 255 </ g > < b > 255 </ b > </ bgcolor > </ bsbPanel > < bsbPresets > </ bsbPresets > See also hilbert Reference https://en.wikipedia.org/wiki/Ring_modulation Credits Eduardo Moguillansky, 2019","title":"diode_ringmod"},{"location":"opcodes/diode_ringmod.html#diode_ringmod","text":"","title":"diode_ringmod"},{"location":"opcodes/diode_ringmod.html#abstract","text":"A ring modulator with optional non-linearities","title":"Abstract"},{"location":"opcodes/diode_ringmod.html#description","text":"diode_ringmod is a ring modulator with optional non-linearities. It implements a built-in sinusoidal carrier signal. The carrier is passed through a diode simulation prior to being multiplied with the input. This signal passes through a feedback stage. Sinewave : Diode Rect ( abs ( x )* 2 - 0.2 ) : _ * Input : Feedback knonlinearities controls the amount of jitter in the carrier's freq and feedback amount. diode_ringmod is a port of Loser's ringmodulator jsfx plugin distributed with REAPER","title":"Description"},{"location":"opcodes/diode_ringmod.html#syntax","text":"aout diode_ringmod ain, kfreq, kdiode=0, kfeedback=0, knonlinear=0, koversample=0","title":"Syntax"},{"location":"opcodes/diode_ringmod.html#arguments","text":"ain : the input signal kfreq : the carrier's frequency (a sine wave) kdiode : if 1, the carrier is passed through a diode rectification stage kfeedback : the amount of feedback (between 0 and 1, 0=no feedback) knonlinear : the amount of non linearities (between 0 and 1, 0=no non linearities) koversample : if 1, oversampling x 2 is performed","title":"Arguments"},{"location":"opcodes/diode_ringmod.html#output","text":"aout : audio output of the ring modulator","title":"Output"},{"location":"opcodes/diode_ringmod.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/diode_ringmod.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac - d - m0 -+ rtmidi = virtual - M0 </ CsOptions > < CsInstruments > /* This is the example file for diode_ringmod NB: diode_ringmod is a port of the jsfx plugin Loser/ringmodulator, which implements diode rectification and non linear behavior in the feedback path. aout diode_ringmode a1, kmodfreq, kdiode=1, kfeedback=0, knonlin=0.2, koversample=0 kmodfreq: frequency of the mod. signal kdiode: if 1, a diode rectification stage is applied to the mod. signal kfeedback: range is 0 to 1. knonlin: range 0 to 1, implements non-linearities in feedback and mod. freq (for the first case only, which used the builtin oscillator) koversample: if 1, 2x oversampling is used. */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ga Outs [] init 2 FLpanel \"dioderingmod\" , 443 , 360 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i __w , i __h , i __line = 300 , 30 , 60 i y , i __marginx = 30 , 30 i _v1 FLvalue \"\" , 50 , 30 , 333 , i y gk ModFrequency , i _s1 FLslider \"Mod Frequency (Hz)\" , 20.0 , 3000.0 , 0 , 3 , \\ i _v1 , i __w , i __h , i __marginx , i y i y += i __line i _v2 FLvalue \"\" , 50 , 30 , 333 , i y gk Diode , i _s2 FLslider \"Diode\" , 0.0 , 1.0 , 0 , 3 , \\ i _v2 , i __w , i __h , i __marginx , i y i y += i __line i _v3 FLvalue \"\" , 50 , 30 , 333 , i y gk Feedback , i _s3 FLslider \"Feedback\" , 0.0 , 1.0 , 0 , 3 , \\ i _v3 , i __w , i __h , i __marginx , i y i y += i __line i _v4 FLvalue \"\" , 50 , 30 , 333 , i y gk Nonlinearities , i _s4 FLslider \"Non-Linearities\" , 0.0 , 1.0 , 0 , 3 , \\ i _v4 , i __w , i __h , i __marginx , i y i y += i __line i _v5 FLvalue \"\" , 50 , 30 , 333 , i y gk Oversample , i _s5 FLslider \"Oversample (x2)\" , 0.0 , 1.0 , 0 , 3 , \\ i _v5 , i __w , i __h , i __marginx , i y FLpanelEnd FLrun FLsetVal_i 440.0 , i _s1 ; Mod Frequency (Hz) FLsetVal_i 0.0 , i _s2 ; Diode FLsetVal_i 0.0 , i _s3 ; Feedback FLsetVal_i 0.1 , i _s4 ; Non-Linearities FLsetVal_i 0.0 , i _s5 ; Oversample (x2); --- end ui massign 1 , 1 instr 1 i midinote notnum i freq mtof i midinote i vel1 ampmidi 127 i db bpf i vel1 , 0 , - 120 , 64 , - 20 , 90 , - 12 , 127 , 0 i amp = ampdb ( i db ) * 0.2 a sig vco2 i amp , i freq ; asig oscili iamp, ifreq a env adsr 0.01 , 0.1 , 0.8 , 0.2 a sig *= a env ga Outs [ 0 ] = ga Outs [ 0 ] + a sig endin instr 100 a 1 = ga Outs [ 0 ] a 2 diode_ringmod a 1 , gk ModFrequency , gk Diode , gk Feedback , gk Nonlinearities , gk Oversample outs a 2 , a 2 ga Outs [ 0 ] = 0 endin </ CsInstruments > < CsScore > i 100 0 3600 </ CsScore > </ CsoundSynthesizer > < bsbPanel > < label > Widgets </ label > < objectName /> < x > 100 </ x > < y > 100 </ y > < w idth > 320 </ w idth > < height > 240 </ height > < visible > true </ visible > < uuid /> < bgcolor mode = \"nobackground\" > < r > 255 </ r > < g > 255 </ g > < b > 255 </ b > </ bgcolor > </ bsbPanel > < bsbPresets > </ bsbPresets >","title":"Examples"},{"location":"opcodes/diode_ringmod.html#see-also","text":"hilbert","title":"See also"},{"location":"opcodes/diode_ringmod.html#reference","text":"https://en.wikipedia.org/wiki/Ring_modulation","title":"Reference"},{"location":"opcodes/diode_ringmod.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/file_exists.html","text":"file_exists Abstract Returns 1 if a file exists and can be read Description file_exists checks if a given file path exists and returns 1 if it does, 0 otherwise. It doesn't check any search path of csound and does not expand any variables (like \"~\" in unix). Syntax iexists file_exists Spath Arguments Spath : the path to check Output iexists : 1 if the file exists, 0 otherwise Execution Time Init Examples < CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > /* Example file for file_exists file_exists returns 1 if a given path refers to an existing file */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 i exists f ile_exists \"file_exists.csd\" print i exists turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer > See also filevalid system Credits Eduardo Moguillansky, 2019","title":"file_exists"},{"location":"opcodes/file_exists.html#file_exists","text":"","title":"file_exists"},{"location":"opcodes/file_exists.html#abstract","text":"Returns 1 if a file exists and can be read","title":"Abstract"},{"location":"opcodes/file_exists.html#description","text":"file_exists checks if a given file path exists and returns 1 if it does, 0 otherwise. It doesn't check any search path of csound and does not expand any variables (like \"~\" in unix).","title":"Description"},{"location":"opcodes/file_exists.html#syntax","text":"iexists file_exists Spath","title":"Syntax"},{"location":"opcodes/file_exists.html#arguments","text":"Spath : the path to check","title":"Arguments"},{"location":"opcodes/file_exists.html#output","text":"iexists : 1 if the file exists, 0 otherwise","title":"Output"},{"location":"opcodes/file_exists.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/file_exists.html#examples","text":"< CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > /* Example file for file_exists file_exists returns 1 if a given path refers to an existing file */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 i exists f ile_exists \"file_exists.csd\" print i exists turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/file_exists.html#see-also","text":"filevalid system","title":"See also"},{"location":"opcodes/file_exists.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/frac2int.html","text":"frac2int Abstract Convert the fractional part of a number into an integer Description frac2int can be used to convert the fractional part of a number (as passed, for example, as p1 ) back to an integer. Syntax iInt frac2int iFloat, iMul kInt frac2int kFloat, kMul Arguments iFloat / kFloat : a number with a fractional part (for example, a fractional p1 ) iMul / kMul : the factor used to convert the initial integer into a fraction (see example) Output iInt / kInt : the integer value corresponding to the fractional part Note The integral part of the passed value is discarded i val = 10 + 123 / 1000 ; => 10.123 i val2 f rac2int i val , 1000 ; => 123 Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > instr 1 i num f rac2int 1.45 , 100 print i num turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also frac Credits Eduardo Moguillansky, 2019","title":"frac2int"},{"location":"opcodes/frac2int.html#frac2int","text":"","title":"frac2int"},{"location":"opcodes/frac2int.html#abstract","text":"Convert the fractional part of a number into an integer","title":"Abstract"},{"location":"opcodes/frac2int.html#description","text":"frac2int can be used to convert the fractional part of a number (as passed, for example, as p1 ) back to an integer.","title":"Description"},{"location":"opcodes/frac2int.html#syntax","text":"iInt frac2int iFloat, iMul kInt frac2int kFloat, kMul","title":"Syntax"},{"location":"opcodes/frac2int.html#arguments","text":"iFloat / kFloat : a number with a fractional part (for example, a fractional p1 ) iMul / kMul : the factor used to convert the initial integer into a fraction (see example)","title":"Arguments"},{"location":"opcodes/frac2int.html#output","text":"iInt / kInt : the integer value corresponding to the fractional part Note The integral part of the passed value is discarded i val = 10 + 123 / 1000 ; => 10.123 i val2 f rac2int i val , 1000 ; => 123","title":"Output"},{"location":"opcodes/frac2int.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/frac2int.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > instr 1 i num f rac2int 1.45 , 100 print i num turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/frac2int.html#see-also","text":"frac","title":"See also"},{"location":"opcodes/frac2int.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/jsfx.html","text":"jsfx Abstract Instantiates and runs a jsfx script Description jsfx allows to instantiate and run a jsfx audio plugin within csound. There are two ways to run a jsfx script in csound. The simplest way is implemented in this plugin, jsfx , which allows to compile and control a jsfx plugin in one opcode. As an alternative, it is also possible to decouple these actions, first compiling a script (see jsfx_new ) and then calling jsfx_setslider and jsfx_play . Afterwords, slider values can be read via jsfx_getslider Note jsfx is an audio programming language implemented pritarily as part of the DAW REAPER . It is a scriptiong language with a built-in jit compiler which translates it to machine code on the fly. It allows the user to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. Note A jsfx script has a certain number of audio input / output channels, and a series of \"sliders\", which are parameters operating at control rate. A script can also use these sliders to send control values, which can be read in csound via jsfx_getslider See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc. Syntax ihandle, aout1 [, aout2, ...] jsfx Spath, ain1 [, ain2, ...] [, id0, kval1, id1, kval2, ...] Arguments Spath : the path to the jsfx script. Either an absolute path, a relative path to the .csd file, or a filename alone, in which case it will be searched first in the current dir and in $SSDIR, if defined. ain1 , ain2 , etc: audio input channels. It is recommended that the number of input streams matches the number of channels expected in the plugin. If you pass less that the expected channels, the rest will be zeroed, and if passing more, only the number of audio channels expected by the plugin will actually be processed idx , kvalx : a jsfx script allows to define up to 64 control parameters, which are called slider s. Each slider has an idx (starting from 1) and a value. Here you can control as many sliders as you need. Each slider consists of a pair of values, an id (i- value) identifying the slider (this corresponds to the sliderx value in the jsfx script) and the value itself (a k- value) Output ihandle : a handle to the jsfx plugin created, which allows to operate on it later, for instance to read slider values via jsfx_getslider aout1 , aout2 : audio output channels. It is recommended that the number of output streams matches the number of channels expected in the plugin. If you pass less that the expected channels, the rest will be zeroed, and if passing more, only the number of audio channels expected by the plugin will actually be processed Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for jsfx opcode gi snd ftgen 0 , 0 , 0 , - 1 , \"bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i h , a 1 jsfx \"tubeharmonics.jsfx\" , a sig , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out if gk dump == 1 then jsfx_dump i h , metro ( 4 ) endif outs a 1 , a 1 endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer > See also jsfx_new jsfx_play jsfx_setslider jsfx_getslider Credits Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"jsfx"},{"location":"opcodes/jsfx.html#jsfx","text":"","title":"jsfx"},{"location":"opcodes/jsfx.html#abstract","text":"Instantiates and runs a jsfx script","title":"Abstract"},{"location":"opcodes/jsfx.html#description","text":"jsfx allows to instantiate and run a jsfx audio plugin within csound. There are two ways to run a jsfx script in csound. The simplest way is implemented in this plugin, jsfx , which allows to compile and control a jsfx plugin in one opcode. As an alternative, it is also possible to decouple these actions, first compiling a script (see jsfx_new ) and then calling jsfx_setslider and jsfx_play . Afterwords, slider values can be read via jsfx_getslider Note jsfx is an audio programming language implemented pritarily as part of the DAW REAPER . It is a scriptiong language with a built-in jit compiler which translates it to machine code on the fly. It allows the user to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. Note A jsfx script has a certain number of audio input / output channels, and a series of \"sliders\", which are parameters operating at control rate. A script can also use these sliders to send control values, which can be read in csound via jsfx_getslider See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc.","title":"Description"},{"location":"opcodes/jsfx.html#syntax","text":"ihandle, aout1 [, aout2, ...] jsfx Spath, ain1 [, ain2, ...] [, id0, kval1, id1, kval2, ...]","title":"Syntax"},{"location":"opcodes/jsfx.html#arguments","text":"Spath : the path to the jsfx script. Either an absolute path, a relative path to the .csd file, or a filename alone, in which case it will be searched first in the current dir and in $SSDIR, if defined. ain1 , ain2 , etc: audio input channels. It is recommended that the number of input streams matches the number of channels expected in the plugin. If you pass less that the expected channels, the rest will be zeroed, and if passing more, only the number of audio channels expected by the plugin will actually be processed idx , kvalx : a jsfx script allows to define up to 64 control parameters, which are called slider s. Each slider has an idx (starting from 1) and a value. Here you can control as many sliders as you need. Each slider consists of a pair of values, an id (i- value) identifying the slider (this corresponds to the sliderx value in the jsfx script) and the value itself (a k- value)","title":"Arguments"},{"location":"opcodes/jsfx.html#output","text":"ihandle : a handle to the jsfx plugin created, which allows to operate on it later, for instance to read slider values via jsfx_getslider aout1 , aout2 : audio output channels. It is recommended that the number of output streams matches the number of channels expected in the plugin. If you pass less that the expected channels, the rest will be zeroed, and if passing more, only the number of audio channels expected by the plugin will actually be processed","title":"Output"},{"location":"opcodes/jsfx.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/jsfx.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for jsfx opcode gi snd ftgen 0 , 0 , 0 , - 1 , \"bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i h , a 1 jsfx \"tubeharmonics.jsfx\" , a sig , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out if gk dump == 1 then jsfx_dump i h , metro ( 4 ) endif outs a 1 , a 1 endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/jsfx.html#see-also","text":"jsfx_new jsfx_play jsfx_setslider jsfx_getslider","title":"See also"},{"location":"opcodes/jsfx.html#credits","text":"Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"Credits"},{"location":"opcodes/jsfx_getslider.html","text":"jsfx_setslider Abstract Gets a slider value of a jsfx instance Description With jsfx_getslider it is possible to get the current values of any slider defined in a jsfx script, mostly after calling jsfx or jsfx_play . A jsfx plugin defines a series of up to 64 sliders, which are control parameters used by the script. A slider can also be used to output values to the caller, for example to indicate the gain reduction in a compressor plugin, or the frequency in a pitch tracking plugin. A slider definition in a jsfx script has the form: slider7 : 0 < 0 , 20 , 0.01 > Gain Reduction This defines a control parameter with default value 0 , between 0 and 20 , with a precission (an increment) of 0.01 and a label \"Gain Reduction\". To read the value of that slider: kgainreduction = jsfx_getslider(ihandle, 7) Note Any slider which is not set via jsfx_setslider retains its default value. A value will always be confined to the range in the slider definition and will also be quantized to the increment in the slider definition. To disable any quantization, set the increment to 0 in the jsfx script Note jsfx is an audio programming language implemented primarily as part of the DAW REAPER . It is a scripting language with a built-in compiler which translates it to machine code. It allows to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc. Syntax kvalue jsfx_getslider ihandle, kid Arguments ihandle : the handle created via jsfx_new or jsfx kidx : the slider number (this corresponds to the sliderx value in the jsfx script) Output kvalue : value of the slider Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for the opcodes jsfx_new, jsfx_play and jsfx_setslider gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i handle jsfx_new \"tubeharmonics.jsfx\" print i handle jsfx_setslider i handle , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out a out jsfx_play i handle , a sig if gk dump == 1 then jsfx_dump i handle , metro ( 4 ) endif k 7 jsfx_getslider i handle , 7 printf \"k7: %f \\r \" , changed2 ( k 7 ), k 7 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer > See also jsfx jsfx_new jsfx_play jsfx_setslider Credits Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"jsfx_setslider"},{"location":"opcodes/jsfx_getslider.html#jsfx_setslider","text":"","title":"jsfx_setslider"},{"location":"opcodes/jsfx_getslider.html#abstract","text":"Gets a slider value of a jsfx instance","title":"Abstract"},{"location":"opcodes/jsfx_getslider.html#description","text":"With jsfx_getslider it is possible to get the current values of any slider defined in a jsfx script, mostly after calling jsfx or jsfx_play . A jsfx plugin defines a series of up to 64 sliders, which are control parameters used by the script. A slider can also be used to output values to the caller, for example to indicate the gain reduction in a compressor plugin, or the frequency in a pitch tracking plugin. A slider definition in a jsfx script has the form: slider7 : 0 < 0 , 20 , 0.01 > Gain Reduction This defines a control parameter with default value 0 , between 0 and 20 , with a precission (an increment) of 0.01 and a label \"Gain Reduction\". To read the value of that slider: kgainreduction = jsfx_getslider(ihandle, 7) Note Any slider which is not set via jsfx_setslider retains its default value. A value will always be confined to the range in the slider definition and will also be quantized to the increment in the slider definition. To disable any quantization, set the increment to 0 in the jsfx script Note jsfx is an audio programming language implemented primarily as part of the DAW REAPER . It is a scripting language with a built-in compiler which translates it to machine code. It allows to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc.","title":"Description"},{"location":"opcodes/jsfx_getslider.html#syntax","text":"kvalue jsfx_getslider ihandle, kid","title":"Syntax"},{"location":"opcodes/jsfx_getslider.html#arguments","text":"ihandle : the handle created via jsfx_new or jsfx kidx : the slider number (this corresponds to the sliderx value in the jsfx script)","title":"Arguments"},{"location":"opcodes/jsfx_getslider.html#output","text":"kvalue : value of the slider","title":"Output"},{"location":"opcodes/jsfx_getslider.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/jsfx_getslider.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for the opcodes jsfx_new, jsfx_play and jsfx_setslider gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i handle jsfx_new \"tubeharmonics.jsfx\" print i handle jsfx_setslider i handle , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out a out jsfx_play i handle , a sig if gk dump == 1 then jsfx_dump i handle , metro ( 4 ) endif k 7 jsfx_getslider i handle , 7 printf \"k7: %f \\r \" , changed2 ( k 7 ), k 7 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/jsfx_getslider.html#see-also","text":"jsfx jsfx_new jsfx_play jsfx_setslider","title":"See also"},{"location":"opcodes/jsfx_getslider.html#credits","text":"Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"Credits"},{"location":"opcodes/jsfx_new.html","text":"jsfx_new Abstract Instantiates a jsfx script Description jsfx_new instantiates and compiles a jsfx script (at init time). It returns a handle which can be used to modify control values and perform audio io. It is also possible to instantiate and play a script with only one opcode via jsfx . Note jsfx is an audio programming language implemented pritarily as part of the DAW REAPER . It is a scriptiong language with a built-in jit compiler which translates it to machine code on the fly. It allows the user to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. !!! Note jsfx input / output A jsfx script has a certain number of audio input / output channels, and a series of \"sliders\", which are parameters operating at control rate. A script can also use these sliders to send control values, which can be read in csound via [jsfx_getslider] See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc. Syntax ihandle jsfx_new Spath Arguments Spath : the path to the jsfx script. Either an absolute path, a relative path to the .csd file, or a filename alone, in which case it will be searched first in the current dir and in $SSDIR, if defined. Output ihandle : a handle to the jsfx plugin created, which allows to operate on it later, for instance to perform audio io via jsfx_play Execution Time Init Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for the opcodes jsfx_new, jsfx_play and jsfx_setslider gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i handle jsfx_new \"tubeharmonics.jsfx\" print i handle jsfx_setslider i handle , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out a out jsfx_play i handle , a sig if gk dump == 1 then jsfx_dump i handle , metro ( 4 ) endif k 7 jsfx_getslider i handle , 7 printf \"k7: %f \\r \" , changed2 ( k 7 ), k 7 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer > See also jsfx jsfx_play jsfx_setslider jsfx_getslider Credits Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"jsfx_new"},{"location":"opcodes/jsfx_new.html#jsfx_new","text":"","title":"jsfx_new"},{"location":"opcodes/jsfx_new.html#abstract","text":"Instantiates a jsfx script","title":"Abstract"},{"location":"opcodes/jsfx_new.html#description","text":"jsfx_new instantiates and compiles a jsfx script (at init time). It returns a handle which can be used to modify control values and perform audio io. It is also possible to instantiate and play a script with only one opcode via jsfx . Note jsfx is an audio programming language implemented pritarily as part of the DAW REAPER . It is a scriptiong language with a built-in jit compiler which translates it to machine code on the fly. It allows the user to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. !!! Note jsfx input / output A jsfx script has a certain number of audio input / output channels, and a series of \"sliders\", which are parameters operating at control rate. A script can also use these sliders to send control values, which can be read in csound via [jsfx_getslider] See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc.","title":"Description"},{"location":"opcodes/jsfx_new.html#syntax","text":"ihandle jsfx_new Spath","title":"Syntax"},{"location":"opcodes/jsfx_new.html#arguments","text":"Spath : the path to the jsfx script. Either an absolute path, a relative path to the .csd file, or a filename alone, in which case it will be searched first in the current dir and in $SSDIR, if defined.","title":"Arguments"},{"location":"opcodes/jsfx_new.html#output","text":"ihandle : a handle to the jsfx plugin created, which allows to operate on it later, for instance to perform audio io via jsfx_play","title":"Output"},{"location":"opcodes/jsfx_new.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/jsfx_new.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for the opcodes jsfx_new, jsfx_play and jsfx_setslider gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i handle jsfx_new \"tubeharmonics.jsfx\" print i handle jsfx_setslider i handle , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out a out jsfx_play i handle , a sig if gk dump == 1 then jsfx_dump i handle , metro ( 4 ) endif k 7 jsfx_getslider i handle , 7 printf \"k7: %f \\r \" , changed2 ( k 7 ), k 7 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/jsfx_new.html#see-also","text":"jsfx jsfx_play jsfx_setslider jsfx_getslider","title":"See also"},{"location":"opcodes/jsfx_new.html#credits","text":"Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"Credits"},{"location":"opcodes/jsfx_play.html","text":"jsfx_play Abstract Processes audio through a jsfx script Description jsfx_play calls the actual sample processing code defined in a jsfx script. The script must have been initialized via jsfx_new , which instantiates and compiles the script and returns a handle. Note jsfx is an audio programming language implemented primarily as part of the DAW REAPER . It is a scriptiong language with a built-in compiler which translates it to machine code on the fly. It allows the user to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. !!! Note jsfx input / output A jsfx script has a certain number of audio input / output channels. The number of audio inputs / outputs passed to the script does not need to match the number of channels defined in the script but it is advised to do so. More precisely, if a plugin is stereo, passing only one channel will not reduce the work performed by the plugin. A plugin also defines a series of \"sliders\", which are parameters operating at control rate. A script can also use these sliders to send control values back, which can be read in csound via [jsfx_getslider] See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc. Syntax a1 [, a2, a3, ...] jsfx_play ihandle, ain1 [, ain2, ain3, ...] Arguments ain1 , ain2 , ...: the audio signals passed as input. The amount of channels processed is min(expected number of streams, given number of streams) Output a1 , a2 , ...: the output audio generated by the plugin Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for the opcodes jsfx_new, jsfx_play and jsfx_setslider gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i handle jsfx_new \"tubeharmonics.jsfx\" print i handle jsfx_setslider i handle , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out a out jsfx_play i handle , a sig if gk dump == 1 then jsfx_dump i handle , metro ( 4 ) endif k 7 jsfx_getslider i handle , 7 printf \"k7: %f \\r \" , changed2 ( k 7 ), k 7 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer > See also jsfx_new jsfx_setslider jsfx_getslider Credits Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"jsfx_play"},{"location":"opcodes/jsfx_play.html#jsfx_play","text":"","title":"jsfx_play"},{"location":"opcodes/jsfx_play.html#abstract","text":"Processes audio through a jsfx script","title":"Abstract"},{"location":"opcodes/jsfx_play.html#description","text":"jsfx_play calls the actual sample processing code defined in a jsfx script. The script must have been initialized via jsfx_new , which instantiates and compiles the script and returns a handle. Note jsfx is an audio programming language implemented primarily as part of the DAW REAPER . It is a scriptiong language with a built-in compiler which translates it to machine code on the fly. It allows the user to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. !!! Note jsfx input / output A jsfx script has a certain number of audio input / output channels. The number of audio inputs / outputs passed to the script does not need to match the number of channels defined in the script but it is advised to do so. More precisely, if a plugin is stereo, passing only one channel will not reduce the work performed by the plugin. A plugin also defines a series of \"sliders\", which are parameters operating at control rate. A script can also use these sliders to send control values back, which can be read in csound via [jsfx_getslider] See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc.","title":"Description"},{"location":"opcodes/jsfx_play.html#syntax","text":"a1 [, a2, a3, ...] jsfx_play ihandle, ain1 [, ain2, ain3, ...]","title":"Syntax"},{"location":"opcodes/jsfx_play.html#arguments","text":"ain1 , ain2 , ...: the audio signals passed as input. The amount of channels processed is min(expected number of streams, given number of streams)","title":"Arguments"},{"location":"opcodes/jsfx_play.html#output","text":"a1 , a2 , ...: the output audio generated by the plugin","title":"Output"},{"location":"opcodes/jsfx_play.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/jsfx_play.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for the opcodes jsfx_new, jsfx_play and jsfx_setslider gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i handle jsfx_new \"tubeharmonics.jsfx\" print i handle jsfx_setslider i handle , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out a out jsfx_play i handle , a sig if gk dump == 1 then jsfx_dump i handle , metro ( 4 ) endif k 7 jsfx_getslider i handle , 7 printf \"k7: %f \\r \" , changed2 ( k 7 ), k 7 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/jsfx_play.html#see-also","text":"jsfx_new jsfx_setslider jsfx_getslider","title":"See also"},{"location":"opcodes/jsfx_play.html#credits","text":"Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"Credits"},{"location":"opcodes/jsfx_setslider.html","text":"jsfx_setslider Abstract Sets the slider values of a jsfx script Description With jsfx_setslider it is possible to set the values of any number of sliders defined in a jsfx script, mostly prior to calling jsfx_play . A jsfx plugin defines a series of up to 64 sliders, which are control parameters used by the script. A slider definition in a jsfx script has the form: slider3 : 1.5 < 0 , 4 , 0.01 > Compression Ratio This defines a control parameter with default value 1.5 , between 0 and 4 , with a precission (an increment) of 0.01 and a label \"Copression Ratio\". kcomprat = 2.5 jsfx_setslider ihandle, 3, kcomprat The code above will set the slider #3 (the index passed corresponds with the slider number) to the value of kcomprat The value of any slider can be read via jsfx_getvalue (only one value at a time). Note It is possible to call jsfx_setslider with any number of sliders. It is not necessary to set all the sliders defined in the script. Any slider which is not set via jsfx_setslider retains its default value. A value will always be confined to the range in the slider definition and will also be quantized to the increment in the slider definition. To disable any quantization, set the increment to 0 in the jsfx script Note jsfx is an audio programming language implemented primarily as part of the DAW REAPER . It is a scriptiong language with a built-in compiler which translates it to machine code. It allows the user to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc. Syntax jsfx_setslider ihandle, id1, kval1 [, id2, kval2, id3, kval3, ...] Arguments ihandle : the handle created via jsfx_new or jsfx idx , kvalx : a jsfx script allows to define up to 64 control parameters, which are called slider s. Each slider has an idx (starting from 1) and a value. Here you can control as many sliders as you need. Each slider consists of a pair of values, an id identifying the slider (this corresponds to the sliderx value in the jsfx script) and the value itself (a k- value) Output Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for the opcodes jsfx_new, jsfx_play and jsfx_setslider gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i handle jsfx_new \"tubeharmonics.jsfx\" print i handle jsfx_setslider i handle , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out a out jsfx_play i handle , a sig if gk dump == 1 then jsfx_dump i handle , metro ( 4 ) endif k 7 jsfx_getslider i handle , 7 printf \"k7: %f \\r \" , changed2 ( k 7 ), k 7 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer > See also jsfx jsfx_new jsfx_play jsfx_getslider Credits Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"jsfx_setslider"},{"location":"opcodes/jsfx_setslider.html#jsfx_setslider","text":"","title":"jsfx_setslider"},{"location":"opcodes/jsfx_setslider.html#abstract","text":"Sets the slider values of a jsfx script","title":"Abstract"},{"location":"opcodes/jsfx_setslider.html#description","text":"With jsfx_setslider it is possible to set the values of any number of sliders defined in a jsfx script, mostly prior to calling jsfx_play . A jsfx plugin defines a series of up to 64 sliders, which are control parameters used by the script. A slider definition in a jsfx script has the form: slider3 : 1.5 < 0 , 4 , 0.01 > Compression Ratio This defines a control parameter with default value 1.5 , between 0 and 4 , with a precission (an increment) of 0.01 and a label \"Copression Ratio\". kcomprat = 2.5 jsfx_setslider ihandle, 3, kcomprat The code above will set the slider #3 (the index passed corresponds with the slider number) to the value of kcomprat The value of any slider can be read via jsfx_getvalue (only one value at a time). Note It is possible to call jsfx_setslider with any number of sliders. It is not necessary to set all the sliders defined in the script. Any slider which is not set via jsfx_setslider retains its default value. A value will always be confined to the range in the slider definition and will also be quantized to the increment in the slider definition. To disable any quantization, set the increment to 0 in the jsfx script Note jsfx is an audio programming language implemented primarily as part of the DAW REAPER . It is a scriptiong language with a built-in compiler which translates it to machine code. It allows the user to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc.","title":"Description"},{"location":"opcodes/jsfx_setslider.html#syntax","text":"jsfx_setslider ihandle, id1, kval1 [, id2, kval2, id3, kval3, ...]","title":"Syntax"},{"location":"opcodes/jsfx_setslider.html#arguments","text":"ihandle : the handle created via jsfx_new or jsfx idx , kvalx : a jsfx script allows to define up to 64 control parameters, which are called slider s. Each slider has an idx (starting from 1) and a value. Here you can control as many sliders as you need. Each slider consists of a pair of values, an id identifying the slider (this corresponds to the sliderx value in the jsfx script) and the value itself (a k- value)","title":"Arguments"},{"location":"opcodes/jsfx_setslider.html#output","text":"","title":"Output"},{"location":"opcodes/jsfx_setslider.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/jsfx_setslider.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for the opcodes jsfx_new, jsfx_play and jsfx_setslider gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i handle jsfx_new \"tubeharmonics.jsfx\" print i handle jsfx_setslider i handle , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out a out jsfx_play i handle , a sig if gk dump == 1 then jsfx_dump i handle , metro ( 4 ) endif k 7 jsfx_getslider i handle , 7 printf \"k7: %f \\r \" , changed2 ( k 7 ), k 7 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/jsfx_setslider.html#see-also","text":"jsfx jsfx_new jsfx_play jsfx_getslider","title":"See also"},{"location":"opcodes/jsfx_setslider.html#credits","text":"Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"Credits"},{"location":"opcodes/lfnoise.html","text":"lfnoise Abstract low frequency, band-limited noise Description Generates random values at a rate given by the nearest integer division of the sample rate by the freq argument. If kinterp==0, between generated values 0 is output. Otherwise the output is the result of interpolating between the generated values. Output is always band limited. Syntax aout lfnoise krate, kinterp=0 Arguments krate : the frequency to generate new values kinterp : if 1, the output is the result of linear interpolation between the generated values Output aout : if kinterp==0, then this is the output random values at the given frequency, or 0. If kinterp==1, then output is the result of interpolation between two generated values. Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* Example file for lfnoise lfnoise generates a random value between 0-1 at the given frequency. If kinterp=1, then values are interpolated; otherwise, they are held until next value */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 FLpanel \"lfnoise\" , 400 , 200 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 322 , 20 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk freq , i h1 FLslider \"freq\" , 0 , 200 , 0 , 3 , i disp1 , 300 , 30 , 20 , 20 gk interp , i h2 FLbutton \"interpolate\" , 1 , 0 , 3 , 100 , 50 , 20 , 80 , - 1 gk gain , i h3 FLslider \"gain\" , 0 , 1 , 0 , 3 , - 1 , 300 , 30 , 20 , 140 FLpanelEnd FLrun FLsetVal_i 8 , i h1 FLsetVal_i 0.1 , i h3 instr 1 a out lfnoise gk freq , gk interp a out *= interp ( gk gain ) outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer > See also dust2 crackle Credits Eduardo Moguillansky, 2019 (port of pd/else's lfnoise , which is itself a merge of supercollider's LFNoise0 and LFNoise1 )","title":"lfnoise"},{"location":"opcodes/lfnoise.html#lfnoise","text":"","title":"lfnoise"},{"location":"opcodes/lfnoise.html#abstract","text":"low frequency, band-limited noise","title":"Abstract"},{"location":"opcodes/lfnoise.html#description","text":"Generates random values at a rate given by the nearest integer division of the sample rate by the freq argument. If kinterp==0, between generated values 0 is output. Otherwise the output is the result of interpolating between the generated values. Output is always band limited.","title":"Description"},{"location":"opcodes/lfnoise.html#syntax","text":"aout lfnoise krate, kinterp=0","title":"Syntax"},{"location":"opcodes/lfnoise.html#arguments","text":"krate : the frequency to generate new values kinterp : if 1, the output is the result of linear interpolation between the generated values","title":"Arguments"},{"location":"opcodes/lfnoise.html#output","text":"aout : if kinterp==0, then this is the output random values at the given frequency, or 0. If kinterp==1, then output is the result of interpolation between two generated values.","title":"Output"},{"location":"opcodes/lfnoise.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/lfnoise.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* Example file for lfnoise lfnoise generates a random value between 0-1 at the given frequency. If kinterp=1, then values are interpolated; otherwise, they are held until next value */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 FLpanel \"lfnoise\" , 400 , 200 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 322 , 20 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk freq , i h1 FLslider \"freq\" , 0 , 200 , 0 , 3 , i disp1 , 300 , 30 , 20 , 20 gk interp , i h2 FLbutton \"interpolate\" , 1 , 0 , 3 , 100 , 50 , 20 , 80 , - 1 gk gain , i h3 FLslider \"gain\" , 0 , 1 , 0 , 3 , - 1 , 300 , 30 , 20 , 140 FLpanelEnd FLrun FLsetVal_i 8 , i h1 FLsetVal_i 0.1 , i h3 instr 1 a out lfnoise gk freq , gk interp a out *= interp ( gk gain ) outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/lfnoise.html#see-also","text":"dust2 crackle","title":"See also"},{"location":"opcodes/lfnoise.html#credits","text":"Eduardo Moguillansky, 2019 (port of pd/else's lfnoise , which is itself a merge of supercollider's LFNoise0 and LFNoise1 )","title":"Credits"},{"location":"opcodes/linenv.html","text":"linenv Abstract A triggerable linear envelope with sustain segment Description linenv is similar to linsegr with an additional gate argument, allowing to retrigger it at will. One of the values can be defined as a sustain point, meaning that as long as the gate is held, the envelope enters a sustain state when reaching this point. When the gate is set to 0, the envelope traverses the rest of the defined points. Syntax xout linenv kgate, isustindex, kval0, [ktime1, kval1, ktime2, kval2, ...] Arguments kgate : whenever this switches from 0 to 1 a new envelope starts isustindex : the index of the sustain point. For example, if isustindex is 2, then when the envelope reaches kval2 (after ktime0+ktime1), it enters a sustain phase, where its value remains unmodified until the gate is set to 0. If no sustain point is desired, set isustindex to -1 kval0 , ktime1 , ...: a linear envelope, similar to linsegr . The release part can have as many segments as desired. ktimex values are defined as time interval between two values, not as absolute timestamps Output xout : value of the envelope (k- or a- rate) Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* This is the example file for opcode \"linenv\" linenv is a triggerable envelope with a sustain segment aout linenv kgate, isustidx, kval0, ktime1, kval1, ..., ktimen, kvaln NB: use isustidx=-1 if no sustain is desired NB: use xtratim if necessary to allow for release segment */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gk gate init 0 FLpanel \"linenv\" , 240 , 100 , 100 , 100 gk gate , gi h1 FLbutton \" Gate\" , 1 , 0 , 2 , 80 , 40 , 10 , 10 , - 1 FLpanelEnd FLrun instr 1 k gate = sc_trig : k ( metro ( 1 / 2 ), 0.5 ) k env linenv k gate , 1 , 0 , 0.15 , 1 , 0.1 , 0 printf \"t: %f , kenv: %f \\n \" , timeinstk (), timeinsts (), k env k env *= 0.2 a sig = pinker () * interp ( k env ) outs a sig , a sig endin instr 2 i period = 2 i gatedur = 1 k gate = sc_trig : k ( metro ( 1 / i period ), i gatedur ) a env linenv k gate , 1 , 0 , 0.2 , 1 , 0.1 , 0 a sig = oscili : a ( 0.2 , 1000 ) * a env FLsetVal changed ( k gate ), k gate , gi h1 outs a sig , a sig endin instr 3 a sig pinker a env linenv gk gate , 2 , 0 , 0.05 , 1 , 0.1 , 0.2 , 0.5 , 0 a sig *= a env outs a sig , a sig endin </ CsInstruments > < CsScore > ; i1 0 10 i 2 0 10 ; i3 0 100 </ CsScore > </ CsoundSynthesizer > See also ramptrig linsegr bpf Credits Eduardo Moguillansky, 2019 (idea based on pd/else's envgen and supercollider's envgen )","title":"linenv"},{"location":"opcodes/linenv.html#linenv","text":"","title":"linenv"},{"location":"opcodes/linenv.html#abstract","text":"A triggerable linear envelope with sustain segment","title":"Abstract"},{"location":"opcodes/linenv.html#description","text":"linenv is similar to linsegr with an additional gate argument, allowing to retrigger it at will. One of the values can be defined as a sustain point, meaning that as long as the gate is held, the envelope enters a sustain state when reaching this point. When the gate is set to 0, the envelope traverses the rest of the defined points.","title":"Description"},{"location":"opcodes/linenv.html#syntax","text":"xout linenv kgate, isustindex, kval0, [ktime1, kval1, ktime2, kval2, ...]","title":"Syntax"},{"location":"opcodes/linenv.html#arguments","text":"kgate : whenever this switches from 0 to 1 a new envelope starts isustindex : the index of the sustain point. For example, if isustindex is 2, then when the envelope reaches kval2 (after ktime0+ktime1), it enters a sustain phase, where its value remains unmodified until the gate is set to 0. If no sustain point is desired, set isustindex to -1 kval0 , ktime1 , ...: a linear envelope, similar to linsegr . The release part can have as many segments as desired. ktimex values are defined as time interval between two values, not as absolute timestamps","title":"Arguments"},{"location":"opcodes/linenv.html#output","text":"xout : value of the envelope (k- or a- rate)","title":"Output"},{"location":"opcodes/linenv.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/linenv.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* This is the example file for opcode \"linenv\" linenv is a triggerable envelope with a sustain segment aout linenv kgate, isustidx, kval0, ktime1, kval1, ..., ktimen, kvaln NB: use isustidx=-1 if no sustain is desired NB: use xtratim if necessary to allow for release segment */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gk gate init 0 FLpanel \"linenv\" , 240 , 100 , 100 , 100 gk gate , gi h1 FLbutton \" Gate\" , 1 , 0 , 2 , 80 , 40 , 10 , 10 , - 1 FLpanelEnd FLrun instr 1 k gate = sc_trig : k ( metro ( 1 / 2 ), 0.5 ) k env linenv k gate , 1 , 0 , 0.15 , 1 , 0.1 , 0 printf \"t: %f , kenv: %f \\n \" , timeinstk (), timeinsts (), k env k env *= 0.2 a sig = pinker () * interp ( k env ) outs a sig , a sig endin instr 2 i period = 2 i gatedur = 1 k gate = sc_trig : k ( metro ( 1 / i period ), i gatedur ) a env linenv k gate , 1 , 0 , 0.2 , 1 , 0.1 , 0 a sig = oscili : a ( 0.2 , 1000 ) * a env FLsetVal changed ( k gate ), k gate , gi h1 outs a sig , a sig endin instr 3 a sig pinker a env linenv gk gate , 2 , 0 , 0.05 , 1 , 0.1 , 0.2 , 0.5 , 0 a sig *= a env outs a sig , a sig endin </ CsInstruments > < CsScore > ; i1 0 10 i 2 0 10 ; i3 0 100 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/linenv.html#see-also","text":"ramptrig linsegr bpf","title":"See also"},{"location":"opcodes/linenv.html#credits","text":"Eduardo Moguillansky, 2019 (idea based on pd/else's envgen and supercollider's envgen )","title":"Credits"},{"location":"opcodes/memview.html","text":"memview Abstract Create a view into a table or another array Description memview makes it possible to operate on a table as if it were an array (using any array opcode), or to operate on a slice of an array without copying the underlying memory. It can be used to efficiently read a slice of an existing array, operate on rows of a 2D matrix, etc. The underlying memory is shared between the source and the view for the duration of the event. Using the returned array as a left-side variable is not supported. This can result in reallocation/resizing of the array, which in this case is not allowed since the underlying memory does not belong to the array. Using it in this way results in undefined behaviour The same holds true for creating a view from a ftable and freeing the ftable during the lifetime of the view. Syntax iView[] memview ift, [, istart=0, iend=0] kView[] memview iSource[] [, istart=0, iend=0] kView[] memview kSource[] [, istart=0, iend=0] Arguments ift : the source ftable iSource[] / kSource[] : the source array istart : the start index of the view (default=0) iend : the end index of the view (non inclusive, default=end of the table / array) Output iView[] / kView[] : the array view Execution time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound - m0 - d </ CsOptions > < CsInstruments > /* memview Create a view into a table or another array iView[] memview ift, [, istart=0, iend=0] kView[] memview iSource[] [, istart=0, iend=0] kView[] memview kSource[] [, istart=0, iend=0] ift: the source ftable iSource[] / kSource[]: the source array istart: the start index of the view (default=0) iend: the end index of the view (non inclusive, default=end of the table / array) memview makes it possible to operate on a table as if it were an array, using any array opcode. It is also possible to take a slice from a different array without copying the underlying elements. It can be used to efficiently read a slice of an existing array, operate on rows of a 2D matrix, etc. The underlying memory is shared between the source and the view for the duration of the event. It is not supported to reuse the array as a left-side variable because that could incurr in reallocation / resizing, which in this case is not allowed since the underlying memory does not belong to the array. Using it in this way results in undefined behaviour. The same holds true for creating a view from a ftable and freeing the ftable during the lifetime of the view. */ gi tab ftgen 0 , 0 , 10 , - 2 , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 instr 1 i View [] memview gi tab prints \" \\n $$$$ Original array:\" printarray i View i View [ 2 ] = 20 i View *= 0.5 prints \" \\n $$$$ Modified array:\" printarray i View prints \" \\n $$$$ Source table should be modified as well \\n \" ftprint gi tab prints \"array length: %d \\n \" , lenarray ( i View ) turnoff endin instr 2 k View [] memview gi tab printf \" \\n $$$$ Original array:\" , 1 printarray k View k View [ 2 ] = 20 k View *= 0.5 printf \" \\n $$$$ Modified array:\" , 1 printarray k View printf \" \\n $$$$ Source table should be modified as well \\n \" , 1 ftprint gi tab , - 1 turnoff endin instr 3 i X [] fillarray 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 i Y [] memview i X , 5 k Z [] memview i X , 3 , 8 i Y *= 10 printarray i Y printarray i X printarray k Z turnoff endin instr 4 k X [] fillarray 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 k Y [] memview k X , 5 k Y *= 0.5 printarray k X printarray k Y turnoff endin </ CsInstruments > < CsScore > ; i1 0 1 ; i2 0 1 i 3 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also copya2ftab slicearray tabrowlin ref deref Credits Eduado Moguillansky, 2019","title":"memview"},{"location":"opcodes/memview.html#memview","text":"","title":"memview"},{"location":"opcodes/memview.html#abstract","text":"Create a view into a table or another array","title":"Abstract"},{"location":"opcodes/memview.html#description","text":"memview makes it possible to operate on a table as if it were an array (using any array opcode), or to operate on a slice of an array without copying the underlying memory. It can be used to efficiently read a slice of an existing array, operate on rows of a 2D matrix, etc. The underlying memory is shared between the source and the view for the duration of the event. Using the returned array as a left-side variable is not supported. This can result in reallocation/resizing of the array, which in this case is not allowed since the underlying memory does not belong to the array. Using it in this way results in undefined behaviour The same holds true for creating a view from a ftable and freeing the ftable during the lifetime of the view.","title":"Description"},{"location":"opcodes/memview.html#syntax","text":"iView[] memview ift, [, istart=0, iend=0] kView[] memview iSource[] [, istart=0, iend=0] kView[] memview kSource[] [, istart=0, iend=0]","title":"Syntax"},{"location":"opcodes/memview.html#arguments","text":"ift : the source ftable iSource[] / kSource[] : the source array istart : the start index of the view (default=0) iend : the end index of the view (non inclusive, default=end of the table / array)","title":"Arguments"},{"location":"opcodes/memview.html#output","text":"iView[] / kView[] : the array view","title":"Output"},{"location":"opcodes/memview.html#execution-time","text":"Init","title":"Execution time"},{"location":"opcodes/memview.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound - m0 - d </ CsOptions > < CsInstruments > /* memview Create a view into a table or another array iView[] memview ift, [, istart=0, iend=0] kView[] memview iSource[] [, istart=0, iend=0] kView[] memview kSource[] [, istart=0, iend=0] ift: the source ftable iSource[] / kSource[]: the source array istart: the start index of the view (default=0) iend: the end index of the view (non inclusive, default=end of the table / array) memview makes it possible to operate on a table as if it were an array, using any array opcode. It is also possible to take a slice from a different array without copying the underlying elements. It can be used to efficiently read a slice of an existing array, operate on rows of a 2D matrix, etc. The underlying memory is shared between the source and the view for the duration of the event. It is not supported to reuse the array as a left-side variable because that could incurr in reallocation / resizing, which in this case is not allowed since the underlying memory does not belong to the array. Using it in this way results in undefined behaviour. The same holds true for creating a view from a ftable and freeing the ftable during the lifetime of the view. */ gi tab ftgen 0 , 0 , 10 , - 2 , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 instr 1 i View [] memview gi tab prints \" \\n $$$$ Original array:\" printarray i View i View [ 2 ] = 20 i View *= 0.5 prints \" \\n $$$$ Modified array:\" printarray i View prints \" \\n $$$$ Source table should be modified as well \\n \" ftprint gi tab prints \"array length: %d \\n \" , lenarray ( i View ) turnoff endin instr 2 k View [] memview gi tab printf \" \\n $$$$ Original array:\" , 1 printarray k View k View [ 2 ] = 20 k View *= 0.5 printf \" \\n $$$$ Modified array:\" , 1 printarray k View printf \" \\n $$$$ Source table should be modified as well \\n \" , 1 ftprint gi tab , - 1 turnoff endin instr 3 i X [] fillarray 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 i Y [] memview i X , 5 k Z [] memview i X , 3 , 8 i Y *= 10 printarray i Y printarray i X printarray k Z turnoff endin instr 4 k X [] fillarray 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 k Y [] memview k X , 5 k Y *= 0.5 printarray k X printarray k Y turnoff endin </ CsInstruments > < CsScore > ; i1 0 1 ; i2 0 1 i 3 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/memview.html#see-also","text":"copya2ftab slicearray tabrowlin ref deref","title":"See also"},{"location":"opcodes/memview.html#credits","text":"Eduado Moguillansky, 2019","title":"Credits"},{"location":"opcodes/poly.html","text":"poly Abstract poly creates and controls multiple parallel version of an opcode Description poly creates a user given number of instances of an opcode, each with its own state, inputs and outputs. The resulting output is an array where each element holds the output of the corresponding instance. In general, an opcode has a signature, given by the number and types of its output and input arguments. For example, the opcode oscili as used like aout oscili kamp, kfreq has a signature a / kk ( a as output, kk as input). To follow this example, to create 10 parallel versions of this opcode (an oscillator bank) it is possible to use poly like this: k Freqs [] fillarray 100 , 110 , 200 , 220 , 300 , 330 , 400 , 440 , 500 , 550 a Out [] poly 10 , \"oscili\" , 0.1 , k Freqs Notice that it is possible to set one value for each instance, as given by kFreqs , or one value to be shared by all instances, as given by the amplitude 0.1 . By changing the array kFreqs it is possible to modify the frequency of each oscillator. It is of course possible to chain multiple poly s to generate complex effect chains, and poly can also be used with k-values. Note At the moment poly works only with builtin opcodes . This might change in the future Note for limitations in the type system of csound, poly works with all opcodes which have at least one output. For opcodes with no outputs (like outch , for example), use poly0 Syntax out1[], [ out2[], ... ] poly inuminstances, Sopcode, xarg0, [xarg1, ...] Arguments inuminstances : the number of instances of Sopcode to instantiate Sopcode : the name of the opcode xargs : any number of arguments, either i-, k- or a-rate, either scalar or arrays, or strings, as needed by the given opcode. String arrays are not yet supported The number and type of the input arguments depend on the arguments passed to the given opcode. The same applies for the output arguments NB : output arguments are always arrays, input arguments can be arrays, in which case they must be at least the size of inuminstances , or scalars, in which case the same value is shared by multiple instances Output The output is one or more arrays of k- or a-type, corresponding to the opcode. For instance, an opcode like aout oscili 0.1, kfreq will output an array of audio channels. An opcode like pan2 will output two audio arrays. Examples LISTEN < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 0dbfs = 1 ; create an array of random values between 0-1 ; inum: number of elements in the array opcode rndarr , i[] , i i num xin i Out [] init i num i 0 = 0 while i 0 < i num do i Out [ i 0 ] = unirand ( 1 ) i 0 += 1 od xout i Out endop ; multiple oscillators, mixed down to mono instr 1 ; number of oscillators i num = 100 ; fundamental k midi = line ( ntom : i ( \"2G\" ), p3 , ntom : i ( \"1C\" )) k f0 = mtof ( k midi ) ; each oscillator is an overtone of f0 k Ratios [] genarray_i 1 , i num ; harmonicity over time k exp line 1 , p3 , 1.32 ; the freq. of each oscillator k Freqs [] = ( k Ratios ^ k exp ) * k f0 ; array of random phases, to avoid synchronous start i Phs [] rndarr i num ; generate the oscillators. a Oscils [] poly i num , \"oscili\" , 1 / i num , k Freqs , - 1 , i Phs a mono sumarray a Oscils a mono *= linsegr : a ( 0 , 0.05 , 1 , 0.05 , 0 ) outs a mono , a mono endin ; poly instances stacked as a processing pipe instr 2 ; amount of polyphony i num = 30 i Freqs [] rndarr i num ; the ratios of the overtones k Ratios [] genarray_i 1 , i num ; a down gliss k m0 linseg ntom : i ( \"2C\" ), p3 * 0.8 , ntom : i ( \"1C\" ) k f0 = mtof ( k m0 ) ; harmonicity curve k p linsegb 1 , p3 * 0.8 , 1.68 ; calculate actual freqs. k Freqs [] = ( k Ratios ^ k p ) * k f0 ; lfo freqs. used for AM and panning k f linsegb 0.1 , p3 * 0.62 , 0.8 , p3 * 0.8 , 0.8 , p3 * 0.96 , 12 , p3 , 60 k LfoFreqs [] = i Freqs * k f ; multiple noise instances, amplitude modulated a A [] poly i num , \"noise\" , 0.5 , 0.3 a Amps [] poly i num , \"oscili\" , 1 , k LfoFreqs * 0.6 a A *= a Amps ; filter noise with bandpass k Q linsegb 0.5 , p3 * 0.5 , 0.02 , p3 , 0.0001 k Bands [] = k Freqs * k Q a B [] poly i num , \"resonr\" , a A , k Freqs , k Bands ; panning. poly works also with k-rate and with ; opcodes producing multiple outputs, like pan2 k PanPos [] poly i num , \"lfo\" , 0.5 , k LfoFreqs k PanPos += 0.5 ; lfo in the range 0-1 for panning a L [], a R [] poly i num , \"pan2\" , a B , k PanPos a left sumarray a L a right sumarray a R ; compress / fade a ref init 1 a sig = 0.707 * ( a left + a right ) a gain compress2 a ref , a sig , - 90 , - 48 , - 24 , 2.5 , 0.05 , 0.2 , 0.05 a left *= a gain a right *= a gain a gain2 compress2 a ref , ( a left + a right ) * 0.707 , - 90 , - 6 , - 3 , 20 , 0.002 , 0.010 , 0.02 a env = a gain2 * cossegr : a ( 0 , 1 , 1 , 0.1 , 0 ) outs a left * a env , a right * a env endin opcode test , a , k k freq xin a out oscili 0.1 , k freq xout a out endop instr 3 ; test udo k freqs [] fillarray 440 , 443 a A [] poly 2 , \"test\" , k freqs a 0 sumarray a A outs a 0 , a 0 endin </ CsInstruments > < CsScore > i 1 0 8 i 2 9 50 ; i 3 0 1 </ CsScore > </ CsoundSynthesizer > See also poly0 maparray polyseq Credits Eduardo Moguillansky, 2019","title":"poly"},{"location":"opcodes/poly.html#poly","text":"","title":"poly"},{"location":"opcodes/poly.html#abstract","text":"poly creates and controls multiple parallel version of an opcode","title":"Abstract"},{"location":"opcodes/poly.html#description","text":"poly creates a user given number of instances of an opcode, each with its own state, inputs and outputs. The resulting output is an array where each element holds the output of the corresponding instance. In general, an opcode has a signature, given by the number and types of its output and input arguments. For example, the opcode oscili as used like aout oscili kamp, kfreq has a signature a / kk ( a as output, kk as input). To follow this example, to create 10 parallel versions of this opcode (an oscillator bank) it is possible to use poly like this: k Freqs [] fillarray 100 , 110 , 200 , 220 , 300 , 330 , 400 , 440 , 500 , 550 a Out [] poly 10 , \"oscili\" , 0.1 , k Freqs Notice that it is possible to set one value for each instance, as given by kFreqs , or one value to be shared by all instances, as given by the amplitude 0.1 . By changing the array kFreqs it is possible to modify the frequency of each oscillator. It is of course possible to chain multiple poly s to generate complex effect chains, and poly can also be used with k-values. Note At the moment poly works only with builtin opcodes . This might change in the future Note for limitations in the type system of csound, poly works with all opcodes which have at least one output. For opcodes with no outputs (like outch , for example), use poly0","title":"Description"},{"location":"opcodes/poly.html#syntax","text":"out1[], [ out2[], ... ] poly inuminstances, Sopcode, xarg0, [xarg1, ...]","title":"Syntax"},{"location":"opcodes/poly.html#arguments","text":"inuminstances : the number of instances of Sopcode to instantiate Sopcode : the name of the opcode xargs : any number of arguments, either i-, k- or a-rate, either scalar or arrays, or strings, as needed by the given opcode. String arrays are not yet supported The number and type of the input arguments depend on the arguments passed to the given opcode. The same applies for the output arguments NB : output arguments are always arrays, input arguments can be arrays, in which case they must be at least the size of inuminstances , or scalars, in which case the same value is shared by multiple instances","title":"Arguments"},{"location":"opcodes/poly.html#output","text":"The output is one or more arrays of k- or a-type, corresponding to the opcode. For instance, an opcode like aout oscili 0.1, kfreq will output an array of audio channels. An opcode like pan2 will output two audio arrays.","title":"Output"},{"location":"opcodes/poly.html#examples","text":"LISTEN < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 0dbfs = 1 ; create an array of random values between 0-1 ; inum: number of elements in the array opcode rndarr , i[] , i i num xin i Out [] init i num i 0 = 0 while i 0 < i num do i Out [ i 0 ] = unirand ( 1 ) i 0 += 1 od xout i Out endop ; multiple oscillators, mixed down to mono instr 1 ; number of oscillators i num = 100 ; fundamental k midi = line ( ntom : i ( \"2G\" ), p3 , ntom : i ( \"1C\" )) k f0 = mtof ( k midi ) ; each oscillator is an overtone of f0 k Ratios [] genarray_i 1 , i num ; harmonicity over time k exp line 1 , p3 , 1.32 ; the freq. of each oscillator k Freqs [] = ( k Ratios ^ k exp ) * k f0 ; array of random phases, to avoid synchronous start i Phs [] rndarr i num ; generate the oscillators. a Oscils [] poly i num , \"oscili\" , 1 / i num , k Freqs , - 1 , i Phs a mono sumarray a Oscils a mono *= linsegr : a ( 0 , 0.05 , 1 , 0.05 , 0 ) outs a mono , a mono endin ; poly instances stacked as a processing pipe instr 2 ; amount of polyphony i num = 30 i Freqs [] rndarr i num ; the ratios of the overtones k Ratios [] genarray_i 1 , i num ; a down gliss k m0 linseg ntom : i ( \"2C\" ), p3 * 0.8 , ntom : i ( \"1C\" ) k f0 = mtof ( k m0 ) ; harmonicity curve k p linsegb 1 , p3 * 0.8 , 1.68 ; calculate actual freqs. k Freqs [] = ( k Ratios ^ k p ) * k f0 ; lfo freqs. used for AM and panning k f linsegb 0.1 , p3 * 0.62 , 0.8 , p3 * 0.8 , 0.8 , p3 * 0.96 , 12 , p3 , 60 k LfoFreqs [] = i Freqs * k f ; multiple noise instances, amplitude modulated a A [] poly i num , \"noise\" , 0.5 , 0.3 a Amps [] poly i num , \"oscili\" , 1 , k LfoFreqs * 0.6 a A *= a Amps ; filter noise with bandpass k Q linsegb 0.5 , p3 * 0.5 , 0.02 , p3 , 0.0001 k Bands [] = k Freqs * k Q a B [] poly i num , \"resonr\" , a A , k Freqs , k Bands ; panning. poly works also with k-rate and with ; opcodes producing multiple outputs, like pan2 k PanPos [] poly i num , \"lfo\" , 0.5 , k LfoFreqs k PanPos += 0.5 ; lfo in the range 0-1 for panning a L [], a R [] poly i num , \"pan2\" , a B , k PanPos a left sumarray a L a right sumarray a R ; compress / fade a ref init 1 a sig = 0.707 * ( a left + a right ) a gain compress2 a ref , a sig , - 90 , - 48 , - 24 , 2.5 , 0.05 , 0.2 , 0.05 a left *= a gain a right *= a gain a gain2 compress2 a ref , ( a left + a right ) * 0.707 , - 90 , - 6 , - 3 , 20 , 0.002 , 0.010 , 0.02 a env = a gain2 * cossegr : a ( 0 , 1 , 1 , 0.1 , 0 ) outs a left * a env , a right * a env endin opcode test , a , k k freq xin a out oscili 0.1 , k freq xout a out endop instr 3 ; test udo k freqs [] fillarray 440 , 443 a A [] poly 2 , \"test\" , k freqs a 0 sumarray a A outs a 0 , a 0 endin </ CsInstruments > < CsScore > i 1 0 8 i 2 9 50 ; i 3 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/poly.html#see-also","text":"poly0 maparray polyseq","title":"See also"},{"location":"opcodes/poly.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/poly0.html","text":"poly0 Abstract poly0 creates and controls multiple parallel version of an opcode with no outputs Description poly0 creates a user given number of instances of an opcode, each with its own state, inputs and outputs. The resulting output is an array where each element holds the output of the corresponding instance. In general, an opcode has a signature, given by the number and types of its output and input arguments. For example, the opcode oscili as used like aout oscili kamp, kfreq has a signature a / kk ( a as output, kk as input). To follow this example, to create 10 parallel versions of this opcode (an oscillator bank) it is possible to use poly0 like this: k Freqs [] fillarray 100 , 110 , 200 , 220 , 300 , 330 , 400 , 440 , 500 , 550 i Pans [] fillarray 0 , 1 , 0 , 1 , 0.5 , 0.3 , 0.7 , 0.2 , 0.9 , 0.8 a Sigs [] poly 10 , \"oscili\" , 0.1 , k Freqs a Ls [], a Rs [] poly 10 , \"pan2\" , a Sigs , i Pans poly0 10 , \"outch\" , 1 , a Ls poly0 10 , \"outch\" , 2 , a Rs Notice that it is possible to set one value for each instance, as given by kFreqs , or one value to be shared by all instances, as given by the amplitude 0.1 . By changing the array kFreqs it is possible to modify the frequency of each oscillator. It is of course possible to chain multiple poly0 s to generate complex effect chains, and poly0 can also be used with k-values. Note At the moment poly0 works only with builtin opcodes . This might change in the future Note for limitations in the type system of csound, poly0 works with all opcodes which have at least one output. For opcodes with no outputs (like outch , for example), use poly0 Syntax poly0 inuminstances, Sopcode, xarg0, [xarg1, ...] Arguments inuminstances : the number of instances of Sopcode to instantiate Sopcode : the name of the opcode xargs : any number of arguments, either i-, k- or a-rate, either scalar or arrays, or strings, as needed by the given opcode. String arrays are not yet supported The number and type of the input arguments depend on the arguments passed to the given opcode. The same applies for the output arguments NB : output arguments are always arrays, input arguments can be arrays, in which case they must be at least the size of inuminstances , or scalars, in which case the same value is shared by multiple instances Output Examples See poly for examples See also poly maparray polyseq Credits Eduardo Moguillansky, 2019","title":"poly0"},{"location":"opcodes/poly0.html#poly0","text":"","title":"poly0"},{"location":"opcodes/poly0.html#abstract","text":"poly0 creates and controls multiple parallel version of an opcode with no outputs","title":"Abstract"},{"location":"opcodes/poly0.html#description","text":"poly0 creates a user given number of instances of an opcode, each with its own state, inputs and outputs. The resulting output is an array where each element holds the output of the corresponding instance. In general, an opcode has a signature, given by the number and types of its output and input arguments. For example, the opcode oscili as used like aout oscili kamp, kfreq has a signature a / kk ( a as output, kk as input). To follow this example, to create 10 parallel versions of this opcode (an oscillator bank) it is possible to use poly0 like this: k Freqs [] fillarray 100 , 110 , 200 , 220 , 300 , 330 , 400 , 440 , 500 , 550 i Pans [] fillarray 0 , 1 , 0 , 1 , 0.5 , 0.3 , 0.7 , 0.2 , 0.9 , 0.8 a Sigs [] poly 10 , \"oscili\" , 0.1 , k Freqs a Ls [], a Rs [] poly 10 , \"pan2\" , a Sigs , i Pans poly0 10 , \"outch\" , 1 , a Ls poly0 10 , \"outch\" , 2 , a Rs Notice that it is possible to set one value for each instance, as given by kFreqs , or one value to be shared by all instances, as given by the amplitude 0.1 . By changing the array kFreqs it is possible to modify the frequency of each oscillator. It is of course possible to chain multiple poly0 s to generate complex effect chains, and poly0 can also be used with k-values. Note At the moment poly0 works only with builtin opcodes . This might change in the future Note for limitations in the type system of csound, poly0 works with all opcodes which have at least one output. For opcodes with no outputs (like outch , for example), use poly0","title":"Description"},{"location":"opcodes/poly0.html#syntax","text":"poly0 inuminstances, Sopcode, xarg0, [xarg1, ...]","title":"Syntax"},{"location":"opcodes/poly0.html#arguments","text":"inuminstances : the number of instances of Sopcode to instantiate Sopcode : the name of the opcode xargs : any number of arguments, either i-, k- or a-rate, either scalar or arrays, or strings, as needed by the given opcode. String arrays are not yet supported The number and type of the input arguments depend on the arguments passed to the given opcode. The same applies for the output arguments NB : output arguments are always arrays, input arguments can be arrays, in which case they must be at least the size of inuminstances , or scalars, in which case the same value is shared by multiple instances","title":"Arguments"},{"location":"opcodes/poly0.html#output","text":"","title":"Output"},{"location":"opcodes/poly0.html#examples","text":"See poly for examples","title":"Examples"},{"location":"opcodes/poly0.html#see-also","text":"poly maparray polyseq","title":"See also"},{"location":"opcodes/poly0.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/polyseq.html","text":"polyseq Abstract polyseq creates and controls multiple sequential version of an opcode Description polyseq creates a user given number of instances of an opcode, each with its own state. The output of an instance is routed to the input of the next instance, forming a chain. Each instance can be controlled individually. We differentiate between chained and multiplexed arguments. chained arguments are the ones which are mapped from one opcode instance to the next, so that the output of one instance is routed to the input of the next. multiplexed are passed after the chained arguments and work as they do with poly : if an array is passed, then each instance is delivered one element of this array, and if a scalar value is passed, then all instances share the same argument. Example All this is best explained with an example: ; these two signal chains produce the same result a 0 pinker k Freqs [] fillarray 100 , 150 , 300 , 330 a eq rbjeq a 0 , k Freqs [ 0 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 1 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 2 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 3 ], 2 , 10 , 1 , 8 a seq polyseq 4 , \"rbjeq\" , a 0 , k Freqs , 2 , 10 , 1 , 8 Syntax xouts polyseq numinstances:i, opcodename:s, xins, params ... polyseq can have any number of inputs and outputs, as long as the opcode used has matching inputs and outputs. Arguments inuminstances : the number of instances of Sopcode to instantiate Sopcode : the name of the opcode xins : any number of arguments, either k- or a-rate, which should correspond to the outputs of the opcode The number and type of the input arguments depend on the arguments passed to the given opcode. The same applies for the output arguments Output xouts : any number of arguments of type k or a , as output by the opcode Examples LISTEN < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 0dbfs = 1 ; Example file for polyseq instr 1 ; A simple parametric eq. ; On the left channel, the reference signal, ; on the right, the polyseq implementation. ; These should be the same a 0 pinker a 0 *= ampdb ( - 12 ) k Freqs [] fillarray 400 , 1400 , 3000 , 4400 , 8000 , 12000 k Qs [] fillarray 10 , 20 , 10 , 20 , 10 , 20 k V = ampdb ( 18 ) a ref = a 0 a ref rbjeq a ref , k Freqs [ 0 ], k V , k Qs [ 0 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 1 ], k V , k Qs [ 1 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 2 ], k V , k Qs [ 2 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 3 ], k V , k Qs [ 3 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 4 ], k V , k Qs [ 4 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 5 ], k V , k Qs [ 5 ], 1 , 8 a seq polyseq lenarray ( k Freqs ), \"rbjeq\" , a 0 , k Freqs , k V , k Qs , 1 , 8 outs a ref , a seq endin opcode rndarr , i[] , iii i num , i min , i max xin i Out [] init i num i 0 = 0 i delta = i max - i min while i 0 < i num do i Out [ i 0 ] = i min + unirand ( i delta ) i 0 += 1 od xout i Out endop instr 2 ; two varying eqs a 0 = pinker () * ampdb ( - 8 ) k Freqs0 [] fillarray 50 , 130 , 400 , 500 , 1400 , 3000 , 4400 , 5000 , 8000 i num lenarray k Freqs0 i Freqslfo [] rndarr i num , 0.05 , 0.4 k Lfos [] poly i num , \"lfo\" , 0.1 , i Freqslfo k FreqsL [] = k Freqs0 * ( 1 + k Lfos ) k FreqsR [] = k Freqs0 * ( 1 + k Lfos * 1.62 ) k Qs [] poly i num , \"lfo\" , 5 , i Freqslfo * 1.5 k Qs += 7.5 a eqL polyseq i num , \"rbjeq\" , a 0 , k FreqsL , ampdb ( 10 ), k Qs , 1 , 8 a eqR polyseq i num , \"rbjeq\" , a 0 , k FreqsR , ampdb ( 12 ), k Qs * 1.5 , 1 , 8 ; declick a env = linsegr ( 0 , 0.5 , 1 , 0.5 , 0 ) outs a eqL * a env , a eqR * a env endin </ CsInstruments > < CsScore > i 1 0 5 i 2 5 20 </ CsScore > </ CsoundSynthesizer > See also maparray poly Credits Eduardo Moguillansky, 2019","title":"polyseq"},{"location":"opcodes/polyseq.html#polyseq","text":"","title":"polyseq"},{"location":"opcodes/polyseq.html#abstract","text":"polyseq creates and controls multiple sequential version of an opcode","title":"Abstract"},{"location":"opcodes/polyseq.html#description","text":"polyseq creates a user given number of instances of an opcode, each with its own state. The output of an instance is routed to the input of the next instance, forming a chain. Each instance can be controlled individually. We differentiate between chained and multiplexed arguments. chained arguments are the ones which are mapped from one opcode instance to the next, so that the output of one instance is routed to the input of the next. multiplexed are passed after the chained arguments and work as they do with poly : if an array is passed, then each instance is delivered one element of this array, and if a scalar value is passed, then all instances share the same argument.","title":"Description"},{"location":"opcodes/polyseq.html#example","text":"All this is best explained with an example: ; these two signal chains produce the same result a 0 pinker k Freqs [] fillarray 100 , 150 , 300 , 330 a eq rbjeq a 0 , k Freqs [ 0 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 1 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 2 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 3 ], 2 , 10 , 1 , 8 a seq polyseq 4 , \"rbjeq\" , a 0 , k Freqs , 2 , 10 , 1 , 8","title":"Example"},{"location":"opcodes/polyseq.html#syntax","text":"xouts polyseq numinstances:i, opcodename:s, xins, params ... polyseq can have any number of inputs and outputs, as long as the opcode used has matching inputs and outputs.","title":"Syntax"},{"location":"opcodes/polyseq.html#arguments","text":"inuminstances : the number of instances of Sopcode to instantiate Sopcode : the name of the opcode xins : any number of arguments, either k- or a-rate, which should correspond to the outputs of the opcode The number and type of the input arguments depend on the arguments passed to the given opcode. The same applies for the output arguments","title":"Arguments"},{"location":"opcodes/polyseq.html#output","text":"xouts : any number of arguments of type k or a , as output by the opcode","title":"Output"},{"location":"opcodes/polyseq.html#examples","text":"LISTEN < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 0dbfs = 1 ; Example file for polyseq instr 1 ; A simple parametric eq. ; On the left channel, the reference signal, ; on the right, the polyseq implementation. ; These should be the same a 0 pinker a 0 *= ampdb ( - 12 ) k Freqs [] fillarray 400 , 1400 , 3000 , 4400 , 8000 , 12000 k Qs [] fillarray 10 , 20 , 10 , 20 , 10 , 20 k V = ampdb ( 18 ) a ref = a 0 a ref rbjeq a ref , k Freqs [ 0 ], k V , k Qs [ 0 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 1 ], k V , k Qs [ 1 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 2 ], k V , k Qs [ 2 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 3 ], k V , k Qs [ 3 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 4 ], k V , k Qs [ 4 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 5 ], k V , k Qs [ 5 ], 1 , 8 a seq polyseq lenarray ( k Freqs ), \"rbjeq\" , a 0 , k Freqs , k V , k Qs , 1 , 8 outs a ref , a seq endin opcode rndarr , i[] , iii i num , i min , i max xin i Out [] init i num i 0 = 0 i delta = i max - i min while i 0 < i num do i Out [ i 0 ] = i min + unirand ( i delta ) i 0 += 1 od xout i Out endop instr 2 ; two varying eqs a 0 = pinker () * ampdb ( - 8 ) k Freqs0 [] fillarray 50 , 130 , 400 , 500 , 1400 , 3000 , 4400 , 5000 , 8000 i num lenarray k Freqs0 i Freqslfo [] rndarr i num , 0.05 , 0.4 k Lfos [] poly i num , \"lfo\" , 0.1 , i Freqslfo k FreqsL [] = k Freqs0 * ( 1 + k Lfos ) k FreqsR [] = k Freqs0 * ( 1 + k Lfos * 1.62 ) k Qs [] poly i num , \"lfo\" , 5 , i Freqslfo * 1.5 k Qs += 7.5 a eqL polyseq i num , \"rbjeq\" , a 0 , k FreqsL , ampdb ( 10 ), k Qs , 1 , 8 a eqR polyseq i num , \"rbjeq\" , a 0 , k FreqsR , ampdb ( 12 ), k Qs * 1.5 , 1 , 8 ; declick a env = linsegr ( 0 , 0.5 , 1 , 0.5 , 0 ) outs a eqL * a env , a eqR * a env endin </ CsInstruments > < CsScore > i 1 0 5 i 2 5 20 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/polyseq.html#see-also","text":"maparray poly","title":"See also"},{"location":"opcodes/polyseq.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/pool_at.html","text":"pool_at Abstract Returns the item of a pool at a given index Description A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. To get a value, call pool_pop and when finished using it the value is returned to the pool with pool_push . pool_size returns the size of the pool (the number of items in it, not the capacity, see pool_capacity for that) Syntax item pool_at ipool, index kitem pool_at ipool, kindex Arguments ipool : the pool to push the value to index / kindex : the index to query Output item / kitem : the item at the given index Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for pool_at pool_at returns the item of a pool at a given index item pool_at ipool, idx ktem pool_at ipool, kidx */ opcode print_pool , 0 , i i pool xin i 0 = 0 i size = pool_size ( i pool ) while i 0 < i size do i tem = pool_at ( i pool , i 0 ) print i tem i 0 += 1 od endop instr 1 i pool pool_gen 10 i 1 pool_pop i pool i 2 pool_pop i pool prints \" \\n <<< pool size: %d , pool capacity: %d >>> \\n\\n \" , \\ pool_size : i ( i pool ), pool_capacity : i ( i pool ) print_pool i pool turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer > See also pool_capacity pool_pop pool_new pool_gen Credits Eduardo Moguillansky, 2019","title":"pool_at"},{"location":"opcodes/pool_at.html#pool_at","text":"","title":"pool_at"},{"location":"opcodes/pool_at.html#abstract","text":"Returns the item of a pool at a given index","title":"Abstract"},{"location":"opcodes/pool_at.html#description","text":"A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. To get a value, call pool_pop and when finished using it the value is returned to the pool with pool_push . pool_size returns the size of the pool (the number of items in it, not the capacity, see pool_capacity for that)","title":"Description"},{"location":"opcodes/pool_at.html#syntax","text":"item pool_at ipool, index kitem pool_at ipool, kindex","title":"Syntax"},{"location":"opcodes/pool_at.html#arguments","text":"ipool : the pool to push the value to index / kindex : the index to query","title":"Arguments"},{"location":"opcodes/pool_at.html#output","text":"item / kitem : the item at the given index","title":"Output"},{"location":"opcodes/pool_at.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/pool_at.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for pool_at pool_at returns the item of a pool at a given index item pool_at ipool, idx ktem pool_at ipool, kidx */ opcode print_pool , 0 , i i pool xin i 0 = 0 i size = pool_size ( i pool ) while i 0 < i size do i tem = pool_at ( i pool , i 0 ) print i tem i 0 += 1 od endop instr 1 i pool pool_gen 10 i 1 pool_pop i pool i 2 pool_pop i pool prints \" \\n <<< pool size: %d , pool capacity: %d >>> \\n\\n \" , \\ pool_size : i ( i pool ), pool_capacity : i ( i pool ) print_pool i pool turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pool_at.html#see-also","text":"pool_capacity pool_pop pool_new pool_gen","title":"See also"},{"location":"opcodes/pool_at.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/pool_capacity.html","text":"pool_capacity Abstract Returns the capacity of a pool Description A pool is actually a stack of numbers, based on an array. pool_capacity returns the maximum number of items which can be pushed in this pool. If the pool was created with a fixed capacity, then pushing when the pool is full will result in a performance error. To create a pool with dynamic size, use pool_new without giving a capacity (see pool_new ) The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. To get a value, call pool_pop and when finished using it the value is returned to the pool with pool_push . pool_capacity returns the capacity of the pool (the max. number of items it can hold, not the actual size, see pool_size for that) Note To differenciate between the opcode being called at init- or at performance time, use the functional style pool_capacity:i(ipool) or pool_capacity:k(ipool) Syntax icapacity pool_capacity ipool kcapacity pool_capacity kpool Arguments ipool : the pool query Output icapacity / kcapacity : the max. number of items this pool can hold Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for pool_size pool_size returns the size of the pool, either at init or at performance time The size of a pool is the number of items actually inside the pool (see also pool_capacity) */ instr 1 i pool pool_gen 10 i 1 pool_pop i pool i 2 pool_pop i pool prints \" \\n <<< pool size: %d , pool capacity: %d >>> \\n\\n \" , \\ pool_size : i ( i pool ), pool_capacity : i ( i pool ) turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer > See also pool_size pool_pop pool_new pool_gen Credits Eduardo Moguillansky, 2019","title":"pool_capacity"},{"location":"opcodes/pool_capacity.html#pool_capacity","text":"","title":"pool_capacity"},{"location":"opcodes/pool_capacity.html#abstract","text":"Returns the capacity of a pool","title":"Abstract"},{"location":"opcodes/pool_capacity.html#description","text":"A pool is actually a stack of numbers, based on an array. pool_capacity returns the maximum number of items which can be pushed in this pool. If the pool was created with a fixed capacity, then pushing when the pool is full will result in a performance error. To create a pool with dynamic size, use pool_new without giving a capacity (see pool_new ) The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. To get a value, call pool_pop and when finished using it the value is returned to the pool with pool_push . pool_capacity returns the capacity of the pool (the max. number of items it can hold, not the actual size, see pool_size for that) Note To differenciate between the opcode being called at init- or at performance time, use the functional style pool_capacity:i(ipool) or pool_capacity:k(ipool)","title":"Description"},{"location":"opcodes/pool_capacity.html#syntax","text":"icapacity pool_capacity ipool kcapacity pool_capacity kpool","title":"Syntax"},{"location":"opcodes/pool_capacity.html#arguments","text":"ipool : the pool query","title":"Arguments"},{"location":"opcodes/pool_capacity.html#output","text":"icapacity / kcapacity : the max. number of items this pool can hold","title":"Output"},{"location":"opcodes/pool_capacity.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/pool_capacity.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for pool_size pool_size returns the size of the pool, either at init or at performance time The size of a pool is the number of items actually inside the pool (see also pool_capacity) */ instr 1 i pool pool_gen 10 i 1 pool_pop i pool i 2 pool_pop i pool prints \" \\n <<< pool size: %d , pool capacity: %d >>> \\n\\n \" , \\ pool_size : i ( i pool ), pool_capacity : i ( i pool ) turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pool_capacity.html#see-also","text":"pool_size pool_pop pool_new pool_gen","title":"See also"},{"location":"opcodes/pool_capacity.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/pool_gen.html","text":"pool_gen Abstract Create a pool and fill it with values Description A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. pool_gen creates a pool of values of a given size by filling the pool with values from 1 to the given size Syntax ipool pool_gen isize ipool pool_gen istart, iend Arguments isize : the size of the pool. istart : the start item iend : the end item (inclusive) Output ipool : an index identifying this pool. This index is used when calling any pool opcode Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 opcode pool_print , 0 , i i pool xin i 0 = 0 i size = pool_size ( i pool ) while i 0 < i size do i val = pool_at ( i pool , i 0 ) print i val i 0 += 1 od endop instr test1 i pool pool_gen 100 i size pool_size i pool i capacity pool_capacity i pool print i size print i capacity pool_print i pool endin instr test2 i pool pool_gen 1 , 100 i size pool_size i pool i capacity pool_capacity i pool print i size print i capacity pool_print i pool endin instr sep prints \" \\n -------------------------------- \\n\\n \" ; turnoff endin </ CsInstruments > < CsScore > i \"test1\" 0 0.1 i \"sep\" 0.1 0.1 i \"test2\" 0.2 0.1 </ CsScore > </ CsoundSynthesizer > See also pool_new pool_push pool_pop pool_size pool_capacity Credits Eduardo Moguillansky, 2019","title":"pool_gen"},{"location":"opcodes/pool_gen.html#pool_gen","text":"","title":"pool_gen"},{"location":"opcodes/pool_gen.html#abstract","text":"Create a pool and fill it with values","title":"Abstract"},{"location":"opcodes/pool_gen.html#description","text":"A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. pool_gen creates a pool of values of a given size by filling the pool with values from 1 to the given size","title":"Description"},{"location":"opcodes/pool_gen.html#syntax","text":"ipool pool_gen isize ipool pool_gen istart, iend","title":"Syntax"},{"location":"opcodes/pool_gen.html#arguments","text":"isize : the size of the pool. istart : the start item iend : the end item (inclusive)","title":"Arguments"},{"location":"opcodes/pool_gen.html#output","text":"ipool : an index identifying this pool. This index is used when calling any pool opcode","title":"Output"},{"location":"opcodes/pool_gen.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/pool_gen.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 opcode pool_print , 0 , i i pool xin i 0 = 0 i size = pool_size ( i pool ) while i 0 < i size do i val = pool_at ( i pool , i 0 ) print i val i 0 += 1 od endop instr test1 i pool pool_gen 100 i size pool_size i pool i capacity pool_capacity i pool print i size print i capacity pool_print i pool endin instr test2 i pool pool_gen 1 , 100 i size pool_size i pool i capacity pool_capacity i pool print i size print i capacity pool_print i pool endin instr sep prints \" \\n -------------------------------- \\n\\n \" ; turnoff endin </ CsInstruments > < CsScore > i \"test1\" 0 0.1 i \"sep\" 0.1 0.1 i \"test2\" 0.2 0.1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pool_gen.html#see-also","text":"pool_new pool_push pool_pop pool_size pool_capacity","title":"See also"},{"location":"opcodes/pool_gen.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/pool_new.html","text":"pool_new Abstract Create an empty pool Description A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. pool_new creates an empty pool. To use the pool it must be first filled with values via pool_push . If a size is given, a pool of the given size is allocated and the size can't be modified. If no size is given, a pool of variable size is created. Note A variable size pool produces allocations during performance, which might be a problem in certain situations / architectures. Syntax ipool pool_new isize=0 Arguments isize : the size of the pool. If leaved out or set as 0, a pool of variable size is created. Values can be pushed via pool_push and the pool will grow to accomodate these. Output ipool : an index identifying this pool. This index is used when calling any pool opcode Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; create a global pool of fixed capacity gi pool pool_new 100 instr 1 pool_push gi pool , 45 pool_push gi pool , 47 i size pool_size gi pool print i size i num1 pool_pop gi pool i num2 pool_pop gi pool print i num1 print i num2 i size pool_size gi pool print i size turnoff endin </ CsInstruments > < CsScore > i 1 0 1 e 5 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also pool_gen pool_push pool_pop pool_size pool_capacity Credits Eduardo Moguillansky, 2019","title":"pool_new"},{"location":"opcodes/pool_new.html#pool_new","text":"","title":"pool_new"},{"location":"opcodes/pool_new.html#abstract","text":"Create an empty pool","title":"Abstract"},{"location":"opcodes/pool_new.html#description","text":"A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. pool_new creates an empty pool. To use the pool it must be first filled with values via pool_push . If a size is given, a pool of the given size is allocated and the size can't be modified. If no size is given, a pool of variable size is created. Note A variable size pool produces allocations during performance, which might be a problem in certain situations / architectures.","title":"Description"},{"location":"opcodes/pool_new.html#syntax","text":"ipool pool_new isize=0","title":"Syntax"},{"location":"opcodes/pool_new.html#arguments","text":"isize : the size of the pool. If leaved out or set as 0, a pool of variable size is created. Values can be pushed via pool_push and the pool will grow to accomodate these.","title":"Arguments"},{"location":"opcodes/pool_new.html#output","text":"ipool : an index identifying this pool. This index is used when calling any pool opcode","title":"Output"},{"location":"opcodes/pool_new.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/pool_new.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; create a global pool of fixed capacity gi pool pool_new 100 instr 1 pool_push gi pool , 45 pool_push gi pool , 47 i size pool_size gi pool print i size i num1 pool_pop gi pool i num2 pool_pop gi pool print i num1 print i num2 i size pool_size gi pool print i size turnoff endin </ CsInstruments > < CsScore > i 1 0 1 e 5 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pool_new.html#see-also","text":"pool_gen pool_push pool_pop pool_size pool_capacity","title":"See also"},{"location":"opcodes/pool_new.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/pool_pop.html","text":"pool_pop Abstract Pop (get) an item from a pool Description A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. To get a value, call pool_pop and when finished using it the value is returned to the pool with pool_push . Syntax ivalue pool_pop ipool kvalue pool_pop ipool Arguments ipool : the pool to push the value to Output ivalue / kvalue : the value to push Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; create a global pool for all instances gi pool pool_gen 1 , 1000 ; create audio buses gi numbuses = 200 zakinit gi numbuses , 1 ; a pool of buses gi buses pool_gen gi numbuses ; release item back to instance pool, print a message ; when that happens opcode pool_release_instance , 0 , ii i pool , i p1 xin i val = f rac2int ( i p1 , pool_capacity ( i pool )) defer \"prints\" , \"releasing back to pool %d \\n \" , i val pool_push i pool , i val , 1 endop instr exit exitnow endin ; schedule and control audio generator instr controlsaw ; get an unused bus i bus = pool_pop ( gi buses ) prints \"Using bus %d \\n \" , i bus i freq = p5 i cap pool_capacity gi pool ; get a unique instance number for \"saw\" instrument i saw = nstrnum ( \"saw\" ) + pool_pop ( gi pool ) / i cap schedule i saw , 0 , p3 , i bus , i freq ; modulate the frequency pwrite i saw , 5 , linseg ( i freq , p3 , i freq * 0.1 ) ; get a unique instance number for filter instrument i filter = nstrnum ( \"filter\" ) + pool_pop ( gi pool ) / i cap schedule i filter , 0 , p3 , i bus , 100 ; modulate its cutoff freq. pwrite i filter , 5 , linseg ( 100 , p3 , 4000 ) ; release bus back to pool when finished (notice the 1 at the end) ; we could have done ; defer \"pool_push\", gibuses, ibus pool_push gi buses , i bus , 1 endin instr saw i bus = p4 k freq = p5 i amp = 0.02 i fade = 0.05 a 0 = vco2 ( i amp , k freq ) a 0 += vco2 ( i amp , k freq * 0.5 ) a 0 += vco2 ( i amp , k freq * 0.25 ) a 0 *= cosseg ( 0 , p3 * 0.5 , 1 , p3 * 0.5 , 0 ) ; write audio to bus zawm a 0 , i bus ; release instance back to the pool pool_release_instance gi pool , p1 endin ; filter audio in bus, output to the outside world instr filter i bus = p4 k freq = p5 a 0 zar i bus a 0 zdf_ladder a 0 , k freq , 18 outch 1 , a 0 endin instr + example1 i dur = 10 ; dur of each note i offset = 0.6 ; offset between notes i Freqs [] genarray 1000 , 8000 , 100 ; begin freq. of gliss. for each note printarray i Freqs ; create a note for each frequency i 0 = 0 while i 0 < lenarray ( i Freqs ) do schedule \"controlsaw\" , i offset * i 0 , i dur , 0 , i Freqs [ i 0 ] i 0 += 1 od ; clear zak zacl 0 , gi numbuses ; schedule exit schedule \"exit\" , i offset * i 0 + i dur + 1 , - 1 endin schedule \"example1\" , 0 , - 1 </ CsInstruments > < CsScore > </ CsScore > </ CsoundSynthesizer > See also pool_push pool_new pool_gen pool_size pool_capacity Credits Eduardo Moguillansky, 2019","title":"pool_pop"},{"location":"opcodes/pool_pop.html#pool_pop","text":"","title":"pool_pop"},{"location":"opcodes/pool_pop.html#abstract","text":"Pop (get) an item from a pool","title":"Abstract"},{"location":"opcodes/pool_pop.html#description","text":"A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. To get a value, call pool_pop and when finished using it the value is returned to the pool with pool_push .","title":"Description"},{"location":"opcodes/pool_pop.html#syntax","text":"ivalue pool_pop ipool kvalue pool_pop ipool","title":"Syntax"},{"location":"opcodes/pool_pop.html#arguments","text":"ipool : the pool to push the value to","title":"Arguments"},{"location":"opcodes/pool_pop.html#output","text":"ivalue / kvalue : the value to push","title":"Output"},{"location":"opcodes/pool_pop.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/pool_pop.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; create a global pool for all instances gi pool pool_gen 1 , 1000 ; create audio buses gi numbuses = 200 zakinit gi numbuses , 1 ; a pool of buses gi buses pool_gen gi numbuses ; release item back to instance pool, print a message ; when that happens opcode pool_release_instance , 0 , ii i pool , i p1 xin i val = f rac2int ( i p1 , pool_capacity ( i pool )) defer \"prints\" , \"releasing back to pool %d \\n \" , i val pool_push i pool , i val , 1 endop instr exit exitnow endin ; schedule and control audio generator instr controlsaw ; get an unused bus i bus = pool_pop ( gi buses ) prints \"Using bus %d \\n \" , i bus i freq = p5 i cap pool_capacity gi pool ; get a unique instance number for \"saw\" instrument i saw = nstrnum ( \"saw\" ) + pool_pop ( gi pool ) / i cap schedule i saw , 0 , p3 , i bus , i freq ; modulate the frequency pwrite i saw , 5 , linseg ( i freq , p3 , i freq * 0.1 ) ; get a unique instance number for filter instrument i filter = nstrnum ( \"filter\" ) + pool_pop ( gi pool ) / i cap schedule i filter , 0 , p3 , i bus , 100 ; modulate its cutoff freq. pwrite i filter , 5 , linseg ( 100 , p3 , 4000 ) ; release bus back to pool when finished (notice the 1 at the end) ; we could have done ; defer \"pool_push\", gibuses, ibus pool_push gi buses , i bus , 1 endin instr saw i bus = p4 k freq = p5 i amp = 0.02 i fade = 0.05 a 0 = vco2 ( i amp , k freq ) a 0 += vco2 ( i amp , k freq * 0.5 ) a 0 += vco2 ( i amp , k freq * 0.25 ) a 0 *= cosseg ( 0 , p3 * 0.5 , 1 , p3 * 0.5 , 0 ) ; write audio to bus zawm a 0 , i bus ; release instance back to the pool pool_release_instance gi pool , p1 endin ; filter audio in bus, output to the outside world instr filter i bus = p4 k freq = p5 a 0 zar i bus a 0 zdf_ladder a 0 , k freq , 18 outch 1 , a 0 endin instr + example1 i dur = 10 ; dur of each note i offset = 0.6 ; offset between notes i Freqs [] genarray 1000 , 8000 , 100 ; begin freq. of gliss. for each note printarray i Freqs ; create a note for each frequency i 0 = 0 while i 0 < lenarray ( i Freqs ) do schedule \"controlsaw\" , i offset * i 0 , i dur , 0 , i Freqs [ i 0 ] i 0 += 1 od ; clear zak zacl 0 , gi numbuses ; schedule exit schedule \"exit\" , i offset * i 0 + i dur + 1 , - 1 endin schedule \"example1\" , 0 , - 1 </ CsInstruments > < CsScore > </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pool_pop.html#see-also","text":"pool_push pool_new pool_gen pool_size pool_capacity","title":"See also"},{"location":"opcodes/pool_pop.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/pool_push.html","text":"pool_push Abstract Push an item into a pool Description A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. To get a value, call pool_pop and when finished using it the value is returned to the pool with pool_push . Syntax pool_push ipool, ivalue, iwhen=0 pool_push ipool, kvalue Arguments ipool : the pool to push the value to ivalue / kvalue : the value to push iwhen : if 0, the value is pushed at init time, if 1 the value is pushed at release time. This argument can only be used when calling the opcode at init time Output Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; create a global pool for all instances gi pool pool_gen 1 , 1000 ; create audio buses gi numbuses = 200 zakinit gi numbuses , 1 ; a pool of buses gi buses pool_gen gi numbuses ; release item back to instance pool, print a message ; when that happens opcode pool_release_instance , 0 , ii i pool , i p1 xin i val = f rac2int ( i p1 , pool_capacity ( i pool )) defer \"prints\" , \"releasing back to pool %d \\n \" , i val pool_push i pool , i val , 1 endop instr exit exitnow endin ; schedule and control audio generator instr controlsaw ; get an unused bus i bus = pool_pop ( gi buses ) prints \"Using bus %d \\n \" , i bus i freq = p5 i cap pool_capacity gi pool ; get a unique instance number for \"saw\" instrument i saw = nstrnum ( \"saw\" ) + pool_pop ( gi pool ) / i cap schedule i saw , 0 , p3 , i bus , i freq ; modulate the frequency pwrite i saw , 5 , linseg ( i freq , p3 , i freq * 0.1 ) ; get a unique instance number for filter instrument i filter = nstrnum ( \"filter\" ) + pool_pop ( gi pool ) / i cap schedule i filter , 0 , p3 , i bus , 100 ; modulate its cutoff freq. pwrite i filter , 5 , linseg ( 100 , p3 , 4000 ) ; release bus back to pool when finished (notice the 1 at the end) ; we could have done ; defer \"pool_push\", gibuses, ibus pool_push gi buses , i bus , 1 endin instr saw i bus = p4 k freq = p5 i amp = 0.02 i fade = 0.05 a 0 = vco2 ( i amp , k freq ) a 0 += vco2 ( i amp , k freq * 0.5 ) a 0 += vco2 ( i amp , k freq * 0.25 ) a 0 *= cosseg ( 0 , p3 * 0.5 , 1 , p3 * 0.5 , 0 ) ; write audio to bus zawm a 0 , i bus ; release instance back to the pool pool_release_instance gi pool , p1 endin ; filter audio in bus, output to the outside world instr filter i bus = p4 k freq = p5 a 0 zar i bus a 0 zdf_ladder a 0 , k freq , 18 outch 1 , a 0 endin instr + example1 i dur = 10 ; dur of each note i offset = 0.6 ; offset between notes i Freqs [] genarray 1000 , 8000 , 100 ; begin freq. of gliss. for each note printarray i Freqs ; create a note for each frequency i 0 = 0 while i 0 < lenarray ( i Freqs ) do schedule \"controlsaw\" , i offset * i 0 , i dur , 0 , i Freqs [ i 0 ] i 0 += 1 od ; clear zak zacl 0 , gi numbuses ; schedule exit schedule \"exit\" , i offset * i 0 + i dur + 1 , - 1 endin schedule \"example1\" , 0 , - 1 </ CsInstruments > < CsScore > </ CsScore > </ CsoundSynthesizer > See also pool_pop pool_new pool_gen Credits Eduardo Moguillansky, 2019","title":"pool_push"},{"location":"opcodes/pool_push.html#pool_push","text":"","title":"pool_push"},{"location":"opcodes/pool_push.html#abstract","text":"Push an item into a pool","title":"Abstract"},{"location":"opcodes/pool_push.html#description","text":"A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. To get a value, call pool_pop and when finished using it the value is returned to the pool with pool_push .","title":"Description"},{"location":"opcodes/pool_push.html#syntax","text":"pool_push ipool, ivalue, iwhen=0 pool_push ipool, kvalue","title":"Syntax"},{"location":"opcodes/pool_push.html#arguments","text":"ipool : the pool to push the value to ivalue / kvalue : the value to push iwhen : if 0, the value is pushed at init time, if 1 the value is pushed at release time. This argument can only be used when calling the opcode at init time","title":"Arguments"},{"location":"opcodes/pool_push.html#output","text":"","title":"Output"},{"location":"opcodes/pool_push.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/pool_push.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; create a global pool for all instances gi pool pool_gen 1 , 1000 ; create audio buses gi numbuses = 200 zakinit gi numbuses , 1 ; a pool of buses gi buses pool_gen gi numbuses ; release item back to instance pool, print a message ; when that happens opcode pool_release_instance , 0 , ii i pool , i p1 xin i val = f rac2int ( i p1 , pool_capacity ( i pool )) defer \"prints\" , \"releasing back to pool %d \\n \" , i val pool_push i pool , i val , 1 endop instr exit exitnow endin ; schedule and control audio generator instr controlsaw ; get an unused bus i bus = pool_pop ( gi buses ) prints \"Using bus %d \\n \" , i bus i freq = p5 i cap pool_capacity gi pool ; get a unique instance number for \"saw\" instrument i saw = nstrnum ( \"saw\" ) + pool_pop ( gi pool ) / i cap schedule i saw , 0 , p3 , i bus , i freq ; modulate the frequency pwrite i saw , 5 , linseg ( i freq , p3 , i freq * 0.1 ) ; get a unique instance number for filter instrument i filter = nstrnum ( \"filter\" ) + pool_pop ( gi pool ) / i cap schedule i filter , 0 , p3 , i bus , 100 ; modulate its cutoff freq. pwrite i filter , 5 , linseg ( 100 , p3 , 4000 ) ; release bus back to pool when finished (notice the 1 at the end) ; we could have done ; defer \"pool_push\", gibuses, ibus pool_push gi buses , i bus , 1 endin instr saw i bus = p4 k freq = p5 i amp = 0.02 i fade = 0.05 a 0 = vco2 ( i amp , k freq ) a 0 += vco2 ( i amp , k freq * 0.5 ) a 0 += vco2 ( i amp , k freq * 0.25 ) a 0 *= cosseg ( 0 , p3 * 0.5 , 1 , p3 * 0.5 , 0 ) ; write audio to bus zawm a 0 , i bus ; release instance back to the pool pool_release_instance gi pool , p1 endin ; filter audio in bus, output to the outside world instr filter i bus = p4 k freq = p5 a 0 zar i bus a 0 zdf_ladder a 0 , k freq , 18 outch 1 , a 0 endin instr + example1 i dur = 10 ; dur of each note i offset = 0.6 ; offset between notes i Freqs [] genarray 1000 , 8000 , 100 ; begin freq. of gliss. for each note printarray i Freqs ; create a note for each frequency i 0 = 0 while i 0 < lenarray ( i Freqs ) do schedule \"controlsaw\" , i offset * i 0 , i dur , 0 , i Freqs [ i 0 ] i 0 += 1 od ; clear zak zacl 0 , gi numbuses ; schedule exit schedule \"exit\" , i offset * i 0 + i dur + 1 , - 1 endin schedule \"example1\" , 0 , - 1 </ CsInstruments > < CsScore > </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pool_push.html#see-also","text":"pool_pop pool_new pool_gen","title":"See also"},{"location":"opcodes/pool_push.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/pool_size.html","text":"pool_size Abstract Returns the size of a pool Description A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. To get a value, call pool_pop and when finished using it the value is returned to the pool with pool_push . pool_size returns the size of the pool (the number of items in it, not the capacity, see pool_capacity for that) Note To differenciate between the opcode being called at init- or at performance time, use the functional style pool_size:i(ipool) or pool_size:k(ipool) Syntax isize pool_size ipool ksize pool_size kpool Arguments ipool : the pool to push the value to Output isize / ksize : the number of items in the pool Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for pool_size pool_size returns the size of the pool, either at init or at performance time The size of a pool is the number of items actually inside the pool (see also pool_capacity) */ opcode print_pool , 0 , i i pool xin i 0 = 0 i size = pool_size ( i pool ) while i 0 < i size do i tem = pool_at ( i pool , i 0 ) print i tem i 0 += 1 od endop instr 1 i pool pool_gen 10 i 1 pool_pop i pool i 2 pool_pop i pool prints \" \\n <<< pool size: %d , pool capacity: %d >>> \\n\\n \" , \\ pool_size : i ( i pool ), pool_capacity : i ( i pool ) print_pool i pool turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer > See also pool_capacity pool_pop pool_new pool_gen Credits Eduardo Moguillansky, 2019","title":"pool_size"},{"location":"opcodes/pool_size.html#pool_size","text":"","title":"pool_size"},{"location":"opcodes/pool_size.html#abstract","text":"Returns the size of a pool","title":"Abstract"},{"location":"opcodes/pool_size.html#description","text":"A pool is actually a stack of numbers, based on an array. The pool_ opcodes implement a stack of numbers. This is useful when assigning ids to resources, like assigning fractional numbers to instrument instances to access them individually. To get a value, call pool_pop and when finished using it the value is returned to the pool with pool_push . pool_size returns the size of the pool (the number of items in it, not the capacity, see pool_capacity for that) Note To differenciate between the opcode being called at init- or at performance time, use the functional style pool_size:i(ipool) or pool_size:k(ipool)","title":"Description"},{"location":"opcodes/pool_size.html#syntax","text":"isize pool_size ipool ksize pool_size kpool","title":"Syntax"},{"location":"opcodes/pool_size.html#arguments","text":"ipool : the pool to push the value to","title":"Arguments"},{"location":"opcodes/pool_size.html#output","text":"isize / ksize : the number of items in the pool","title":"Output"},{"location":"opcodes/pool_size.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/pool_size.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for pool_size pool_size returns the size of the pool, either at init or at performance time The size of a pool is the number of items actually inside the pool (see also pool_capacity) */ opcode print_pool , 0 , i i pool xin i 0 = 0 i size = pool_size ( i pool ) while i 0 < i size do i tem = pool_at ( i pool , i 0 ) print i tem i 0 += 1 od endop instr 1 i pool pool_gen 10 i 1 pool_pop i pool i 2 pool_pop i pool prints \" \\n <<< pool size: %d , pool capacity: %d >>> \\n\\n \" , \\ pool_size : i ( i pool ), pool_capacity : i ( i pool ) print_pool i pool turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pool_size.html#see-also","text":"pool_capacity pool_pop pool_new pool_gen","title":"See also"},{"location":"opcodes/pool_size.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/pread.html","text":"pread Abstract Read pfield values from any active instrument instance Description pread can be used to query the pfield value of a running instance (possibly a fractional instrument number) of an instrument. Together with pwrite it can be used to establish a two-way communication between two running instances of any two instruments. It no instance is found that matches the given instrument number, the output value is set to inotfound . Behaviour If no matching instance is found, pread returns inotfound . Reporting starts at the moment a matching instance is found. To avoid a continuous search, set instrnum as negative number. In this case, a matching instance is searched only once, and, if not found, this opcode becomes a noop If an instance is found and stops, pread returns inotfound from the moment the instance stops and no new instance is searched. Syntax output : i | k pread instrnum : i , index : i | k [, inotfound =- 1 ] Arguments instrnum (i): the (fractional) instrument number to modify index (i or k): the index of the pfield to read. If kindex is 4, then p4 will be modified inotfound : the value to return if instrnum is not found. To avoid misinterpretation, this value should be different than any expected value of the pfield Output output (i or k): the current value of the given pfield. Will be inotfound if no matching instance has been found. Execution Time Init (if output is of i-type) Performance (if output is of k-type) Examples < CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > /* Example file for pread ====================== ivalue pread instrnum, index [, inotfound=-1] kvalue pread instrnum, kindex [, inotfound=-1] pread reads a pfield value from an active instrument Returns inotfound if instrnum is not active Raises a performance error if index is out of range */ instr 1 print p4 endin instr 2 i p4 pread 1.01 , 4 printf \"<<<< instr 1.01 p4= %f >>>> \\n \" , 1 , i p4 turnoff endin </ CsInstruments > < CsScore > i 1.01 0 2 95 i 2 1 0.1 </ CsScore > </ CsoundSynthesizer > See also pwrite pset p passign uniqinstance Credits Eduardo Moguillansky, 2019","title":"pread"},{"location":"opcodes/pread.html#pread","text":"","title":"pread"},{"location":"opcodes/pread.html#abstract","text":"Read pfield values from any active instrument instance","title":"Abstract"},{"location":"opcodes/pread.html#description","text":"pread can be used to query the pfield value of a running instance (possibly a fractional instrument number) of an instrument. Together with pwrite it can be used to establish a two-way communication between two running instances of any two instruments. It no instance is found that matches the given instrument number, the output value is set to inotfound .","title":"Description"},{"location":"opcodes/pread.html#behaviour","text":"If no matching instance is found, pread returns inotfound . Reporting starts at the moment a matching instance is found. To avoid a continuous search, set instrnum as negative number. In this case, a matching instance is searched only once, and, if not found, this opcode becomes a noop If an instance is found and stops, pread returns inotfound from the moment the instance stops and no new instance is searched.","title":"Behaviour"},{"location":"opcodes/pread.html#syntax","text":"output : i | k pread instrnum : i , index : i | k [, inotfound =- 1 ]","title":"Syntax"},{"location":"opcodes/pread.html#arguments","text":"instrnum (i): the (fractional) instrument number to modify index (i or k): the index of the pfield to read. If kindex is 4, then p4 will be modified inotfound : the value to return if instrnum is not found. To avoid misinterpretation, this value should be different than any expected value of the pfield","title":"Arguments"},{"location":"opcodes/pread.html#output","text":"output (i or k): the current value of the given pfield. Will be inotfound if no matching instance has been found.","title":"Output"},{"location":"opcodes/pread.html#execution-time","text":"Init (if output is of i-type) Performance (if output is of k-type)","title":"Execution Time"},{"location":"opcodes/pread.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > /* Example file for pread ====================== ivalue pread instrnum, index [, inotfound=-1] kvalue pread instrnum, kindex [, inotfound=-1] pread reads a pfield value from an active instrument Returns inotfound if instrnum is not active Raises a performance error if index is out of range */ instr 1 print p4 endin instr 2 i p4 pread 1.01 , 4 printf \"<<<< instr 1.01 p4= %f >>>> \\n \" , 1 , i p4 turnoff endin </ CsInstruments > < CsScore > i 1.01 0 2 95 i 2 1 0.1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pread.html#see-also","text":"pwrite pset p passign uniqinstance","title":"See also"},{"location":"opcodes/pread.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/pwrite.html","text":"pwrite Abstract Modify pfield values of an active instrument instance Description pwrite can be used to modify the value of a pfield of a running instance (possibly a fractional instrument number). A matching instance is searched at performance time, so that its behaviour can be controlled via if or timout statements. If no active instance is found, search is retried until a matching instance is found. To avoid retrying, set instrnum to a negative value. If the instance ceases to exist during another instrument is modifying its pfield values, nothing happens. pwrite notices that the instance is not active anymore and becomes a NOOP . Exact instance vs Broadcasting If instrnum is a fractional instrument number, pwrite will only affect the first instance matching this exact number. If instrnum is set to an integer number, pwrite will broadcast the changes to ALL instruments with the same integer number. Note Setting a value of a pfield out of range will result in a performance error. Syntax pwrite instrnum:i, index:i|k, value:i|k Arguments instrnum : the (fractional) instrument number to modify iindex / kindex : the index of the pfield to modify. If kindex is 4, then p4 will be modified ivalue / kvalue : the new value of the given pfield Execution Time Init (if index and value are i-values) Performance (if either index or value are k-variables) Examples < CsoundSynthesizer > < CsOptions > - odac - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr exit exitnow endin ;; Example 1. instr 2 creates and controls instr 1 instr 1 pset 0 , 0 , 0 , 40 , 50 k t timeinsts k 4 = p4 k 5 = p5 printf \"time: %.4f \\t instance: %.3f \\t p4: %f \\t p5: %f \\n \" , metro ( 20 ), k t , p1 , k 4 , k 5 endin instr 2 k val line 0 , p3 , 1 pwrite 1.01 , 4 , k val pwrite 1.02 , 5 , k val * 2 endin instr example1 schedule 1.01 , 0 , 4 , - 1 schedule 1.02 , 0 , 4 , - 1 schedule 2 , 1 , 1 schedule \"exit\" , 4 , - 1 turnoff endin ;----------------------------- ; Example 2, one instrument modulates another instr ex2_generator pset p1 , p2 , p3 , 0.5 , 1000 , 4000 , 0.1 k amp = p4 k freq = p5 k cutoff = p6 k resonance = p7 a saw vco2 , k amp , k freq a out moogladder2 , a saw , k cutoff , k resonance a out *= linsegr ( 0 , 0.1 , 1 , 0.1 , 0 ) outs a out , a out endin instr ex2_control i glissdur = p4 i num = nstrnum ( \"ex2_generator\" ) i num1 = i num + 0.001 i num2 = i num + 0.002 k freq1 linseg ntof ( \"4A\" ), i glissdur , ntof ( \"3A\" ) k freq2 linseg ntof ( \"4F\" ), i glissdur , ntof ( \"3F\" ) ; amp schedule i num1 , 0 , p3 , 0.2 schedule i num2 , 0 , p3 , 0.2 pwrite i num1 , 5 , k freq1 pwrite i num2 , 5 , k freq2 endin instr ex2_broadcast printf \"filter start \\n \" , 1 i num = nstrnum ( \"ex2_generator\" ) k cutoff linseg 4000 , p3 , 400 k resonance linseg 0.1 , p3 * 0.5 , 0.8 pwrite i num , 6 , k cutoff , 7 , k resonance endin instr example2 schedule \"ex2_control\" , 0 , 8 , 4 schedule \"ex2_broadcast\" , 4 , 4 schedule \"exit\" , 8.5 , - 1 turnoff endin ;; Uncomment as needed ; schedule \"example1\", 0, 1 schedule \"example2\" , 0 , 1 </ CsInstruments > < CsScore > </ CsScore > </ CsoundSynthesizer > See also pread pset p passign uniqinstance Credits Eduardo Moguillansky, 2019","title":"pwrite"},{"location":"opcodes/pwrite.html#pwrite","text":"","title":"pwrite"},{"location":"opcodes/pwrite.html#abstract","text":"Modify pfield values of an active instrument instance","title":"Abstract"},{"location":"opcodes/pwrite.html#description","text":"pwrite can be used to modify the value of a pfield of a running instance (possibly a fractional instrument number). A matching instance is searched at performance time, so that its behaviour can be controlled via if or timout statements. If no active instance is found, search is retried until a matching instance is found. To avoid retrying, set instrnum to a negative value. If the instance ceases to exist during another instrument is modifying its pfield values, nothing happens. pwrite notices that the instance is not active anymore and becomes a NOOP .","title":"Description"},{"location":"opcodes/pwrite.html#exact-instance-vs-broadcasting","text":"If instrnum is a fractional instrument number, pwrite will only affect the first instance matching this exact number. If instrnum is set to an integer number, pwrite will broadcast the changes to ALL instruments with the same integer number. Note Setting a value of a pfield out of range will result in a performance error.","title":"Exact instance vs Broadcasting"},{"location":"opcodes/pwrite.html#syntax","text":"pwrite instrnum:i, index:i|k, value:i|k","title":"Syntax"},{"location":"opcodes/pwrite.html#arguments","text":"instrnum : the (fractional) instrument number to modify iindex / kindex : the index of the pfield to modify. If kindex is 4, then p4 will be modified ivalue / kvalue : the new value of the given pfield","title":"Arguments"},{"location":"opcodes/pwrite.html#execution-time","text":"Init (if index and value are i-values) Performance (if either index or value are k-variables)","title":"Execution Time"},{"location":"opcodes/pwrite.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr exit exitnow endin ;; Example 1. instr 2 creates and controls instr 1 instr 1 pset 0 , 0 , 0 , 40 , 50 k t timeinsts k 4 = p4 k 5 = p5 printf \"time: %.4f \\t instance: %.3f \\t p4: %f \\t p5: %f \\n \" , metro ( 20 ), k t , p1 , k 4 , k 5 endin instr 2 k val line 0 , p3 , 1 pwrite 1.01 , 4 , k val pwrite 1.02 , 5 , k val * 2 endin instr example1 schedule 1.01 , 0 , 4 , - 1 schedule 1.02 , 0 , 4 , - 1 schedule 2 , 1 , 1 schedule \"exit\" , 4 , - 1 turnoff endin ;----------------------------- ; Example 2, one instrument modulates another instr ex2_generator pset p1 , p2 , p3 , 0.5 , 1000 , 4000 , 0.1 k amp = p4 k freq = p5 k cutoff = p6 k resonance = p7 a saw vco2 , k amp , k freq a out moogladder2 , a saw , k cutoff , k resonance a out *= linsegr ( 0 , 0.1 , 1 , 0.1 , 0 ) outs a out , a out endin instr ex2_control i glissdur = p4 i num = nstrnum ( \"ex2_generator\" ) i num1 = i num + 0.001 i num2 = i num + 0.002 k freq1 linseg ntof ( \"4A\" ), i glissdur , ntof ( \"3A\" ) k freq2 linseg ntof ( \"4F\" ), i glissdur , ntof ( \"3F\" ) ; amp schedule i num1 , 0 , p3 , 0.2 schedule i num2 , 0 , p3 , 0.2 pwrite i num1 , 5 , k freq1 pwrite i num2 , 5 , k freq2 endin instr ex2_broadcast printf \"filter start \\n \" , 1 i num = nstrnum ( \"ex2_generator\" ) k cutoff linseg 4000 , p3 , 400 k resonance linseg 0.1 , p3 * 0.5 , 0.8 pwrite i num , 6 , k cutoff , 7 , k resonance endin instr example2 schedule \"ex2_control\" , 0 , 8 , 4 schedule \"ex2_broadcast\" , 4 , 4 schedule \"exit\" , 8.5 , - 1 turnoff endin ;; Uncomment as needed ; schedule \"example1\", 0, 1 schedule \"example2\" , 0 , 1 </ CsInstruments > < CsScore > </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pwrite.html#see-also","text":"pread pset p passign uniqinstance","title":"See also"},{"location":"opcodes/pwrite.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/ramptrig.html","text":"ramptrig Abstract A triggerable ramp between 0 and 1 Description ramptrig is a phasor between 0 and 1, with the difference that it stops after reaching its end point. Whenever it is triggered it rewinds to 0 and starts ramping to 1 in the given duration. A trigger detected whenever the value is possitive and higher than the previous value. Usage as envelope generator Together with bpf this can be used to emulate supercollider's Env and EnvGen , where ramptrig is used as a triggerable phasor, passed as an argument to bpf , which generates the envelope. See examples Syntax kout ramptrig ktrig, kdur, ivaluepost=1, ivaluepre=0 kout, kfinished ramptrig ktrig, kdur, ivaluepost=1, ivaluepre=0 Arguments ktrig : whenever this is possitive and higher than last value, kout is rewinded to 0 kdur : the duration of the ramp ivaluepost : value when ramp reaches its end (default=1) ivaluepre : value previous to any trigger (default=0) Output kout : value of the ramp, between 0 and 1. It can also be ivaluepost or ivaluepre if these are set to any other value than the default kfinished : will be one whenever the ramp reaches its end value. Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > ; This is the example file of ramptrig ; ramptrig is a triggerable ramp from 0 to 1 ; xout ramptrig xtrig, kdur sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; Use Case #1: An envelope which can be retriggered instr 1 ; Duration of envelope k dur = 4 ; This is the gate, could be any irregular signal, midi, osc, etc. k trig metro 0.5 ; Whenever ktrig is possitive and higher than previous value, ; kx ramps from 0 to 1 in kdur seconds k x ramptrig k trig , k dur ; actual envelope k env bpf k x * k dur , 0 , 0 , 0.02 , 1 , k dur , 0 a sig oscili 0.2 , 1000 ; asig pinker a sig *= interp ( k env ) outs a sig , a sig endin ; Use Case #2: Use finished trigger to signal something instr 2 k trig metro 1 / 4 k trig delayk k trig , 0.5 i dur = 2 k phase , k finished1 ramptrig k trig , 2 printf \"finished! \\n \" , k finished1 k env bpf k phase * i dur , 0 , 0 , 0.5 , 1 , 0.8 , 0.5 , 1 , 1 , i dur , 0 a sig = pinker () * interp ( k env ) outs a sig , a sig endin </ CsInstruments > < CsScore > i 1 0 10 ; i2 0 12 ; i3 0 20 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also linenv sc_phasor bpf Credits Eduardo Moguillansky, 2019","title":"ramptrig"},{"location":"opcodes/ramptrig.html#ramptrig","text":"","title":"ramptrig"},{"location":"opcodes/ramptrig.html#abstract","text":"A triggerable ramp between 0 and 1","title":"Abstract"},{"location":"opcodes/ramptrig.html#description","text":"ramptrig is a phasor between 0 and 1, with the difference that it stops after reaching its end point. Whenever it is triggered it rewinds to 0 and starts ramping to 1 in the given duration. A trigger detected whenever the value is possitive and higher than the previous value. Usage as envelope generator Together with bpf this can be used to emulate supercollider's Env and EnvGen , where ramptrig is used as a triggerable phasor, passed as an argument to bpf , which generates the envelope. See examples","title":"Description"},{"location":"opcodes/ramptrig.html#syntax","text":"kout ramptrig ktrig, kdur, ivaluepost=1, ivaluepre=0 kout, kfinished ramptrig ktrig, kdur, ivaluepost=1, ivaluepre=0","title":"Syntax"},{"location":"opcodes/ramptrig.html#arguments","text":"ktrig : whenever this is possitive and higher than last value, kout is rewinded to 0 kdur : the duration of the ramp ivaluepost : value when ramp reaches its end (default=1) ivaluepre : value previous to any trigger (default=0)","title":"Arguments"},{"location":"opcodes/ramptrig.html#output","text":"kout : value of the ramp, between 0 and 1. It can also be ivaluepost or ivaluepre if these are set to any other value than the default kfinished : will be one whenever the ramp reaches its end value.","title":"Output"},{"location":"opcodes/ramptrig.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/ramptrig.html#examples","text":"< CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > ; This is the example file of ramptrig ; ramptrig is a triggerable ramp from 0 to 1 ; xout ramptrig xtrig, kdur sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; Use Case #1: An envelope which can be retriggered instr 1 ; Duration of envelope k dur = 4 ; This is the gate, could be any irregular signal, midi, osc, etc. k trig metro 0.5 ; Whenever ktrig is possitive and higher than previous value, ; kx ramps from 0 to 1 in kdur seconds k x ramptrig k trig , k dur ; actual envelope k env bpf k x * k dur , 0 , 0 , 0.02 , 1 , k dur , 0 a sig oscili 0.2 , 1000 ; asig pinker a sig *= interp ( k env ) outs a sig , a sig endin ; Use Case #2: Use finished trigger to signal something instr 2 k trig metro 1 / 4 k trig delayk k trig , 0.5 i dur = 2 k phase , k finished1 ramptrig k trig , 2 printf \"finished! \\n \" , k finished1 k env bpf k phase * i dur , 0 , 0 , 0.5 , 1 , 0.8 , 0.5 , 1 , 1 , i dur , 0 a sig = pinker () * interp ( k env ) outs a sig , a sig endin </ CsInstruments > < CsScore > i 1 0 10 ; i2 0 12 ; i3 0 20 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/ramptrig.html#see-also","text":"linenv sc_phasor bpf","title":"See also"},{"location":"opcodes/ramptrig.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/ref.html","text":"ref Abstract Get a reference to a variable Description ref and deref implement a mechanism to pass a reference to an array, allowing to share it across instruments, opcodes, etc. A ref is a proxy to an axisting array. Refs are reference counted and deallocate themselves when out of scope and not being referenced by any object. It makes it possible to pass arrays by reference to user defined opcodes, allowing to modify an array in place, to skip copying memory, etc. Arrays i Xs [] fillarray 0 , 1 , 2 , 3 , 4 i ref ref i Xs i Ys [] deref i ref In the case above, iYs shares the same memory as iXs and any modification in one array will be visible in the other. Moving arrays It is possible for the ref opcode to own the memory of the array. This can be used for the cases where a ref is passed to an event which is scheduled at a point in time later that the end of the event which owns the array. In this case the array if moved to a global space and owns the memory until no other events are referencing it. Syntax iref ref xArray, [imove=0] Arguments xArray : the array to be referenced move : for arrays, it is possible to specify that the reference owns the memory. This is useful for the niche case where a reference is passed to an event scheduled at a point in time later that the end of the current event. Without this, the ref would go out of scope before the deref takes place. Output iref : an integer identifying the reference handle. Execution Time Init Examples < CsoundSynthesizer > < CsOptions > - m0 - d </ CsOptions > < CsInstruments > /* Example file for ref / deref */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gi A [] fillarray 0 , 1000 , 2000 , 3000 ; Example 1: take a ref from an array, deref it to create a second view of it instr 1 ; a source array i X [] fillarray 0 , 10 , 20 , 30 , 40 ; create a ref of iXs, return the index i ref ref i X ; now iYs points to iXs i Y [] deref i ref printarray i Y , \"\" , \"instrument 1, iY\" i Z [] fillarray 0 , 1 , 3 , 5 , 7 ; create a ref, pass it to instr. 2 schedule 2 , 0 , 1 , ref ( i Z ) ; create another ref of iZ. In this case the event is scheduled ; in the future, so the source will not exist anymore when instr. 2 ; is scheduled. This should fail. schedule 2 , 1 , 1 , ref ( i Z ) turnoff endin instr 2 i ref = p4 if refvalid ( i ref ) == 1 then i Zs [] deref i ref printarray i Zs , \"\" , \"p1=2, iZs\" else prints \" \\n >>> The reference has become invalid <<< \\n \" endif turnoff endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; Example 2: move semantics for arrays instr 3 ; create a source array k Xs [] fillarray 1 , 1 , 2 , 3 , 5 , 8 , 13 ; In order to bridge the time gap between the end of life of the source ; of a ref and the scheduled event where a deref is taken, it is possible ; to create a forward reference, a \"promise\" that one deref has been scheduled ; in the future. ; short lived event, ends before this event schedule 4 , 0 , 0.1 , ref ( k Xs ) ; starts before we end, but survives us schedule 4 , p3 - 0.1 , 0.2 , ref ( k Xs ) ; starts after we end, we need a move schedule 4 , p3 + 1 , 0.1 , ref ( k Xs , 1 ) defer \"prints\" , \" <<< instr. 3 finished >>> \\n \" endin instr 4 prints \"instr. 4 \\n \" k View [] deref p4 printarray k View defer \"prints\" , \" <<< instr. 4 finished >>> \\n \" ; At deinition time the memory of the `iView` array is marked as deallocated. ; The handle (a global structure created by the `ref` opcode) which owns the memory, ; is signaled that no other clients of this data are alive. It deallocates the ; original memory and frees itself endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; test: multiple derefs instr 5 i Xs [] fillarray 0 , 1 , 4 , 9 i ref ref i Xs i Ys [] deref i ref i Zs [] deref i ref printarray i Ys printarray i Zs i Xs [ 0 ] = 100 printarray i Zs turnoff endin ; test performance of pass-by-value vs pass-by-reference opcode arrayadd , i[] , i[]i ; pass by value in and out i In [], i x xin i Out [] = i In + i x xout i Out endop opcode arrayaddref , i[] , ii ; pass by ref in, by value out i ref , i x xin i In [] deref i ref i Out [] = i In + i x xout i Out endop opcode arrayadd_inplace , 0 , ii ; in place i ref , i x xin i In [] deref i ref i In += i x endop opcode arrayadd_byref_inout , 0 , iii ; pass by ref in and out i refin , i refout , i x xin i In [] deref i refin i Out [] deref i refout if lenarray ( i Out ) >= lenarray ( i In ) then i Out = i In + i x endif endop instr testUdoPerformance1 ; Here we test the performance gain of passing arrays by reference. ; Passing the input array by reference seems to produce a speedup of ~25%, i num = 100000 i Xs [] genarray 0 , i num i i = 0 i t0 rtclock while i i < 20 do i Ys [] arrayadd i Xs , 2.0 i i += 1 od i t1 rtclock prints \"Dur UDO pass by value = %.8f \\n \" , i t1 - i t0 i t0 rtclock i Ys [] arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i t1 rtclock prints \"Dur UDO pass by value unroll = %.8f \\n \" , i t1 - i t0 i ref = ref ( i Xs ) i t0 rtclock i Y0 [] arrayaddref i ref , 0.1 i Y0 arrayaddref i ref , 0.2 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i t1 rtclock prints \"Dur UDO pass by ref input = %.8f \\n \" , i t1 - i t0 i Zs [] genarray 0 , i num i Out [] init lenarray ( i Zs ) i t0 rtclock i refZ = ref ( i Zs ) i refOut = ref ( i Out ) arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 i t1 rtclock prints \"Dur UDO pass by ref in and out= %.8f \\n \" , i t1 - i t0 ; printarray iOut endin instr 7 i In [] genarray 0 , 1000 i Out [] init lenarray ( i In ) arrayadd_byref_inout ref ( i In ), ref ( i Out ), 0.5 turnoff endin instr 8 ; test / k arrays ; 1. A way to convert a i-array to a k-array by taking a reference i Xs [] genarray 0 , 99 k Xs [] deref ref ( i Xs ) k Xs [ 0 ] = timeinsts () printarray k Xs , metro ( 8 ) endin instr 9 ; we need genarray_i because otherwise kXs is not initialized at i-time k Xs [] genarray 0 , 9 i Xs [] deref ref ( k Xs ) i Xs += 10 printarray i Xs printarray k Xs turnoff endin ; schedule 1, 0, 1 ; schedule 3, 0, 1 ; schedule 5, 0, 0.1 schedule \"testUdoPerformance1\" , 0 , 0.1 ; schedule 8, 0, 4 </ CsInstruments > < CsScore > e 10 </ CsScore > </ CsoundSynthesizer > See also deref defer schedule event release Credits Eduardo Moguillansky, 2019","title":"ref"},{"location":"opcodes/ref.html#ref","text":"","title":"ref"},{"location":"opcodes/ref.html#abstract","text":"Get a reference to a variable","title":"Abstract"},{"location":"opcodes/ref.html#description","text":"ref and deref implement a mechanism to pass a reference to an array, allowing to share it across instruments, opcodes, etc. A ref is a proxy to an axisting array. Refs are reference counted and deallocate themselves when out of scope and not being referenced by any object. It makes it possible to pass arrays by reference to user defined opcodes, allowing to modify an array in place, to skip copying memory, etc.","title":"Description"},{"location":"opcodes/ref.html#arrays","text":"i Xs [] fillarray 0 , 1 , 2 , 3 , 4 i ref ref i Xs i Ys [] deref i ref In the case above, iYs shares the same memory as iXs and any modification in one array will be visible in the other.","title":"Arrays"},{"location":"opcodes/ref.html#moving-arrays","text":"It is possible for the ref opcode to own the memory of the array. This can be used for the cases where a ref is passed to an event which is scheduled at a point in time later that the end of the event which owns the array. In this case the array if moved to a global space and owns the memory until no other events are referencing it.","title":"Moving arrays"},{"location":"opcodes/ref.html#syntax","text":"iref ref xArray, [imove=0]","title":"Syntax"},{"location":"opcodes/ref.html#arguments","text":"xArray : the array to be referenced move : for arrays, it is possible to specify that the reference owns the memory. This is useful for the niche case where a reference is passed to an event scheduled at a point in time later that the end of the current event. Without this, the ref would go out of scope before the deref takes place.","title":"Arguments"},{"location":"opcodes/ref.html#output","text":"iref : an integer identifying the reference handle.","title":"Output"},{"location":"opcodes/ref.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/ref.html#examples","text":"< CsoundSynthesizer > < CsOptions > - m0 - d </ CsOptions > < CsInstruments > /* Example file for ref / deref */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gi A [] fillarray 0 , 1000 , 2000 , 3000 ; Example 1: take a ref from an array, deref it to create a second view of it instr 1 ; a source array i X [] fillarray 0 , 10 , 20 , 30 , 40 ; create a ref of iXs, return the index i ref ref i X ; now iYs points to iXs i Y [] deref i ref printarray i Y , \"\" , \"instrument 1, iY\" i Z [] fillarray 0 , 1 , 3 , 5 , 7 ; create a ref, pass it to instr. 2 schedule 2 , 0 , 1 , ref ( i Z ) ; create another ref of iZ. In this case the event is scheduled ; in the future, so the source will not exist anymore when instr. 2 ; is scheduled. This should fail. schedule 2 , 1 , 1 , ref ( i Z ) turnoff endin instr 2 i ref = p4 if refvalid ( i ref ) == 1 then i Zs [] deref i ref printarray i Zs , \"\" , \"p1=2, iZs\" else prints \" \\n >>> The reference has become invalid <<< \\n \" endif turnoff endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; Example 2: move semantics for arrays instr 3 ; create a source array k Xs [] fillarray 1 , 1 , 2 , 3 , 5 , 8 , 13 ; In order to bridge the time gap between the end of life of the source ; of a ref and the scheduled event where a deref is taken, it is possible ; to create a forward reference, a \"promise\" that one deref has been scheduled ; in the future. ; short lived event, ends before this event schedule 4 , 0 , 0.1 , ref ( k Xs ) ; starts before we end, but survives us schedule 4 , p3 - 0.1 , 0.2 , ref ( k Xs ) ; starts after we end, we need a move schedule 4 , p3 + 1 , 0.1 , ref ( k Xs , 1 ) defer \"prints\" , \" <<< instr. 3 finished >>> \\n \" endin instr 4 prints \"instr. 4 \\n \" k View [] deref p4 printarray k View defer \"prints\" , \" <<< instr. 4 finished >>> \\n \" ; At deinition time the memory of the `iView` array is marked as deallocated. ; The handle (a global structure created by the `ref` opcode) which owns the memory, ; is signaled that no other clients of this data are alive. It deallocates the ; original memory and frees itself endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; test: multiple derefs instr 5 i Xs [] fillarray 0 , 1 , 4 , 9 i ref ref i Xs i Ys [] deref i ref i Zs [] deref i ref printarray i Ys printarray i Zs i Xs [ 0 ] = 100 printarray i Zs turnoff endin ; test performance of pass-by-value vs pass-by-reference opcode arrayadd , i[] , i[]i ; pass by value in and out i In [], i x xin i Out [] = i In + i x xout i Out endop opcode arrayaddref , i[] , ii ; pass by ref in, by value out i ref , i x xin i In [] deref i ref i Out [] = i In + i x xout i Out endop opcode arrayadd_inplace , 0 , ii ; in place i ref , i x xin i In [] deref i ref i In += i x endop opcode arrayadd_byref_inout , 0 , iii ; pass by ref in and out i refin , i refout , i x xin i In [] deref i refin i Out [] deref i refout if lenarray ( i Out ) >= lenarray ( i In ) then i Out = i In + i x endif endop instr testUdoPerformance1 ; Here we test the performance gain of passing arrays by reference. ; Passing the input array by reference seems to produce a speedup of ~25%, i num = 100000 i Xs [] genarray 0 , i num i i = 0 i t0 rtclock while i i < 20 do i Ys [] arrayadd i Xs , 2.0 i i += 1 od i t1 rtclock prints \"Dur UDO pass by value = %.8f \\n \" , i t1 - i t0 i t0 rtclock i Ys [] arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i Ys arrayadd i Xs , 2.0 i t1 rtclock prints \"Dur UDO pass by value unroll = %.8f \\n \" , i t1 - i t0 i ref = ref ( i Xs ) i t0 rtclock i Y0 [] arrayaddref i ref , 0.1 i Y0 arrayaddref i ref , 0.2 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i t1 rtclock prints \"Dur UDO pass by ref input = %.8f \\n \" , i t1 - i t0 i Zs [] genarray 0 , i num i Out [] init lenarray ( i Zs ) i t0 rtclock i refZ = ref ( i Zs ) i refOut = ref ( i Out ) arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 i t1 rtclock prints \"Dur UDO pass by ref in and out= %.8f \\n \" , i t1 - i t0 ; printarray iOut endin instr 7 i In [] genarray 0 , 1000 i Out [] init lenarray ( i In ) arrayadd_byref_inout ref ( i In ), ref ( i Out ), 0.5 turnoff endin instr 8 ; test / k arrays ; 1. A way to convert a i-array to a k-array by taking a reference i Xs [] genarray 0 , 99 k Xs [] deref ref ( i Xs ) k Xs [ 0 ] = timeinsts () printarray k Xs , metro ( 8 ) endin instr 9 ; we need genarray_i because otherwise kXs is not initialized at i-time k Xs [] genarray 0 , 9 i Xs [] deref ref ( k Xs ) i Xs += 10 printarray i Xs printarray k Xs turnoff endin ; schedule 1, 0, 1 ; schedule 3, 0, 1 ; schedule 5, 0, 0.1 schedule \"testUdoPerformance1\" , 0 , 0.1 ; schedule 8, 0, 4 </ CsInstruments > < CsScore > e 10 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/ref.html#see-also","text":"deref defer schedule event release","title":"See also"},{"location":"opcodes/ref.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/refvalid.html","text":"refvalid Abstract Queries if a reference is valid Description ref and deref implement a mechanism to pass a reference to any object, allowing to share a variable across instruments, with opcodes, etc. A reference is a proxy to an axisting variable / array. A reference is reference counted and deallocates itself when it falls out of scope without being referenced by any object. Since a reference is just an integer, refvalid can be used to check if the given reference index corresponds to a valid reference Syntax iout refvalid iref kout refvalid kref Arguments iref / kout : an integer identifying the reference handle, as passed via ref Output \u00ecout / kout : 1 if the reference is valid, 0 otherwise Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > - m0 - d </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 k freq linseg 0 , p3 , 1 schedule 2 , 0 , p3 , ref ( k freq ) endin instr 2 if refvalid ( p4 ) == 1 then k freq = deref ( p4 ) else k freq = 1000 endif a sig vco2 0.2 , k freq schedule 3 , 0 , p3 , ref ( a sig ) endin instr 3 if refvalid ( p4 ) == 1 then a in deref p4 else a in = 0 endif a out lpf18 a in , 2000 , 0.9 , 0.2 outs a out , a out endin See also deref ref defer schedule event release Credits Eduardo Moguillansky, 2019","title":"refvalid"},{"location":"opcodes/refvalid.html#refvalid","text":"","title":"refvalid"},{"location":"opcodes/refvalid.html#abstract","text":"Queries if a reference is valid","title":"Abstract"},{"location":"opcodes/refvalid.html#description","text":"ref and deref implement a mechanism to pass a reference to any object, allowing to share a variable across instruments, with opcodes, etc. A reference is a proxy to an axisting variable / array. A reference is reference counted and deallocates itself when it falls out of scope without being referenced by any object. Since a reference is just an integer, refvalid can be used to check if the given reference index corresponds to a valid reference","title":"Description"},{"location":"opcodes/refvalid.html#syntax","text":"iout refvalid iref kout refvalid kref","title":"Syntax"},{"location":"opcodes/refvalid.html#arguments","text":"iref / kout : an integer identifying the reference handle, as passed via ref","title":"Arguments"},{"location":"opcodes/refvalid.html#output","text":"\u00ecout / kout : 1 if the reference is valid, 0 otherwise","title":"Output"},{"location":"opcodes/refvalid.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/refvalid.html#examples","text":"< CsoundSynthesizer > < CsOptions > - m0 - d </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 k freq linseg 0 , p3 , 1 schedule 2 , 0 , p3 , ref ( k freq ) endin instr 2 if refvalid ( p4 ) == 1 then k freq = deref ( p4 ) else k freq = 1000 endif a sig vco2 0.2 , k freq schedule 3 , 0 , p3 , ref ( a sig ) endin instr 3 if refvalid ( p4 ) == 1 then a in deref p4 else a in = 0 endif a out lpf18 a in , 2000 , 0.9 , 0.2 outs a out , a out endin","title":"Examples"},{"location":"opcodes/refvalid.html#see-also","text":"deref ref defer schedule event release","title":"See also"},{"location":"opcodes/refvalid.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/schmitt.html","text":"schmitt Abstract A schmitt trigger (a comparator with hysteresis). Description Implements a schmitt trigger, which is a comparator with hysteresis. Whenever the input is higher than khigh , output is 1 and stays 1 until input drops beneath klow . Output is 1 if the input is higher than khigh if signal is increasing Output is 0 if the input is lower than klow if signal is decreasing Note schmitt is particularly useful for implementing effects like a noise gate, to avoid fast opening and closing at the threshold. It can be further refined together with sc_lagud to add attack / release times to the opening of the gate or with sc_trig to assure a minimum open time for the gate Port of pd/else's schmitt Syntax xout schmitt xin, khigh, klow Arguments xin : input signal (k- or audio rate). The rate of xin must match the rate of xout khigh : high value of the comparator, output is 1 whenever input is higher than this klow : low value of the comparator, output is 0 whenever input is lower than this Output xout : output value of the comparator (0 or 1). Rate of xout is the same as xin Execution Time Performance (k or audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 /* Example file for schmitt opcode aout schmitt ain, khigh, klow kout schmitt kin, khigh, klow schmitt is a schmitt trigger (a gate with hysteresis), out is 1 if higher than khigh, 0 if lower than klow */ FLpanel \"schmitt\" , 400 , 300 , 50 , 50 i disp1 FLvalue \"\" , 40 , 30 , 322 , 20 i disp2 FLvalue \"\" , 40 , 30 , 322 , 80 i disp3 FLvalue \"\" , 40 , 30 , 322 , 140 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk signal , gi h1 FLslider \"signal\" , - 1 , 1 , 0 , 1 , i disp1 , 300 , 30 , 20 , 20 gk low , gi h2 FLslider \"low\" , - 1 , 1 , 0 , 3 , i disp2 , 300 , 30 , 20 , 80 gk high , gi h3 FLslider \"high\" , - 1 , 1 , 0 , 3 , i disp3 , 300 , 30 , 20 , 140 k schmitt , gi h4 FLbutton \"out\" , 1 , 0 , 3 , 50 , 50 , 20 , 200 , - 1 FLpanelEnd FLrun FLsetVal_i - 0.5 , gi h2 FLsetVal_i 0.5 , gi h3 instr 1 a in oscili 1 , 0.25 a out schmitt a in , gk high , gk low k guitrig metro 24 FLsetVal k guitrig , k ( a in ), gi h1 FLsetVal k guitrig , k ( a out ), gi h4 endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer > See also sc_lagud sc_trig Credits Eduardo Moguillansky, 2019","title":"schmitt"},{"location":"opcodes/schmitt.html#schmitt","text":"","title":"schmitt"},{"location":"opcodes/schmitt.html#abstract","text":"A schmitt trigger (a comparator with hysteresis).","title":"Abstract"},{"location":"opcodes/schmitt.html#description","text":"Implements a schmitt trigger, which is a comparator with hysteresis. Whenever the input is higher than khigh , output is 1 and stays 1 until input drops beneath klow . Output is 1 if the input is higher than khigh if signal is increasing Output is 0 if the input is lower than klow if signal is decreasing Note schmitt is particularly useful for implementing effects like a noise gate, to avoid fast opening and closing at the threshold. It can be further refined together with sc_lagud to add attack / release times to the opening of the gate or with sc_trig to assure a minimum open time for the gate Port of pd/else's schmitt","title":"Description"},{"location":"opcodes/schmitt.html#syntax","text":"xout schmitt xin, khigh, klow","title":"Syntax"},{"location":"opcodes/schmitt.html#arguments","text":"xin : input signal (k- or audio rate). The rate of xin must match the rate of xout khigh : high value of the comparator, output is 1 whenever input is higher than this klow : low value of the comparator, output is 0 whenever input is lower than this","title":"Arguments"},{"location":"opcodes/schmitt.html#output","text":"xout : output value of the comparator (0 or 1). Rate of xout is the same as xin","title":"Output"},{"location":"opcodes/schmitt.html#execution-time","text":"Performance (k or audio)","title":"Execution Time"},{"location":"opcodes/schmitt.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 /* Example file for schmitt opcode aout schmitt ain, khigh, klow kout schmitt kin, khigh, klow schmitt is a schmitt trigger (a gate with hysteresis), out is 1 if higher than khigh, 0 if lower than klow */ FLpanel \"schmitt\" , 400 , 300 , 50 , 50 i disp1 FLvalue \"\" , 40 , 30 , 322 , 20 i disp2 FLvalue \"\" , 40 , 30 , 322 , 80 i disp3 FLvalue \"\" , 40 , 30 , 322 , 140 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk signal , gi h1 FLslider \"signal\" , - 1 , 1 , 0 , 1 , i disp1 , 300 , 30 , 20 , 20 gk low , gi h2 FLslider \"low\" , - 1 , 1 , 0 , 3 , i disp2 , 300 , 30 , 20 , 80 gk high , gi h3 FLslider \"high\" , - 1 , 1 , 0 , 3 , i disp3 , 300 , 30 , 20 , 140 k schmitt , gi h4 FLbutton \"out\" , 1 , 0 , 3 , 50 , 50 , 20 , 200 , - 1 FLpanelEnd FLrun FLsetVal_i - 0.5 , gi h2 FLsetVal_i 0.5 , gi h3 instr 1 a in oscili 1 , 0.25 a out schmitt a in , gk high , gk low k guitrig metro 24 FLsetVal k guitrig , k ( a in ), gi h1 FLsetVal k guitrig , k ( a out ), gi h4 endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/schmitt.html#see-also","text":"sc_lagud sc_trig","title":"See also"},{"location":"opcodes/schmitt.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/sigmdrive.html","text":"sigmdrive Abstract Analog \"soft clipping\" distortion by applying non-linear transfer functions. Description sigmdrive simulates analog \"soft clipping\" by applying non-linear transfer functions. Two different sigmoid equations are implemented. mode 0 out = tanh(in * drivefactor) mode 1 if in > 0 then out = 1.0 - pow(1. - in, drivefactor) if in <= 0 then out = pow(1. + x, drivefactor) - 1.0 Syntax aout sigmdrive ain, xdrivefactor, kmode=0 Arguments ain : the input audio signal xdrivefactor : a k- or a- value, normally greater than 1. A higher value implies more distortion kmode : the distortion mode. 0=tanh, 1=pow (see above) Output aout : the distorted audio Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* sigmdrive: a sigmoid distortion aout sigmdrive ain, kdrive, kmode=0 kdrive: how much distortion (range 0-1) kmode: 0 = tanh, 1 = pow */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 FLpanel \"sigmdrive\" , 400 , 200 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 322 , 20 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk drive , i drivehandle1 FLslider \"drive\" , 0 , 10 , 0 , 3 , i disp1 , 300 , 30 , 20 , 20 gk mode , i drivehandle2 FLbutton \"mode\" , 1 , 0 , 3 , 60 , 50 , 20 , 80 , - 1 FLpanelEnd FLrun instr 1 a in oscili 0.2 , 440 a out sigmdrive a in , port : k ( gk drive , 0.2 ), gk mode outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer > See also tubeharmonics distort1 tanh powershape Credits Eduardo Moguillansky, 2019 (based on pd/else's drive~ - https://github.com/porres/pd-else)","title":"sigmdrive"},{"location":"opcodes/sigmdrive.html#sigmdrive","text":"","title":"sigmdrive"},{"location":"opcodes/sigmdrive.html#abstract","text":"Analog \"soft clipping\" distortion by applying non-linear transfer functions.","title":"Abstract"},{"location":"opcodes/sigmdrive.html#description","text":"sigmdrive simulates analog \"soft clipping\" by applying non-linear transfer functions. Two different sigmoid equations are implemented.","title":"Description"},{"location":"opcodes/sigmdrive.html#mode-0","text":"out = tanh(in * drivefactor)","title":"mode 0"},{"location":"opcodes/sigmdrive.html#mode-1","text":"if in > 0 then out = 1.0 - pow(1. - in, drivefactor) if in <= 0 then out = pow(1. + x, drivefactor) - 1.0","title":"mode 1"},{"location":"opcodes/sigmdrive.html#syntax","text":"aout sigmdrive ain, xdrivefactor, kmode=0","title":"Syntax"},{"location":"opcodes/sigmdrive.html#arguments","text":"ain : the input audio signal xdrivefactor : a k- or a- value, normally greater than 1. A higher value implies more distortion kmode : the distortion mode. 0=tanh, 1=pow (see above)","title":"Arguments"},{"location":"opcodes/sigmdrive.html#output","text":"aout : the distorted audio","title":"Output"},{"location":"opcodes/sigmdrive.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/sigmdrive.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* sigmdrive: a sigmoid distortion aout sigmdrive ain, kdrive, kmode=0 kdrive: how much distortion (range 0-1) kmode: 0 = tanh, 1 = pow */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 FLpanel \"sigmdrive\" , 400 , 200 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 322 , 20 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk drive , i drivehandle1 FLslider \"drive\" , 0 , 10 , 0 , 3 , i disp1 , 300 , 30 , 20 , 20 gk mode , i drivehandle2 FLbutton \"mode\" , 1 , 0 , 3 , 60 , 50 , 20 , 80 , - 1 FLpanelEnd FLrun instr 1 a in oscili 0.2 , 440 a out sigmdrive a in , port : k ( gk drive , 0.2 ), gk mode outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/sigmdrive.html#see-also","text":"tubeharmonics distort1 tanh powershape","title":"See also"},{"location":"opcodes/sigmdrive.html#credits","text":"Eduardo Moguillansky, 2019 (based on pd/else's drive~ - https://github.com/porres/pd-else)","title":"Credits"},{"location":"opcodes/standardchaos.html","text":"standardchaos Abstract Standard map chaotic generator Description standardchaos is a chaotic generator, the sound is generated with the following difference equations; y[n] = (y[n-1] + k * sin(x[n-1])) % 2pi; x[n] = (x[n-1] + y[n]) % 2pi; out = (x[n] - pi) / pi Syntax aout standardchaos krate, kk=1, ix=0.5, iy=0 Arguments krate : from 0 to nyquist kk : a value for k in the above equation ix : initial value for x iy : initial value for y Output aout : audio output of the chaotic generator Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 /* Example file for standardchaos opcode aout standardchaos krate, kk, ix=0.5, iy=0 Standard map chaotic generator, the sound is generated with the difference equations; y[n] = (y[n-1] + k * sin(x[n-1])) % 2pi; x[n] = (x[n-1] + y[n]) % 2pi; out = (x[n] - pi) / pi; */ FLpanel \"standardchaos\" , 600 , 300 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 522 , 20 i disp2 FLvalue \"\" , 50 , 30 , 522 , 80 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk rate , gi h1 FLslider \"rate\" , 0 , 20000 , 0 , 3 , i disp1 , 500 , 30 , 20 , 20 gk k , gi h2 FLslider \"k\" , 0 , 10 , 0 , 3 , i disp2 , 500 , 30 , 20 , 80 FLpanelEnd FLrun FLsetVal_i 1618 , gi h1 FLsetVal_i 1 , gi h2 instr 1 i x = 0.5 i y = 1 i gain = 0.3 a out standardchaos gk rate , gk k , i x , i y a out *= i gain outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer > < bsbPanel > < label > Widgets </ label > < objectName /> < x > 100 </ x > < y > 100 </ y > < w idth > 320 </ w idth > < height > 240 </ height > < visible > true </ visible > < uuid /> < bgcolor mode = \"nobackground\" > < r > 255 </ r > < g > 255 </ g > < b > 255 </ b > </ bgcolor > </ bsbPanel > < bsbPresets > </ bsbPresets > See also crackle chuap dust2 Credits Eduardo Moguillansky, 2019 (based on pd/else's standard~ - https://github.com/porres/pd-else)","title":"standardchaos"},{"location":"opcodes/standardchaos.html#standardchaos","text":"","title":"standardchaos"},{"location":"opcodes/standardchaos.html#abstract","text":"Standard map chaotic generator","title":"Abstract"},{"location":"opcodes/standardchaos.html#description","text":"standardchaos is a chaotic generator, the sound is generated with the following difference equations; y[n] = (y[n-1] + k * sin(x[n-1])) % 2pi; x[n] = (x[n-1] + y[n]) % 2pi; out = (x[n] - pi) / pi","title":"Description"},{"location":"opcodes/standardchaos.html#syntax","text":"aout standardchaos krate, kk=1, ix=0.5, iy=0","title":"Syntax"},{"location":"opcodes/standardchaos.html#arguments","text":"krate : from 0 to nyquist kk : a value for k in the above equation ix : initial value for x iy : initial value for y","title":"Arguments"},{"location":"opcodes/standardchaos.html#output","text":"aout : audio output of the chaotic generator","title":"Output"},{"location":"opcodes/standardchaos.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/standardchaos.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 /* Example file for standardchaos opcode aout standardchaos krate, kk, ix=0.5, iy=0 Standard map chaotic generator, the sound is generated with the difference equations; y[n] = (y[n-1] + k * sin(x[n-1])) % 2pi; x[n] = (x[n-1] + y[n]) % 2pi; out = (x[n] - pi) / pi; */ FLpanel \"standardchaos\" , 600 , 300 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 522 , 20 i disp2 FLvalue \"\" , 50 , 30 , 522 , 80 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk rate , gi h1 FLslider \"rate\" , 0 , 20000 , 0 , 3 , i disp1 , 500 , 30 , 20 , 20 gk k , gi h2 FLslider \"k\" , 0 , 10 , 0 , 3 , i disp2 , 500 , 30 , 20 , 80 FLpanelEnd FLrun FLsetVal_i 1618 , gi h1 FLsetVal_i 1 , gi h2 instr 1 i x = 0.5 i y = 1 i gain = 0.3 a out standardchaos gk rate , gk k , i x , i y a out *= i gain outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer > < bsbPanel > < label > Widgets </ label > < objectName /> < x > 100 </ x > < y > 100 </ y > < w idth > 320 </ w idth > < height > 240 </ height > < visible > true </ visible > < uuid /> < bgcolor mode = \"nobackground\" > < r > 255 </ r > < g > 255 </ g > < b > 255 </ b > </ bgcolor > </ bsbPanel > < bsbPresets > </ bsbPresets >","title":"Examples"},{"location":"opcodes/standardchaos.html#see-also","text":"crackle chuap dust2","title":"See also"},{"location":"opcodes/standardchaos.html#credits","text":"Eduardo Moguillansky, 2019 (based on pd/else's standard~ - https://github.com/porres/pd-else)","title":"Credits"},{"location":"opcodes/strcache.html","text":"strcache Abstract Put a string into the global cache or retrieve a string from the cache Description strcache implements a global string cache. This can be useful in situations where a string needs to be stored/passed but only numbers are allowed (for example, when using the event opcode, or to be able to mix numbers and strings inside an array). It behaves similar to the strset / strget opcodes but automatically assigns an index to each distinct string inside the cache. strcache executes both at i-time and k-time , depending on the type of the input variable Note It is guaranteed that passing twice the same string will return the same index. Note The same opcode is used for creating a reference to a string and from converting that reference back to a string. Syntax Sstr strcache idx Sstr strcache kdx idx strcache Sstr kdx strcache Sstr Arguments idx / kdx : the numeric id representing the string Sstr : the string inside the cache, corresponding to idx Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for strcache / strview */ ; Use strcache to pass multiple strings between instruments instr 1 event_i \"i\" , 2 , 0 , - 1 , strcache ( \"foo\" ), strcache ( \"bar\" ) turnoff endin instr 2 ;; get a read-only string from the cache S 1 strview p4 S 2 strview p5 prints \"S1= %s S2= %s \\n \" , S 1 , S 2 turnoff endin ;; Use strcache to store strings inside a numeric array instr 3 i Struct [] fillarray strcache ( \"Bach\" ), 1675 , 1750 prints \"Name = %s \\n \" , strcache ( i Struct [ 0 ]) endin ;; If the string does not need to be modified, strview ;; can be used instead of strcache to retrieve a string ;; from the cache. In this case, the string is not allocated, ;; it only points to the version inside the cache. instr 4 S 1 = \"foo bar\" i S1 = strcache ( S 1 ) ;; S2 is a read-only view of the cached S1. S 2 = strcache ( i S1 ) prints \"S2 = %s \\n \" , S 2 turnoff endin instr test_same_idx i dx1 = strcache ( \"foo\" ) i dx2 = strcache ( \"foo\" ) prints \"These indices should be the same: idx1= %d , idx2= %d \\n \" , i dx1 , i dx2 turnoff endin instr test_strview S 1 = \"uniquestring\" i dx1 = strcache ( S 1 ) S view = strview ( i dx1 ) prints \"Sview = ' %s ' (should be ' %s ') \\n \" , S view , S 1 turnoff endin </ CsInstruments > < CsScore > ; i 1 0 0.1 ; i 3 + 0.1 ; i 4 + 0.1 i \"test_same_idx\" 0 1 ; i \"test_strview\" 0 1 </ CsScore > </ CsoundSynthesizer > Credits Eduardo Moguillansky, 2019","title":"strcache"},{"location":"opcodes/strcache.html#strcache","text":"","title":"strcache"},{"location":"opcodes/strcache.html#abstract","text":"Put a string into the global cache or retrieve a string from the cache","title":"Abstract"},{"location":"opcodes/strcache.html#description","text":"strcache implements a global string cache. This can be useful in situations where a string needs to be stored/passed but only numbers are allowed (for example, when using the event opcode, or to be able to mix numbers and strings inside an array). It behaves similar to the strset / strget opcodes but automatically assigns an index to each distinct string inside the cache. strcache executes both at i-time and k-time , depending on the type of the input variable Note It is guaranteed that passing twice the same string will return the same index. Note The same opcode is used for creating a reference to a string and from converting that reference back to a string.","title":"Description"},{"location":"opcodes/strcache.html#syntax","text":"Sstr strcache idx Sstr strcache kdx idx strcache Sstr kdx strcache Sstr","title":"Syntax"},{"location":"opcodes/strcache.html#arguments","text":"idx / kdx : the numeric id representing the string Sstr : the string inside the cache, corresponding to idx","title":"Arguments"},{"location":"opcodes/strcache.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/strcache.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for strcache / strview */ ; Use strcache to pass multiple strings between instruments instr 1 event_i \"i\" , 2 , 0 , - 1 , strcache ( \"foo\" ), strcache ( \"bar\" ) turnoff endin instr 2 ;; get a read-only string from the cache S 1 strview p4 S 2 strview p5 prints \"S1= %s S2= %s \\n \" , S 1 , S 2 turnoff endin ;; Use strcache to store strings inside a numeric array instr 3 i Struct [] fillarray strcache ( \"Bach\" ), 1675 , 1750 prints \"Name = %s \\n \" , strcache ( i Struct [ 0 ]) endin ;; If the string does not need to be modified, strview ;; can be used instead of strcache to retrieve a string ;; from the cache. In this case, the string is not allocated, ;; it only points to the version inside the cache. instr 4 S 1 = \"foo bar\" i S1 = strcache ( S 1 ) ;; S2 is a read-only view of the cached S1. S 2 = strcache ( i S1 ) prints \"S2 = %s \\n \" , S 2 turnoff endin instr test_same_idx i dx1 = strcache ( \"foo\" ) i dx2 = strcache ( \"foo\" ) prints \"These indices should be the same: idx1= %d , idx2= %d \\n \" , i dx1 , i dx2 turnoff endin instr test_strview S 1 = \"uniquestring\" i dx1 = strcache ( S 1 ) S view = strview ( i dx1 ) prints \"Sview = ' %s ' (should be ' %s ') \\n \" , S view , S 1 turnoff endin </ CsInstruments > < CsScore > ; i 1 0 0.1 ; i 3 + 0.1 ; i 4 + 0.1 i \"test_same_idx\" 0 1 ; i \"test_strview\" 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/strcache.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/strview.html","text":"strview Abstract Retrieves a read-only string from the cache Description strcache / strview implement a global string cache. This can be useful in situations where a string needs to be stored/passed but only numbers are allowed (for example, when using the event opcode, or to be able to mix numbers and strings inside an array). It behaves similar to the strset / strget opcodes but automatically assigns an index to each distinct string inside the cache. The string returned by strview should not be modified. This is not enforced. strview executes at i-time . Syntax Sstr strview idx Arguments idx / kdx : the numeric id representing the string Sstr : the string inside the cache, corresponding to idx Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for strcache / strview */ ; Use strcache to pass multiple strings between instruments instr 1 event_i \"i\" , 2 , 0 , - 1 , strcache ( \"foo\" ), strcache ( \"bar\" ) turnoff endin instr 2 ;; get a read-only string from the cache S 1 strview p4 S 2 strview p5 prints \"S1= %s S2= %s \\n \" , S 1 , S 2 turnoff endin ;; Use strcache to store strings inside a numeric array instr 3 i Struct [] fillarray strcache ( \"Bach\" ), 1675 , 1750 prints \"Name = %s \\n \" , strcache ( i Struct [ 0 ]) endin ;; If the string does not need to be modified, strview ;; can be used instead of strcache to retrieve a string ;; from the cache. In this case, the string is not allocated, ;; it only points to the version inside the cache. instr 4 S 1 = \"foo bar\" i S1 = strcache ( S 1 ) ;; S2 is a read-only view of the cached S1. S 2 = strcache ( i S1 ) prints \"S2 = %s \\n \" , S 2 turnoff endin instr test_same_idx i dx1 = strcache ( \"foo\" ) i dx2 = strcache ( \"foo\" ) prints \"These indices should be the same: idx1= %d , idx2= %d \\n \" , i dx1 , i dx2 turnoff endin instr test_strview S 1 = \"uniquestring\" i dx1 = strcache ( S 1 ) S view = strview ( i dx1 ) prints \"Sview = ' %s ' (should be ' %s ') \\n \" , S view , S 1 turnoff endin </ CsInstruments > < CsScore > ; i 1 0 0.1 ; i 3 + 0.1 ; i 4 + 0.1 i \"test_same_idx\" 0 1 ; i \"test_strview\" 0 1 </ CsScore > </ CsoundSynthesizer > Credits Eduardo Moguillansky, 2020","title":"strview"},{"location":"opcodes/strview.html#strview","text":"","title":"strview"},{"location":"opcodes/strview.html#abstract","text":"Retrieves a read-only string from the cache","title":"Abstract"},{"location":"opcodes/strview.html#description","text":"strcache / strview implement a global string cache. This can be useful in situations where a string needs to be stored/passed but only numbers are allowed (for example, when using the event opcode, or to be able to mix numbers and strings inside an array). It behaves similar to the strset / strget opcodes but automatically assigns an index to each distinct string inside the cache. The string returned by strview should not be modified. This is not enforced. strview executes at i-time .","title":"Description"},{"location":"opcodes/strview.html#syntax","text":"Sstr strview idx","title":"Syntax"},{"location":"opcodes/strview.html#arguments","text":"idx / kdx : the numeric id representing the string Sstr : the string inside the cache, corresponding to idx","title":"Arguments"},{"location":"opcodes/strview.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/strview.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for strcache / strview */ ; Use strcache to pass multiple strings between instruments instr 1 event_i \"i\" , 2 , 0 , - 1 , strcache ( \"foo\" ), strcache ( \"bar\" ) turnoff endin instr 2 ;; get a read-only string from the cache S 1 strview p4 S 2 strview p5 prints \"S1= %s S2= %s \\n \" , S 1 , S 2 turnoff endin ;; Use strcache to store strings inside a numeric array instr 3 i Struct [] fillarray strcache ( \"Bach\" ), 1675 , 1750 prints \"Name = %s \\n \" , strcache ( i Struct [ 0 ]) endin ;; If the string does not need to be modified, strview ;; can be used instead of strcache to retrieve a string ;; from the cache. In this case, the string is not allocated, ;; it only points to the version inside the cache. instr 4 S 1 = \"foo bar\" i S1 = strcache ( S 1 ) ;; S2 is a read-only view of the cached S1. S 2 = strcache ( i S1 ) prints \"S2 = %s \\n \" , S 2 turnoff endin instr test_same_idx i dx1 = strcache ( \"foo\" ) i dx2 = strcache ( \"foo\" ) prints \"These indices should be the same: idx1= %d , idx2= %d \\n \" , i dx1 , i dx2 turnoff endin instr test_strview S 1 = \"uniquestring\" i dx1 = strcache ( S 1 ) S view = strview ( i dx1 ) prints \"Sview = ' %s ' (should be ' %s ') \\n \" , S view , S 1 turnoff endin </ CsInstruments > < CsScore > ; i 1 0 0.1 ; i 3 + 0.1 ; i 4 + 0.1 i \"test_same_idx\" 0 1 ; i \"test_strview\" 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/strview.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/tubeharmonics.html","text":"tubeharmonics Abstract A distortion with control for odd/even harmonics Description Simulates the behaviour of a vacuum tube circuit stage. Adds odd and even harmonics to the signal. Has flux and program dependent saturation. A port of REAPER 's \"Tube Harmonics\" jsfx plugin Syntax aout tubeharmonics ain, keven, kodd, kfluctuation=0, kindrive=0, koutdrive=0, kgain=0 Arguments ain : the input signal keven : amount of even harmonics (between 0-1) kodd : amount of odd harmonics (between 0-1) kfluctuation : non linearities (between 0-1, default 0) kindrive : amount of input drive (in dB, default=0 dB) koutdrive : amount of output drive (in dB, default=0 dB) koutgain : output gain, in dB (default=0 dB) Output aout : audio output Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for tubeharmonics opcode gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i gain = 0 a 1 , a 2 tubeharmonics a sig , a sig , gk even , gk odd , gk flct , gk inpt , gk out , i gain outs a 1 , a 2 endin </ CsInstruments > < CsScore > i 1 0 300 </ CsScore > </ CsoundSynthesizer > See also sigmdrive tanh distort1 Credits Eduardo Moguillansky, 2019","title":"tubeharmonics"},{"location":"opcodes/tubeharmonics.html#tubeharmonics","text":"","title":"tubeharmonics"},{"location":"opcodes/tubeharmonics.html#abstract","text":"A distortion with control for odd/even harmonics","title":"Abstract"},{"location":"opcodes/tubeharmonics.html#description","text":"Simulates the behaviour of a vacuum tube circuit stage. Adds odd and even harmonics to the signal. Has flux and program dependent saturation. A port of REAPER 's \"Tube Harmonics\" jsfx plugin","title":"Description"},{"location":"opcodes/tubeharmonics.html#syntax","text":"aout tubeharmonics ain, keven, kodd, kfluctuation=0, kindrive=0, koutdrive=0, kgain=0","title":"Syntax"},{"location":"opcodes/tubeharmonics.html#arguments","text":"ain : the input signal keven : amount of even harmonics (between 0-1) kodd : amount of odd harmonics (between 0-1) kfluctuation : non linearities (between 0-1, default 0) kindrive : amount of input drive (in dB, default=0 dB) koutdrive : amount of output drive (in dB, default=0 dB) koutgain : output gain, in dB (default=0 dB)","title":"Arguments"},{"location":"opcodes/tubeharmonics.html#output","text":"aout : audio output","title":"Output"},{"location":"opcodes/tubeharmonics.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/tubeharmonics.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for tubeharmonics opcode gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i gain = 0 a 1 , a 2 tubeharmonics a sig , a sig , gk even , gk odd , gk flct , gk inpt , gk out , i gain outs a 1 , a 2 endin </ CsInstruments > < CsScore > i 1 0 300 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/tubeharmonics.html#see-also","text":"sigmdrive tanh distort1","title":"See also"},{"location":"opcodes/tubeharmonics.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/uniqinstance.html","text":"uniqinstance Abstract Return an fractional instrument number which is not in use Description Given an integer instrument number, uniqinstance a fractional instrument number which is not active now and can be used as p1 for event , schedule or similar opcodes to create a unique instance of the given instrument Note This opcode DOES NOT create a new instance. It just returns an instr number which can be used to create one Syntax instrnum uniqinstance integer_instrnum instrnum uniqinstance Sinstrname Arguments integer_instrnum : the integer instrument number Sinstrname : the name of a named instrument Output instrnum : a fractional instrument number which is guaranteed not to be active at the moment Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > /* Example file for uniqinstance instrnum uniqinstance intinstr Returns a unique fractional instrument number which is not active at the moment and can be assigned to a new instance */ instr exit exitnow endin instr 1 k counter init 0 k trig metro 20 if k trig == 1 then k counter += 1 k inst = 10 + k counter / 100 printf \"kinst= %f \\n \" , k trig , k inst event \"i\" , k inst , 0 , 1 endif endin instr 2 i nstrnum10 uniqinstance 10 printf \"Unique instance of 10= %f \\n \" , 1 , i nstrnum10 i nstrnum11 uniqinstance 11 printf \"Unique instance of 11= %f \\n \" , 1 , i nstrnum11 turnoff endin instr 10 print p1 endin instr 11 print p1 endin instr example1 printf \">>>>>>>>>>>>>>>>>>> example1 \\n \" , 1 schedule 1 , 0 , 0.5 schedule 2 , 0.5 , 0.1 schedule 10.150 , 0 , 0.1 schedule 11 , 0 , 2 turnoff endin ; -------------------------------------- ; Test that instances get recycled instr example2 printf \">>>>>>>>>>>>>>>>>>> example2 \\n \" , 1 i 0 = 0 i step = 0.01 i dur = 1.0 ; 100 simultaneous instances ; idur = 2.0 ; 200 simultaneous instances while i 0 < 1000 do schedule \"scheduniq\" , i 0 * i step , i dur , 20 i 0 += 1 od i maxdur = 2000 * i step + i dur turnoff endin instr scheduniq i num = p4 i num2 = uniqinstance ( i num , 100 ) if i num2 < 0 then prints \"<<<<< Could not find unique instance >>>>> \\n \" else schedule i num2 , 0 , p3 prints \"active now= %d , inum= %f \\n \" , active ( 0 ), i num2 endif turnoff endin instr 20 printf \"started %f \\n \" , 1 , p1 defer \"prints\" , \"finished %f \\n \" , p1 endin </ CsInstruments > < CsScore > ; i \"example1\" 0 10 i \"example2\" 0 10 </ CsScore > </ CsoundSynthesizer > See also pread pset p passign nstrnum Credits Eduardo Moguillansky, 2019","title":"uniqinstance"},{"location":"opcodes/uniqinstance.html#uniqinstance","text":"","title":"uniqinstance"},{"location":"opcodes/uniqinstance.html#abstract","text":"Return an fractional instrument number which is not in use","title":"Abstract"},{"location":"opcodes/uniqinstance.html#description","text":"Given an integer instrument number, uniqinstance a fractional instrument number which is not active now and can be used as p1 for event , schedule or similar opcodes to create a unique instance of the given instrument Note This opcode DOES NOT create a new instance. It just returns an instr number which can be used to create one","title":"Description"},{"location":"opcodes/uniqinstance.html#syntax","text":"instrnum uniqinstance integer_instrnum instrnum uniqinstance Sinstrname","title":"Syntax"},{"location":"opcodes/uniqinstance.html#arguments","text":"integer_instrnum : the integer instrument number Sinstrname : the name of a named instrument","title":"Arguments"},{"location":"opcodes/uniqinstance.html#output","text":"instrnum : a fractional instrument number which is guaranteed not to be active at the moment","title":"Output"},{"location":"opcodes/uniqinstance.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/uniqinstance.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > /* Example file for uniqinstance instrnum uniqinstance intinstr Returns a unique fractional instrument number which is not active at the moment and can be assigned to a new instance */ instr exit exitnow endin instr 1 k counter init 0 k trig metro 20 if k trig == 1 then k counter += 1 k inst = 10 + k counter / 100 printf \"kinst= %f \\n \" , k trig , k inst event \"i\" , k inst , 0 , 1 endif endin instr 2 i nstrnum10 uniqinstance 10 printf \"Unique instance of 10= %f \\n \" , 1 , i nstrnum10 i nstrnum11 uniqinstance 11 printf \"Unique instance of 11= %f \\n \" , 1 , i nstrnum11 turnoff endin instr 10 print p1 endin instr 11 print p1 endin instr example1 printf \">>>>>>>>>>>>>>>>>>> example1 \\n \" , 1 schedule 1 , 0 , 0.5 schedule 2 , 0.5 , 0.1 schedule 10.150 , 0 , 0.1 schedule 11 , 0 , 2 turnoff endin ; -------------------------------------- ; Test that instances get recycled instr example2 printf \">>>>>>>>>>>>>>>>>>> example2 \\n \" , 1 i 0 = 0 i step = 0.01 i dur = 1.0 ; 100 simultaneous instances ; idur = 2.0 ; 200 simultaneous instances while i 0 < 1000 do schedule \"scheduniq\" , i 0 * i step , i dur , 20 i 0 += 1 od i maxdur = 2000 * i step + i dur turnoff endin instr scheduniq i num = p4 i num2 = uniqinstance ( i num , 100 ) if i num2 < 0 then prints \"<<<<< Could not find unique instance >>>>> \\n \" else schedule i num2 , 0 , p3 prints \"active now= %d , inum= %f \\n \" , active ( 0 ), i num2 endif turnoff endin instr 20 printf \"started %f \\n \" , 1 , p1 defer \"prints\" , \"finished %f \\n \" , p1 endin </ CsInstruments > < CsScore > ; i \"example1\" 0 10 i \"example2\" 0 10 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/uniqinstance.html#see-also","text":"pread pset p passign nstrnum","title":"See also"},{"location":"opcodes/uniqinstance.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/xtracycles.html","text":"xtracycles Abstract Returns the number of extra performance cycles for an event Description xtracycles returns the number of extra performance cycles of an event. An event can extend its scheduled duration via two mechanisms - either through opcodes like linsegr , which have a release segment, or explicitely through xtratim , which extends the duration of an event by a given time. Note xtracycles should be called after all other duration extending opcodes (like linsegr or xtratim). It works only at init. Info To calculate the extra time for an event, divide the number of cycles by kr ( extratime = xtracycles() / kr ) Syntax icycles xtracycles Arguments Output icycles : the number of extra performance cycles for this event Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound - d - m0 </ CsOptions > < CsInstruments > /* ## Example file for xtracycles opcode. xtracycles returns the number of extra performance cycles of an event. An event can extend its scheduled duration via two mechanisms - either through opcodes like `linsegr`, which have a release segment, or explicitely through `xtratim`, which extends the duration of an event by a given time. `xtracycles` should be called after all other duration extending opcodes (like linsegr or xtratim). It works only at init. NB: to calculate the extra time for an event, divide the number of cycles by kr (extratime = xtracycles() / kr) ## Syntax icycles xtracycles ## Returns icycles - the number of extra performance cycles for this event */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 a env linsegr 0 , 0.1 , 1 , 0.5 , 0 i extratime = xtracycles () / kr prints \" \\n >>> extra time = %f (should be higher than 0.5) \\n\\n \" , i extratime endin </ CsInstruments > < CsScore > i 1 0 3 </ CsScore > </ CsoundSynthesizer > See also release xtratim defer Credits Eduardo Moguillansky, 2019","title":"xtracycles"},{"location":"opcodes/xtracycles.html#xtracycles","text":"","title":"xtracycles"},{"location":"opcodes/xtracycles.html#abstract","text":"Returns the number of extra performance cycles for an event","title":"Abstract"},{"location":"opcodes/xtracycles.html#description","text":"xtracycles returns the number of extra performance cycles of an event. An event can extend its scheduled duration via two mechanisms - either through opcodes like linsegr , which have a release segment, or explicitely through xtratim , which extends the duration of an event by a given time. Note xtracycles should be called after all other duration extending opcodes (like linsegr or xtratim). It works only at init. Info To calculate the extra time for an event, divide the number of cycles by kr ( extratime = xtracycles() / kr )","title":"Description"},{"location":"opcodes/xtracycles.html#syntax","text":"icycles xtracycles","title":"Syntax"},{"location":"opcodes/xtracycles.html#arguments","text":"","title":"Arguments"},{"location":"opcodes/xtracycles.html#output","text":"icycles : the number of extra performance cycles for this event","title":"Output"},{"location":"opcodes/xtracycles.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/xtracycles.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound - d - m0 </ CsOptions > < CsInstruments > /* ## Example file for xtracycles opcode. xtracycles returns the number of extra performance cycles of an event. An event can extend its scheduled duration via two mechanisms - either through opcodes like `linsegr`, which have a release segment, or explicitely through `xtratim`, which extends the duration of an event by a given time. `xtracycles` should be called after all other duration extending opcodes (like linsegr or xtratim). It works only at init. NB: to calculate the extra time for an event, divide the number of cycles by kr (extratime = xtracycles() / kr) ## Syntax icycles xtracycles ## Returns icycles - the number of extra performance cycles for this event */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 a env linsegr 0 , 0.1 , 1 , 0.5 , 0 i extratime = xtracycles () / kr prints \" \\n >>> extra time = %f (should be higher than 0.5) \\n\\n \" , i extratime endin </ CsInstruments > < CsScore > i 1 0 3 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/xtracycles.html#see-also","text":"release xtratim defer","title":"See also"},{"location":"opcodes/xtracycles.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"}]}