{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Csound Plugins Welcome to the csound-plugins wiki! This is a collection of plugins for csound Installation See Installation klib A hashtable for csound dict_new : Create a hashtable dict_free : Free a hashtable dict_get : Get a value from a hashtable dict_set : Set (or remove) a value from a hashtable dict_size : Returns the number of key:value pairs in a dict dict_query : Query different properties of a dict dict_print : Prints the contents of a dict dict_iter : Iterate over the key-value pairs of a dict cacheput : Put a string inside the cache cacheget : Get a string inside the cache cachepop : Get a cached string and remove it from the cache poly Multiple (parallel or sequential) instances of an opcode poly : poly creates and controls multiple parallel version of an opcode polyseq : polyseq creates and controls multiple sequential version of an opcode jsfx A csound interface to the opensource implementation of jsfx jsfx : Instantiates and runs a jsfx script jsfx_new : Instantiates a jsfx script jsfx_play : Processes audio through a jsfx script jsfx_getslider : Gets a slider value of a jsfx instance jsfx_setslider : Sets the slider values of a jsfx script tubeharmonics : A distortion with control for odd/even harmonics sched Schedule an action when note is stopped atstop : Schedule an instrument at the end of the current instrument else Collection of miscellaneous plugins, most ports of supercollider, puredata/else or jsfx crackle : generates noise based on a chaotic equation ramptrig : A triggerable ramp between 0 and 1 sigmdrive : Analog \"soft clipping\" distortion by applying non-linear transfer functions. lfnoise : low frequency, band-limited noise schmitt : A schmitt trigger (a comparator with hysteresis). standardchaos : Standard map chaotic generator linenv : A triggerable linear envelope with sustain segment diode_ringmod : A ring modulator with optional non-linearities file_exists : Returns 1 if a file exists and can be read pargwrite : Modify parg values of an active instrument instance pargread : Read parg values from any active instrument instance","title":"Csound Plugins"},{"location":"index.html#csound-plugins","text":"Welcome to the csound-plugins wiki! This is a collection of plugins for csound","title":"Csound Plugins"},{"location":"index.html#installation","text":"See Installation","title":"Installation"},{"location":"index.html#klib","text":"A hashtable for csound dict_new : Create a hashtable dict_free : Free a hashtable dict_get : Get a value from a hashtable dict_set : Set (or remove) a value from a hashtable dict_size : Returns the number of key:value pairs in a dict dict_query : Query different properties of a dict dict_print : Prints the contents of a dict dict_iter : Iterate over the key-value pairs of a dict cacheput : Put a string inside the cache cacheget : Get a string inside the cache cachepop : Get a cached string and remove it from the cache","title":"klib"},{"location":"index.html#poly","text":"Multiple (parallel or sequential) instances of an opcode poly : poly creates and controls multiple parallel version of an opcode polyseq : polyseq creates and controls multiple sequential version of an opcode","title":"poly"},{"location":"index.html#jsfx","text":"A csound interface to the opensource implementation of jsfx jsfx : Instantiates and runs a jsfx script jsfx_new : Instantiates a jsfx script jsfx_play : Processes audio through a jsfx script jsfx_getslider : Gets a slider value of a jsfx instance jsfx_setslider : Sets the slider values of a jsfx script tubeharmonics : A distortion with control for odd/even harmonics","title":"jsfx"},{"location":"index.html#sched","text":"Schedule an action when note is stopped atstop : Schedule an instrument at the end of the current instrument","title":"sched"},{"location":"index.html#else","text":"Collection of miscellaneous plugins, most ports of supercollider, puredata/else or jsfx crackle : generates noise based on a chaotic equation ramptrig : A triggerable ramp between 0 and 1 sigmdrive : Analog \"soft clipping\" distortion by applying non-linear transfer functions. lfnoise : low frequency, band-limited noise schmitt : A schmitt trigger (a comparator with hysteresis). standardchaos : Standard map chaotic generator linenv : A triggerable linear envelope with sustain segment diode_ringmod : A ring modulator with optional non-linearities file_exists : Returns 1 if a file exists and can be read pargwrite : Modify parg values of an active instrument instance pargread : Read parg values from any active instrument instance","title":"else"},{"location":"Contributing.html","text":"Contributing To submit an opcode clone this repository and make a pull request Organisation An opcode is normally implemented as part of a library, to allow for different versions and related opcodes to share functionality. Each library lives in its own directory. The tree can be structured as follows: mylib/ CMakeLists.txt manifest.json [ README.md ] src/ mylib.c examples/ foo.csd bar.csd docs/ foo.md bar.md For each opcode defined in mylib.c there should be an example opcode.csd and a manual page opcode.md . Optionally it is possible to include a README.md where a short description of the opcodes in this library is given Put your tree under src and you should be able to build your plugin. Build We use cmake as a build tool. For simple opcodes with no extra dependencies, a simple CMakeLists.txt would suffice: make_plugin(mylib src/mylib.c) Installation At the root folder of this repository, do mkdir build cd build cmake .. make sudo make install Manifest A manifest is used to automate documentation of the opcodes (wiki, pdf documentation, etc). The manifest is a .json file. It should have the minimal form: { \"name\" : \"mylib\" , \"opcodes\" : [ \"foo\" , \"bar\" ], \"author\" : \"name\" , \"author_email\" : \"name@email.com\" , \"license\" : \"LGPL\" , \"description\" : \"Description of this package\" , \"url\" : \"http://github.com/...\" } In this case, three opcodes are defined, and these names should correspond to the .csd example living inside of the examples folder, and a .md file living inside the docs folder.","title":"Contributing"},{"location":"Contributing.html#contributing","text":"To submit an opcode clone this repository and make a pull request","title":"Contributing"},{"location":"Contributing.html#organisation","text":"An opcode is normally implemented as part of a library, to allow for different versions and related opcodes to share functionality. Each library lives in its own directory. The tree can be structured as follows: mylib/ CMakeLists.txt manifest.json [ README.md ] src/ mylib.c examples/ foo.csd bar.csd docs/ foo.md bar.md For each opcode defined in mylib.c there should be an example opcode.csd and a manual page opcode.md . Optionally it is possible to include a README.md where a short description of the opcodes in this library is given Put your tree under src and you should be able to build your plugin.","title":"Organisation"},{"location":"Contributing.html#build","text":"We use cmake as a build tool. For simple opcodes with no extra dependencies, a simple CMakeLists.txt would suffice: make_plugin(mylib src/mylib.c)","title":"Build"},{"location":"Contributing.html#installation","text":"At the root folder of this repository, do mkdir build cd build cmake .. make sudo make install","title":"Installation"},{"location":"Contributing.html#manifest","text":"A manifest is used to automate documentation of the opcodes (wiki, pdf documentation, etc). The manifest is a .json file. It should have the minimal form: { \"name\" : \"mylib\" , \"opcodes\" : [ \"foo\" , \"bar\" ], \"author\" : \"name\" , \"author_email\" : \"name@email.com\" , \"license\" : \"LGPL\" , \"description\" : \"Description of this package\" , \"url\" : \"http://github.com/...\" } In this case, three opcodes are defined, and these names should correspond to the .csd example living inside of the examples folder, and a .md file living inside the docs folder.","title":"Manifest"},{"location":"Installation.html","text":"Installation From Source The source lives at https://github.com/csound-plugins/csound-plugins Dependencies a compiler cmake csound >= 6.13 git clone https://github.com/csound-plugins/csound-plugins cd csound-plugins mkdir build cd build cmake .. make sudo make install","title":"Installation"},{"location":"Installation.html#installation","text":"","title":"Installation"},{"location":"Installation.html#from-source","text":"The source lives at https://github.com/csound-plugins/csound-plugins","title":"From Source"},{"location":"Installation.html#dependencies","text":"a compiler cmake csound >= 6.13 git clone https://github.com/csound-plugins/csound-plugins cd csound-plugins mkdir build cd build cmake .. make sudo make install","title":"Dependencies"},{"location":"opcodes/atstop.html","text":"atstop Abstract Schedule an instrument at the end of the current instrument Description atstop can be used to schedule an instrument event as the last action of a given instrument, during the process of being deallocated. This can be used to notify when the note has actually stopped, or to schedule a chain of events, free any table or dict allocated, etc. The advantage over the release opcode is that atstop is guaranteed to be run after the note has stopped, so there is no danger in deallocating resources being used by this note, there are no conflicts with release envelopes, etc. Release time vs deinit time The event is not scheduled at release time (see below \"Release time vs Deinit time\") but at the moment the note is freed. Release time is when the note is within its release phase , which will only happen if the note has an envelope with a release segment (like linsegr ), or if it has setup extra time with xtratim . The opcode release can be used to query if the current note is being released. The instrument keeps running in release phase as long as the release part of the envelope is finished or the extra time allocated via xtratim is through. Deinit time is the moment the note is actually being freed, so the instrument is not running anymore at this point. Syntax atstop instrnum [, idelay=0, idur=-1, p4, p5, ...] atstop Sinstrname [, idelay=0, idur=-1, p4, p5, ...] atstop executes only at init time . Arguments instrnum / Sintrname : the number or the name of the instr to be scheduled idelay : the time offset after the stop time of this note to start this instrument idur : the duration of the event p4 , p5 , ...: any other p-arguments, as used with similar opcodes like schedule , event , etc. Execution Time Init Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* # This is the example file for the atstop opcode atstop schedules an instrument at the end of the note This might be useful to notify that a note stopped, or to schedule a chain of notes, etc. NB: the scheduled event is NOT triggered at release time, which might be when this note is still playing, if the note has some release envelope, but when the note is being deleted ## Syntax atstop Sinstrname, idelay, idur, ... atstop instrnum, idelay, idur, ... * Sinstrname / instrnum: the name or the instrument number to schedule * idelay: time offset to this note stop * idur: duration of the scheduled event (-1 = forever) */ sr = 44100 ksmps = 64 0dbfs = 1 nchnls = 2 opcode myvco , a , ii i amp , i freq xin a 0 vco2 , i amp , i freq a 0 += vco2 ( i amp , i freq + 2 ) a 0 += vco2 ( i amp , i freq / 2 ) xout a 0 endop ; brownian walk instr 1 i midi = p4 a 0 myvco 0.1 , mtof : i ( i midi ) outs a 0 , a 0 i delta = round (( rnd ( 4 ) - 1 ) * 2 ) / 2 i delta = i delta != 0 ? i delta : - 0.5 i midi2 = i midi + i delta i midi2 = i midi2 < 96 ? i midi2 : 48 i durnext = round ( rnd ( 0.25 ) * 8 ) / 8 a tstop 1 , 0 , i durnext , i midi2 endin ; ping-pong instr 2 i midi = p4 i midi = i midi < 96 ? i midi : 48 a 0 myvco 0.1 , mtof : i ( i midi ) a 0 *= linsegr ( 0 , 0.05 , 1 , 0.05 , 0 ) outs a 0 , a 0 a tstop 3 , 0 , p3 * 0.97 , i midi + 1 endin instr 3 i midi = p4 i midi = i midi < 88 ? i midi : 48 a 0 oscili 0.8 , mtof : i ( i midi ) a 0 *= linsegr ( 0 , 0.05 , 1 , 0.050 , 0 ) outs a 0 , a 0 a tstop 2 , 0 , p3 * 0.95 , i midi + 1 endin ; test calling a named instr at stop instr 10 a 0 oscili 0.1 , 440 outs a 0 , a 0 a tstop \"foo\" , 0.5 , 1 , 1000 endin instr foo i freq = p4 a 0 oscili 0.1 , i freq outs a 0 , a 0 endin ; test simple case with optional pargs instr first a tstop \"second\" , 1 , - 1 , 0.5 a tstop \"second\" , 0.5 a tstop 200 endin instr second printf \"second! p4 = %f \\n \" , 1 , p4 turnoff endin instr 200 printf \"200! \\n \" , 1 turnoff endin instr StopPerformance exitnow endin </ CsInstruments > < CsScore > ; i 1 0 0.25 36 ; i 2 0 0.25 48 ; i 10 0 1 ; i \"StopPerformance\" 10 1 i \"first\" 1 0.5 f 0 5 </ CsScore > </ CsoundSynthesizer > See also schedule event release xtratim Credits Eduardo Moguillansky, 2019","title":"atstop"},{"location":"opcodes/atstop.html#atstop","text":"","title":"atstop"},{"location":"opcodes/atstop.html#abstract","text":"Schedule an instrument at the end of the current instrument","title":"Abstract"},{"location":"opcodes/atstop.html#description","text":"atstop can be used to schedule an instrument event as the last action of a given instrument, during the process of being deallocated. This can be used to notify when the note has actually stopped, or to schedule a chain of events, free any table or dict allocated, etc. The advantage over the release opcode is that atstop is guaranteed to be run after the note has stopped, so there is no danger in deallocating resources being used by this note, there are no conflicts with release envelopes, etc. Release time vs deinit time The event is not scheduled at release time (see below \"Release time vs Deinit time\") but at the moment the note is freed. Release time is when the note is within its release phase , which will only happen if the note has an envelope with a release segment (like linsegr ), or if it has setup extra time with xtratim . The opcode release can be used to query if the current note is being released. The instrument keeps running in release phase as long as the release part of the envelope is finished or the extra time allocated via xtratim is through. Deinit time is the moment the note is actually being freed, so the instrument is not running anymore at this point.","title":"Description"},{"location":"opcodes/atstop.html#syntax","text":"atstop instrnum [, idelay=0, idur=-1, p4, p5, ...] atstop Sinstrname [, idelay=0, idur=-1, p4, p5, ...] atstop executes only at init time .","title":"Syntax"},{"location":"opcodes/atstop.html#arguments","text":"instrnum / Sintrname : the number or the name of the instr to be scheduled idelay : the time offset after the stop time of this note to start this instrument idur : the duration of the event p4 , p5 , ...: any other p-arguments, as used with similar opcodes like schedule , event , etc.","title":"Arguments"},{"location":"opcodes/atstop.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/atstop.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* # This is the example file for the atstop opcode atstop schedules an instrument at the end of the note This might be useful to notify that a note stopped, or to schedule a chain of notes, etc. NB: the scheduled event is NOT triggered at release time, which might be when this note is still playing, if the note has some release envelope, but when the note is being deleted ## Syntax atstop Sinstrname, idelay, idur, ... atstop instrnum, idelay, idur, ... * Sinstrname / instrnum: the name or the instrument number to schedule * idelay: time offset to this note stop * idur: duration of the scheduled event (-1 = forever) */ sr = 44100 ksmps = 64 0dbfs = 1 nchnls = 2 opcode myvco , a , ii i amp , i freq xin a 0 vco2 , i amp , i freq a 0 += vco2 ( i amp , i freq + 2 ) a 0 += vco2 ( i amp , i freq / 2 ) xout a 0 endop ; brownian walk instr 1 i midi = p4 a 0 myvco 0.1 , mtof : i ( i midi ) outs a 0 , a 0 i delta = round (( rnd ( 4 ) - 1 ) * 2 ) / 2 i delta = i delta != 0 ? i delta : - 0.5 i midi2 = i midi + i delta i midi2 = i midi2 < 96 ? i midi2 : 48 i durnext = round ( rnd ( 0.25 ) * 8 ) / 8 a tstop 1 , 0 , i durnext , i midi2 endin ; ping-pong instr 2 i midi = p4 i midi = i midi < 96 ? i midi : 48 a 0 myvco 0.1 , mtof : i ( i midi ) a 0 *= linsegr ( 0 , 0.05 , 1 , 0.05 , 0 ) outs a 0 , a 0 a tstop 3 , 0 , p3 * 0.97 , i midi + 1 endin instr 3 i midi = p4 i midi = i midi < 88 ? i midi : 48 a 0 oscili 0.8 , mtof : i ( i midi ) a 0 *= linsegr ( 0 , 0.05 , 1 , 0.050 , 0 ) outs a 0 , a 0 a tstop 2 , 0 , p3 * 0.95 , i midi + 1 endin ; test calling a named instr at stop instr 10 a 0 oscili 0.1 , 440 outs a 0 , a 0 a tstop \"foo\" , 0.5 , 1 , 1000 endin instr foo i freq = p4 a 0 oscili 0.1 , i freq outs a 0 , a 0 endin ; test simple case with optional pargs instr first a tstop \"second\" , 1 , - 1 , 0.5 a tstop \"second\" , 0.5 a tstop 200 endin instr second printf \"second! p4 = %f \\n \" , 1 , p4 turnoff endin instr 200 printf \"200! \\n \" , 1 turnoff endin instr StopPerformance exitnow endin </ CsInstruments > < CsScore > ; i 1 0 0.25 36 ; i 2 0 0.25 48 ; i 10 0 1 ; i \"StopPerformance\" 10 1 i \"first\" 1 0.5 f 0 5 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/atstop.html#see-also","text":"schedule event release xtratim","title":"See also"},{"location":"opcodes/atstop.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/cacheget.html","text":"cacheget Abstract Get a string inside the cache Description The cache- opcodes implement a global string cache. This can be useful to pass multiple strings between instruments using the event opcode. This is similar to the strset and strget opcodes but automatically asigns an idx to each distints string inside the cache (we guarantee that passing twice the same string will return the same index) cacheget executes both at i-time and k-time , depending on the type of the input variable Syntax Sstr cacheget idx Sstr cacheget kdx Arguments idx / kdx : the numeric id representing the string, as returned by cacheput Output Sstr : the string inside the cache, corresponding to idx Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for cacheput / cacheget cacheput and cacheget implement a method to internalize strings, similar to strset and strget, but without having to take care about setting the indices cacheput puts a strin into the cache and returns an idx identifying this string. If a string is put into the cache which already exists, we guarantee that the index returned is the same. idx cacheput Sstr i-time kdx cacheput Sstr k-time cacheget retrieves a str previously put in the cache. If the index does not point to an existing string, a performance error is raised Sstr cacheget idx i-time Sstr cacheget kdx k-time Both opcodes work at both i- and k-time, depending on the arguments */ ; Use cacheput/get to pass multiple strings between instruments instr 1 event_i \"i\" , 2 , 0 , - 1 , cacheput : i ( \"foo\" ), cacheput : i ( \"bar\" ) turnoff endin instr 2 S 1 cacheget p4 S 2 cacheget p5 prints \"S1= %s S2= %s \\n \" , S 1 , S 2 turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 f 0 1 </ CsScore > </ CsoundSynthesizer > See also cacheput Credits Eduardo Moguillansky, 2019","title":"cacheget"},{"location":"opcodes/cacheget.html#cacheget","text":"","title":"cacheget"},{"location":"opcodes/cacheget.html#abstract","text":"Get a string inside the cache","title":"Abstract"},{"location":"opcodes/cacheget.html#description","text":"The cache- opcodes implement a global string cache. This can be useful to pass multiple strings between instruments using the event opcode. This is similar to the strset and strget opcodes but automatically asigns an idx to each distints string inside the cache (we guarantee that passing twice the same string will return the same index) cacheget executes both at i-time and k-time , depending on the type of the input variable","title":"Description"},{"location":"opcodes/cacheget.html#syntax","text":"Sstr cacheget idx Sstr cacheget kdx","title":"Syntax"},{"location":"opcodes/cacheget.html#arguments","text":"idx / kdx : the numeric id representing the string, as returned by cacheput","title":"Arguments"},{"location":"opcodes/cacheget.html#output","text":"Sstr : the string inside the cache, corresponding to idx","title":"Output"},{"location":"opcodes/cacheget.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/cacheget.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for cacheput / cacheget cacheput and cacheget implement a method to internalize strings, similar to strset and strget, but without having to take care about setting the indices cacheput puts a strin into the cache and returns an idx identifying this string. If a string is put into the cache which already exists, we guarantee that the index returned is the same. idx cacheput Sstr i-time kdx cacheput Sstr k-time cacheget retrieves a str previously put in the cache. If the index does not point to an existing string, a performance error is raised Sstr cacheget idx i-time Sstr cacheget kdx k-time Both opcodes work at both i- and k-time, depending on the arguments */ ; Use cacheput/get to pass multiple strings between instruments instr 1 event_i \"i\" , 2 , 0 , - 1 , cacheput : i ( \"foo\" ), cacheput : i ( \"bar\" ) turnoff endin instr 2 S 1 cacheget p4 S 2 cacheget p5 prints \"S1= %s S2= %s \\n \" , S 1 , S 2 turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 f 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/cacheget.html#see-also","text":"cacheput","title":"See also"},{"location":"opcodes/cacheget.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/cachepop.html","text":"cachepop Abstract Get a cached string and remove it from the cache Description The cache- opcodes implement a global string cache. This can be useful to pass multiple strings between instruments using the event opcode. This is similar to the strset and strget opcodes but automatically asigns an idx to each distints string inside the cache (we guarantee that passing twice the same string will return the same index). cachepop is similar to cacheget but after retrievin the value from the cache it is removed. This can be useful for cases where one-of strings are passed between instruments and do not need to survive the current note Syntax Sstr cachepop idx Arguments idx : the numeric id representing the string, as returned by cacheput Output Sstr : the string inside the cache, corresponding to idx Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for cacheput / cacheget / cachepop cacheput and cacheget implement a method to internalize strings, similar to strset and strget, but without having to take care about setting the indices. cachepop is similar to cacheget but removes the entry from the cache. cacheput puts a strin into the cache and returns an idx identifying this string. If a string is put into the cache which already exists, we guarantee that the index returned is the same. */ ; Use cacheput/pop to pass multiple strings between instruments instr 1 event_i \"i\" , 2 , 0 , - 1 , cacheput : i ( \"foo\" ), cacheput : i ( \"bar\" ) turnoff endin instr 2 S 1 cachepop p4 S 2 cachepop p5 ; these strings are no longer in the cache prints \"S1= %s S2= %s \\n \" , S 1 , S 2 turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 f 0 1 </ CsScore > </ CsoundSynthesizer > See also cacheput cacheget Credits Eduardo Moguillansky, 2019","title":"cachepop"},{"location":"opcodes/cachepop.html#cachepop","text":"","title":"cachepop"},{"location":"opcodes/cachepop.html#abstract","text":"Get a cached string and remove it from the cache","title":"Abstract"},{"location":"opcodes/cachepop.html#description","text":"The cache- opcodes implement a global string cache. This can be useful to pass multiple strings between instruments using the event opcode. This is similar to the strset and strget opcodes but automatically asigns an idx to each distints string inside the cache (we guarantee that passing twice the same string will return the same index). cachepop is similar to cacheget but after retrievin the value from the cache it is removed. This can be useful for cases where one-of strings are passed between instruments and do not need to survive the current note","title":"Description"},{"location":"opcodes/cachepop.html#syntax","text":"Sstr cachepop idx","title":"Syntax"},{"location":"opcodes/cachepop.html#arguments","text":"idx : the numeric id representing the string, as returned by cacheput","title":"Arguments"},{"location":"opcodes/cachepop.html#output","text":"Sstr : the string inside the cache, corresponding to idx","title":"Output"},{"location":"opcodes/cachepop.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/cachepop.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for cacheput / cacheget / cachepop cacheput and cacheget implement a method to internalize strings, similar to strset and strget, but without having to take care about setting the indices. cachepop is similar to cacheget but removes the entry from the cache. cacheput puts a strin into the cache and returns an idx identifying this string. If a string is put into the cache which already exists, we guarantee that the index returned is the same. */ ; Use cacheput/pop to pass multiple strings between instruments instr 1 event_i \"i\" , 2 , 0 , - 1 , cacheput : i ( \"foo\" ), cacheput : i ( \"bar\" ) turnoff endin instr 2 S 1 cachepop p4 S 2 cachepop p5 ; these strings are no longer in the cache prints \"S1= %s S2= %s \\n \" , S 1 , S 2 turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 f 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/cachepop.html#see-also","text":"cacheput cacheget","title":"See also"},{"location":"opcodes/cachepop.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/cacheput.html","text":"cacheput Abstract Put a string inside the cache Description The cache- opcodes implement a global string cache. This can be useful to pass multiple strings between instruments using the event opcode. This is similar to the strset and strget opcodes but automatically asigns an idx to each distints string inside the cache (we guarantee that passing twice the same string will return the same index) Syntax idx cacheput Sstr kdx cacheput Sstr Arguments Sstr : the string to be put inside the cache Output idx / kdx : the numeric id representing the string passed Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for cacheput / cacheget cacheput and cacheget implement a method to internalize strings, similar to strset and strget, but without having to take care about setting the indices cacheput puts a strin into the cache and returns an idx identifying this string. If a string is put into the cache which already exists, we guarantee that the index returned is the same. idx cacheput Sstr i-time kdx cacheput Sstr k-time cacheget retrieves a str previously put in the cache. If the index does not point to an existing string, a performance error is raised Sstr cacheget idx i-time Sstr cacheget kdx k-time Both opcodes work at both i- and k-time, depending on the arguments */ ; Use cacheput/get to pass multiple strings between instruments instr 1 event_i \"i\" , 2 , 0 , - 1 , cacheput : i ( \"foo\" ), cacheput : i ( \"bar\" ) turnoff endin instr 2 S 1 cacheget p4 S 2 cacheget p5 prints \"S1= %s S2= %s \\n \" , S 1 , S 2 turnoff endin instr 10 k trig metro 10 k i init 0 if k trig == 1 then k i += 1 event \"i\" , 20 , 0 , - 1 , cacheput : k ( sprintfk ( \"key %d \" , k i )) endif endin instr 20 S 1 cacheget p4 prints \"S1 = %s \\n \" , S 1 turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 i 10 + 1 f 0 1 </ CsScore > </ CsoundSynthesizer > See also cacheget Credits Eduardo Moguillansky, 2019","title":"cacheput"},{"location":"opcodes/cacheput.html#cacheput","text":"","title":"cacheput"},{"location":"opcodes/cacheput.html#abstract","text":"Put a string inside the cache","title":"Abstract"},{"location":"opcodes/cacheput.html#description","text":"The cache- opcodes implement a global string cache. This can be useful to pass multiple strings between instruments using the event opcode. This is similar to the strset and strget opcodes but automatically asigns an idx to each distints string inside the cache (we guarantee that passing twice the same string will return the same index)","title":"Description"},{"location":"opcodes/cacheput.html#syntax","text":"idx cacheput Sstr kdx cacheput Sstr","title":"Syntax"},{"location":"opcodes/cacheput.html#arguments","text":"Sstr : the string to be put inside the cache","title":"Arguments"},{"location":"opcodes/cacheput.html#output","text":"idx / kdx : the numeric id representing the string passed","title":"Output"},{"location":"opcodes/cacheput.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/cacheput.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for cacheput / cacheget cacheput and cacheget implement a method to internalize strings, similar to strset and strget, but without having to take care about setting the indices cacheput puts a strin into the cache and returns an idx identifying this string. If a string is put into the cache which already exists, we guarantee that the index returned is the same. idx cacheput Sstr i-time kdx cacheput Sstr k-time cacheget retrieves a str previously put in the cache. If the index does not point to an existing string, a performance error is raised Sstr cacheget idx i-time Sstr cacheget kdx k-time Both opcodes work at both i- and k-time, depending on the arguments */ ; Use cacheput/get to pass multiple strings between instruments instr 1 event_i \"i\" , 2 , 0 , - 1 , cacheput : i ( \"foo\" ), cacheput : i ( \"bar\" ) turnoff endin instr 2 S 1 cacheget p4 S 2 cacheget p5 prints \"S1= %s S2= %s \\n \" , S 1 , S 2 turnoff endin instr 10 k trig metro 10 k i init 0 if k trig == 1 then k i += 1 event \"i\" , 20 , 0 , - 1 , cacheput : k ( sprintfk ( \"key %d \" , k i )) endif endin instr 20 S 1 cacheget p4 prints \"S1 = %s \\n \" , S 1 turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 i 10 + 1 f 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/cacheput.html#see-also","text":"cacheget","title":"See also"},{"location":"opcodes/cacheput.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/crackle.html","text":"crackle Abstract generates noise based on a chaotic equation Description crackle is a chaotic generator, the sound is generated with the following equation y[n] = p * y[n-1]- y[n-2] - 0.05 Port of supercollider's Crackle Syntax aout crackle kp Arguments kp : the p parameter in the equation, a value between 1.0 and 2.0 Output aout : audio output of the chaotic generator Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* # This is the example file for the crackle opcode crackle is a port of supercollider's crackle (taken from pd/else) crackle is a chaotic noise generator based on the equation: y[n] = p * y[n-1] - y[n-2] - 0.05 ## Syntax aout crackle kp=0.5 * kp: value for p in the equation (default = 0.5) * aout: noise signal */ sr = 44100 ksmps = 64 0dbfs = 1 nchnls = 2 instr 1 k P [] fillarray 1.0 , 1.2 , 1.3 , 1.35 , 1.4 , 1.5 , 1.8 , 1.9 , 1.97 , 2.0 k idx = int ( line ( 0 , p3 , lenarray ( k P ))) k p = k P [ k idx ] printk2 k p a out crackle k p a out *= 0.5 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 15 </ CsScore > </ CsoundSynthesizer > See also standardchaos chuap dust2 Credits Eduardo Moguillansky, 2019","title":"crackle"},{"location":"opcodes/crackle.html#crackle","text":"","title":"crackle"},{"location":"opcodes/crackle.html#abstract","text":"generates noise based on a chaotic equation","title":"Abstract"},{"location":"opcodes/crackle.html#description","text":"crackle is a chaotic generator, the sound is generated with the following equation y[n] = p * y[n-1]- y[n-2] - 0.05 Port of supercollider's Crackle","title":"Description"},{"location":"opcodes/crackle.html#syntax","text":"aout crackle kp","title":"Syntax"},{"location":"opcodes/crackle.html#arguments","text":"kp : the p parameter in the equation, a value between 1.0 and 2.0","title":"Arguments"},{"location":"opcodes/crackle.html#output","text":"aout : audio output of the chaotic generator","title":"Output"},{"location":"opcodes/crackle.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/crackle.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* # This is the example file for the crackle opcode crackle is a port of supercollider's crackle (taken from pd/else) crackle is a chaotic noise generator based on the equation: y[n] = p * y[n-1] - y[n-2] - 0.05 ## Syntax aout crackle kp=0.5 * kp: value for p in the equation (default = 0.5) * aout: noise signal */ sr = 44100 ksmps = 64 0dbfs = 1 nchnls = 2 instr 1 k P [] fillarray 1.0 , 1.2 , 1.3 , 1.35 , 1.4 , 1.5 , 1.8 , 1.9 , 1.97 , 2.0 k idx = int ( line ( 0 , p3 , lenarray ( k P ))) k p = k P [ k idx ] printk2 k p a out crackle k p a out *= 0.5 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 15 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/crackle.html#see-also","text":"standardchaos chuap dust2","title":"See also"},{"location":"opcodes/crackle.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_free.html","text":"dict_free Abstract Free a hashtable Description frees the hashtable either at init time or at the end of the note (similar to ftfree) A dict can only be freed if it was created as global (see dict_new ). To be able to pass a dict between notes, a note can create a global dict and pass its handle to another note. When the first note is released, the dict lives on (because it is global), and it will be either freed at the end of the performance or explicitely by calling dict_free dict_free executes only at init time . Syntax dict_free idict [, iwhen=0] Arguments idict : the handle of the dict to be freed iwhen : similar to ftfree if iwhen == 0 : free the dict now if iwhen == 1 : free the dict at the end of this note Execution Time Init Examples < CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > See also dict_new Credits Eduardo Moguillansky, 2019","title":"dict_free"},{"location":"opcodes/dict_free.html#dict_free","text":"","title":"dict_free"},{"location":"opcodes/dict_free.html#abstract","text":"Free a hashtable","title":"Abstract"},{"location":"opcodes/dict_free.html#description","text":"frees the hashtable either at init time or at the end of the note (similar to ftfree) A dict can only be freed if it was created as global (see dict_new ). To be able to pass a dict between notes, a note can create a global dict and pass its handle to another note. When the first note is released, the dict lives on (because it is global), and it will be either freed at the end of the performance or explicitely by calling dict_free dict_free executes only at init time .","title":"Description"},{"location":"opcodes/dict_free.html#syntax","text":"dict_free idict [, iwhen=0]","title":"Syntax"},{"location":"opcodes/dict_free.html#arguments","text":"idict : the handle of the dict to be freed iwhen : similar to ftfree if iwhen == 0 : free the dict now if iwhen == 1 : free the dict at the end of this note","title":"Arguments"},{"location":"opcodes/dict_free.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/dict_free.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_free.html#see-also","text":"dict_new","title":"See also"},{"location":"opcodes/dict_free.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_get.html","text":"dict_get Abstract Get a value from a hashtable Description A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_get returns the value for a given key. If the key is not present, a default value is returned (the empty string for string values, or an user given default for number values) Syntax kvalue dict_get idict, Skeym [idefault=0] kvalue dict_get idict, kkey, [idefault=0] Svalue dict_get idict, Skey Svalue dict_get idict, kkey The type of key and value depend on the type definition of the dict , see dict_new dict_get executes both at i-time and k-time . Arguments \u00ecdict : the handle of the dict, as returned by dict_new Skey / kkey : the key to be queries, as previously set by dict_set idefault : if the key is not present, this value is returned (defaults to 0) Output kvalue / Svalue : the value corresponding to the key, or a default if the key is not found For dicts with a string value, an empty string is returned when the key is not found. For dicts with a numeric value, a user given default is returned (default=0) Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > < CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > /* # Example file for the dict_ opcode family A dict is a hashtable, mapping a string or an integer key to a string or float value. The type of the key and value are set at creation time and can't be modified later on The lifespan of a dict can be attached to the instr it was created in, or it can be global, in which case it lives until the end of the performance, or until it is explicitely destroyed (see dict_free) A dict is identified by a handler, which is an integer value, and thus can be passed around between intruments, the handlers can be part of other structures, like arrays or other dicts, etc. # Opcodes ## dict_new ihandle dict_new Stype [, iglobal=0, key, value, key, value, ...] Creates a new dictionary, either local to the instr or global Stype: a string identifying the types of key and value. \"ss\" : string -> string \"sf\" : string -> float \"is\" : int -> string \"if\" : int -> float iglobal: if 1, the dict is global and lives until the end of the performance, or until explicitely destroyed by dict_free Optionally the dict can be populated at creation time with a series of key:value pairs ## dict_free dict_free idict [, iwhen=0] frees the hashtable either at init time or at the end of the note (similar to ftfree) This is needed when passing a dict from one instrument to another * iwhen = 0, free now * iwhen = 1, free at the end of this note ## dict_set dict_set idict, Skey, kvalue ; k-time dict_set idict, kkey, kvalue ; k-time dict_set idict, ikey, ivalue ; i-time Set a key:value pair idict dict_new \"sf\" dict_set idict, \"key\", kvalue Without a value, deletes the key:value pair ## dict_get kvalue dict_get idict, \"key\" [, kdefault=0] Get the value at a given key. For string values, an empty string is returned when the key is not found. For int values, a default value given by the user is returned when the key is not found. ## dict_print dict_print ihandle, [ktrig] Prints the contents of the dict, either at i-time if no trigger is given, or at k-time whenever ktrig is possitive and different from the last value. Use -1 to print at every k-cycle. NB: All opcodes work at k-tim. The hashtables with int-keys work also at i-time whenever key and value are of i-type (for both set and get actions) */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve teh value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, mapping strings to strings i dict2 dict_new \"ss\" dict_set i dict2 , \"baz\" , \"bazvalue\" dict_set i dict2 , \"hoo\" , \"hoovalue\" S baz dict_get i dict2 , \"baz\" S hoo dict_get i dict2 , \"hoo\" printf \">>>> baz: %s , hoo: %s \\n \" , 1 , S baz , S hoo turnoff endin instr 2 ;; set and get if timeinstk () > 1 kgoto perf ;; this starts at 1 i maxcnt = 100 i dict dict_new \"ss\" k cnt = 0 while k cnt < i maxcnt do S key sprintfk \"key_ %d \" , k cnt S value sprintfk \"value_ %d \" , k cnt dict_set i dict , S key , S value k cnt += 1 od perf : k cnt = 0 while k cnt < i maxcnt do S key sprintfk \"key_ %d \" , k cnt ; the same for get, the key can change at k-time S value dict_get i dict , S key printf \"key: %s , value: %s \\n \" , k cnt , S key , S value k cnt += 1 od endin instr 3 /* dict_iter xkey, xvalue, kidx dict_iter ihandle [,kreset=1] kidx: holds the number of pairs yielded since last reset. It is set to -1 when iteration has stopped (in this case, xkey and xvalue are invalid and should not be used) kreset = 0 -> after iterating over all pairs iteration stops In this mode, iteration happens at most once 1 -> iteration starts over every k-cycle 2 -> iteration restarts after stopping */ k t timeinstk if k t > 1 kgoto perf i dict dict_new \"sf\" dict_set i dict , \"foo\" , 1 dict_set i dict , \"bar\" , 2 dict_set i dict , \"baz\" , 15 dict_set i dict , \"bee\" , 9 perf : ; iterate with a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"while) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value od ; the same but with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"loop) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value kgoto loop break : endin instr 4 ; test deleting a key ; ~~~~~~~~~~~~~~~~~~~ i dict dict_new \"ss\" ; set a key:value pair dict_set i dict , \"foo\" , \"foovalue\" ; get the value, print it S foo dict_get i dict , \"foo\" printf \"key: foo value: %s \\n \" , 1 , S foo ; dict_set without value deletes the key:value pair dict_set i dict , \"foo\" ; now check that the pair is gone S foo dict_get i dict , \"foo\" if ( strlen ( S foo ) == 0 ) then printf \"key does not exist \\n \" , 1 endif turnoff endin instr 5 ; dicts can be passed between instruments ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ if timeinstk () > 1 goto perf ; create a dict which survives this note i dict1 dict_new \"sf\" , 1 ; set some initial values once dict_set i dict1 , \"foo\" , 1 dict_set i dict1 , \"bar\" , 2 ; launch instr 6, which will outlive this note, pass idict as p4 event \"i\" , \"midifydict\" , 0 , p3 + 1 , i dict1 perf : k foo dict_get i dict1 , \"foo\" printk2 k foo endin instr modifydict ; here we modify instr 5's dictionary ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; the dict was created by instr 5 i dict = p4 k foo line 0 , p3 - 1 , 10 dict_set i dict , \"foo\" , k foo dict_free i dict , 1 ; 1 = free dict when note ends endin instr 7 ; it is possible to create a new dict and set initial ; values at once. This is only executed at i-time i dict dict_new \"sf\" , 0 , \"foo\" , 10 , \"bar\" , 20 , \"baz\" , 30 k baz dict_get i dict , \"baz\" k bar dict_get i dict , \"bar\" k xx dict_get i dict , \"xx\" , 99 printf \"baz: %f bar: %f xx: %f \\n \" , 1 , k baz , k bar , k xx turnoff endin instr 8 ; get all the keys as an array i dict1 dict_new \"sf\" , 0 , \"keyA\" , 1 , \"keyB\" , 2 , \"keyC\" , 3 S Keys [] dict_query i dict1 , \"keys\" printarray S Keys i dict2 dict_new \"if\" , 0 , 1 , 100 , 10 , 1000 , 2 , 200 k Keys [] dict_query i dict2 , \"keys\" printarray k Keys , 1 , \" %.0f \" ; get values as an array i dict3 dict_new \"is\" , 0 , 10 , \"foo\" , 20 , \"bar\" , 30 , \"baz\" S vals [] dict_query i dict3 , \"values\" printarray S vals k Vals [] dict_query i dict2 , \"values\" printarray k Vals turnoff endin ; One convenient use of dicts is to pass arguments to an instr instr 100 ; create our communication dict, set initial values i dict dict_new \"sf\" , 0 , \"amp\" , 0.1 , \"freq\" , 1000 ; the launched instr will last longer, so will have to deal with ; this dict ceasing to exist event_i \"i\" , 101 , 0 , p3 + 1 , i dict ; now we can control the synth with the dict dict_set i dict , \"freq\" , linseg : k ( 440 , p3 , 455 ) a 0 oscili 0.1 , 440 outch 1 , a 0 endin ; a variation on dict_get where we either get the value corresponding to a key, ; or the last value, if the dict does not exist opcode dict_receive , k , iSi i dict , S key , i val0 xin k last init i val0 if ( dict_size ( i dict ) > 0 ) then k val dict_get i dict , S key , i val0 k last = k val else k val = k last endif xout k val endop instr 101 i dict = p4 ; get the value for a given key. when the dict does not exist, just ; outputs the last value k amp dict_receive i dict , \"amp\" , 0.1 k freq dict_receive i dict , \"freq\" , 1000 a 0 oscili k amp , k freq outch 2 , a 0 endin </ CsInstruments > < CsScore > ; i 1 0 0.01 ; i 2 0 0.01 i 8 0 0.1 i 100 0 10 f 0 1 </ CsScore > </ CsoundSynthesizer > See also dict_new dict_set Credits Eduardo Moguillansky, 2019","title":"dict_get"},{"location":"opcodes/dict_get.html#dict_get","text":"","title":"dict_get"},{"location":"opcodes/dict_get.html#abstract","text":"Get a value from a hashtable","title":"Abstract"},{"location":"opcodes/dict_get.html#description","text":"A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_get returns the value for a given key. If the key is not present, a default value is returned (the empty string for string values, or an user given default for number values)","title":"Description"},{"location":"opcodes/dict_get.html#syntax","text":"kvalue dict_get idict, Skeym [idefault=0] kvalue dict_get idict, kkey, [idefault=0] Svalue dict_get idict, Skey Svalue dict_get idict, kkey The type of key and value depend on the type definition of the dict , see dict_new dict_get executes both at i-time and k-time .","title":"Syntax"},{"location":"opcodes/dict_get.html#arguments","text":"\u00ecdict : the handle of the dict, as returned by dict_new Skey / kkey : the key to be queries, as previously set by dict_set idefault : if the key is not present, this value is returned (defaults to 0)","title":"Arguments"},{"location":"opcodes/dict_get.html#output","text":"kvalue / Svalue : the value corresponding to the key, or a default if the key is not found For dicts with a string value, an empty string is returned when the key is not found. For dicts with a numeric value, a user given default is returned (default=0)","title":"Output"},{"location":"opcodes/dict_get.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/dict_get.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > < CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > /* # Example file for the dict_ opcode family A dict is a hashtable, mapping a string or an integer key to a string or float value. The type of the key and value are set at creation time and can't be modified later on The lifespan of a dict can be attached to the instr it was created in, or it can be global, in which case it lives until the end of the performance, or until it is explicitely destroyed (see dict_free) A dict is identified by a handler, which is an integer value, and thus can be passed around between intruments, the handlers can be part of other structures, like arrays or other dicts, etc. # Opcodes ## dict_new ihandle dict_new Stype [, iglobal=0, key, value, key, value, ...] Creates a new dictionary, either local to the instr or global Stype: a string identifying the types of key and value. \"ss\" : string -> string \"sf\" : string -> float \"is\" : int -> string \"if\" : int -> float iglobal: if 1, the dict is global and lives until the end of the performance, or until explicitely destroyed by dict_free Optionally the dict can be populated at creation time with a series of key:value pairs ## dict_free dict_free idict [, iwhen=0] frees the hashtable either at init time or at the end of the note (similar to ftfree) This is needed when passing a dict from one instrument to another * iwhen = 0, free now * iwhen = 1, free at the end of this note ## dict_set dict_set idict, Skey, kvalue ; k-time dict_set idict, kkey, kvalue ; k-time dict_set idict, ikey, ivalue ; i-time Set a key:value pair idict dict_new \"sf\" dict_set idict, \"key\", kvalue Without a value, deletes the key:value pair ## dict_get kvalue dict_get idict, \"key\" [, kdefault=0] Get the value at a given key. For string values, an empty string is returned when the key is not found. For int values, a default value given by the user is returned when the key is not found. ## dict_print dict_print ihandle, [ktrig] Prints the contents of the dict, either at i-time if no trigger is given, or at k-time whenever ktrig is possitive and different from the last value. Use -1 to print at every k-cycle. NB: All opcodes work at k-tim. The hashtables with int-keys work also at i-time whenever key and value are of i-type (for both set and get actions) */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve teh value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, mapping strings to strings i dict2 dict_new \"ss\" dict_set i dict2 , \"baz\" , \"bazvalue\" dict_set i dict2 , \"hoo\" , \"hoovalue\" S baz dict_get i dict2 , \"baz\" S hoo dict_get i dict2 , \"hoo\" printf \">>>> baz: %s , hoo: %s \\n \" , 1 , S baz , S hoo turnoff endin instr 2 ;; set and get if timeinstk () > 1 kgoto perf ;; this starts at 1 i maxcnt = 100 i dict dict_new \"ss\" k cnt = 0 while k cnt < i maxcnt do S key sprintfk \"key_ %d \" , k cnt S value sprintfk \"value_ %d \" , k cnt dict_set i dict , S key , S value k cnt += 1 od perf : k cnt = 0 while k cnt < i maxcnt do S key sprintfk \"key_ %d \" , k cnt ; the same for get, the key can change at k-time S value dict_get i dict , S key printf \"key: %s , value: %s \\n \" , k cnt , S key , S value k cnt += 1 od endin instr 3 /* dict_iter xkey, xvalue, kidx dict_iter ihandle [,kreset=1] kidx: holds the number of pairs yielded since last reset. It is set to -1 when iteration has stopped (in this case, xkey and xvalue are invalid and should not be used) kreset = 0 -> after iterating over all pairs iteration stops In this mode, iteration happens at most once 1 -> iteration starts over every k-cycle 2 -> iteration restarts after stopping */ k t timeinstk if k t > 1 kgoto perf i dict dict_new \"sf\" dict_set i dict , \"foo\" , 1 dict_set i dict , \"bar\" , 2 dict_set i dict , \"baz\" , 15 dict_set i dict , \"bee\" , 9 perf : ; iterate with a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"while) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value od ; the same but with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"loop) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value kgoto loop break : endin instr 4 ; test deleting a key ; ~~~~~~~~~~~~~~~~~~~ i dict dict_new \"ss\" ; set a key:value pair dict_set i dict , \"foo\" , \"foovalue\" ; get the value, print it S foo dict_get i dict , \"foo\" printf \"key: foo value: %s \\n \" , 1 , S foo ; dict_set without value deletes the key:value pair dict_set i dict , \"foo\" ; now check that the pair is gone S foo dict_get i dict , \"foo\" if ( strlen ( S foo ) == 0 ) then printf \"key does not exist \\n \" , 1 endif turnoff endin instr 5 ; dicts can be passed between instruments ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ if timeinstk () > 1 goto perf ; create a dict which survives this note i dict1 dict_new \"sf\" , 1 ; set some initial values once dict_set i dict1 , \"foo\" , 1 dict_set i dict1 , \"bar\" , 2 ; launch instr 6, which will outlive this note, pass idict as p4 event \"i\" , \"midifydict\" , 0 , p3 + 1 , i dict1 perf : k foo dict_get i dict1 , \"foo\" printk2 k foo endin instr modifydict ; here we modify instr 5's dictionary ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; the dict was created by instr 5 i dict = p4 k foo line 0 , p3 - 1 , 10 dict_set i dict , \"foo\" , k foo dict_free i dict , 1 ; 1 = free dict when note ends endin instr 7 ; it is possible to create a new dict and set initial ; values at once. This is only executed at i-time i dict dict_new \"sf\" , 0 , \"foo\" , 10 , \"bar\" , 20 , \"baz\" , 30 k baz dict_get i dict , \"baz\" k bar dict_get i dict , \"bar\" k xx dict_get i dict , \"xx\" , 99 printf \"baz: %f bar: %f xx: %f \\n \" , 1 , k baz , k bar , k xx turnoff endin instr 8 ; get all the keys as an array i dict1 dict_new \"sf\" , 0 , \"keyA\" , 1 , \"keyB\" , 2 , \"keyC\" , 3 S Keys [] dict_query i dict1 , \"keys\" printarray S Keys i dict2 dict_new \"if\" , 0 , 1 , 100 , 10 , 1000 , 2 , 200 k Keys [] dict_query i dict2 , \"keys\" printarray k Keys , 1 , \" %.0f \" ; get values as an array i dict3 dict_new \"is\" , 0 , 10 , \"foo\" , 20 , \"bar\" , 30 , \"baz\" S vals [] dict_query i dict3 , \"values\" printarray S vals k Vals [] dict_query i dict2 , \"values\" printarray k Vals turnoff endin ; One convenient use of dicts is to pass arguments to an instr instr 100 ; create our communication dict, set initial values i dict dict_new \"sf\" , 0 , \"amp\" , 0.1 , \"freq\" , 1000 ; the launched instr will last longer, so will have to deal with ; this dict ceasing to exist event_i \"i\" , 101 , 0 , p3 + 1 , i dict ; now we can control the synth with the dict dict_set i dict , \"freq\" , linseg : k ( 440 , p3 , 455 ) a 0 oscili 0.1 , 440 outch 1 , a 0 endin ; a variation on dict_get where we either get the value corresponding to a key, ; or the last value, if the dict does not exist opcode dict_receive , k , iSi i dict , S key , i val0 xin k last init i val0 if ( dict_size ( i dict ) > 0 ) then k val dict_get i dict , S key , i val0 k last = k val else k val = k last endif xout k val endop instr 101 i dict = p4 ; get the value for a given key. when the dict does not exist, just ; outputs the last value k amp dict_receive i dict , \"amp\" , 0.1 k freq dict_receive i dict , \"freq\" , 1000 a 0 oscili k amp , k freq outch 2 , a 0 endin </ CsInstruments > < CsScore > ; i 1 0 0.01 ; i 2 0 0.01 i 8 0 0.1 i 100 0 10 f 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_get.html#see-also","text":"dict_new dict_set","title":"See also"},{"location":"opcodes/dict_get.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_iter.html","text":"dict_iter Abstract Iterate over the key-value pairs of a dict Description Iterates over the key:value pairs. Whenever kreset is 1, iteration starts over If kreset is -1 (the default), iteration is autotriggered when it reaches the end of the collection. dict_loop executes only at Performance Time . Note dict_iter is meant to be used in a loop at k-time Syntax xkey, xvalue, kidx dict_iter idict [, kreset = -1] Arguments idict : the handle to the dict as returned by dict_new kreset : the reset policy kreset effect 0 no reset, iteration stops at the end of the collection. There will be at most 1 iteration 1 (default) Iteration starts over at every k-cycle 2 Reset at the end of iteration (independent of k-cycle) Output xkey / xvalue : the key and value for this pair. The types are determined by the type of this dict, as defined via dict_new kidx : the index of this pair. It will be 0 for the first pair, 1 for the second, etc. When no more pairs, kidx will be -1. In this case, xkey and xvalue do not hold valid values Execution time Performance Usage There are two ways to use dict_iter , either in a while loop, or using gotos ; iterate in a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"key: %s value: %f \" , k idx , S key , k value od ; iterate with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"key: %s value: %f \" , k idx , S key , k value kgoto loop break : Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* # Example file for dict_iter opcode */ instr 1 /* dict_iter xkey, xvalue, kidx dict_iter ihandle [,kreset=1] kidx: holds the number of pairs yielded since last reset. It is set to -1 when iteration has stopped (in this case, xkey and xvalue are invalid and should not be used) kreset = 0 -> after iterating over all pairs iteration stops In this mode, iteration happens at most once 1 -> iteration starts over every k-cycle 2 -> iteration restarts after stopping */ i dict dict_new \"str:float\" , 0 , \"foo\" , 1 , \"bar\" , 2 , \"baz\" , 15 , \"bee\" , 9 k t timeinstk ; iterate with a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"while) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value od ; the same but with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"loop) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value kgoto loop break : endin </ CsInstruments > < CsScore > i 1 0 0.05 </ CsScore > </ CsoundSynthesizer > See also dict_new dict_size Credits Eduardo Moguillansky, 2019","title":"dict_iter"},{"location":"opcodes/dict_iter.html#dict_iter","text":"","title":"dict_iter"},{"location":"opcodes/dict_iter.html#abstract","text":"Iterate over the key-value pairs of a dict","title":"Abstract"},{"location":"opcodes/dict_iter.html#description","text":"Iterates over the key:value pairs. Whenever kreset is 1, iteration starts over If kreset is -1 (the default), iteration is autotriggered when it reaches the end of the collection. dict_loop executes only at Performance Time . Note dict_iter is meant to be used in a loop at k-time","title":"Description"},{"location":"opcodes/dict_iter.html#syntax","text":"xkey, xvalue, kidx dict_iter idict [, kreset = -1]","title":"Syntax"},{"location":"opcodes/dict_iter.html#arguments","text":"idict : the handle to the dict as returned by dict_new kreset : the reset policy kreset effect 0 no reset, iteration stops at the end of the collection. There will be at most 1 iteration 1 (default) Iteration starts over at every k-cycle 2 Reset at the end of iteration (independent of k-cycle)","title":"Arguments"},{"location":"opcodes/dict_iter.html#output","text":"xkey / xvalue : the key and value for this pair. The types are determined by the type of this dict, as defined via dict_new kidx : the index of this pair. It will be 0 for the first pair, 1 for the second, etc. When no more pairs, kidx will be -1. In this case, xkey and xvalue do not hold valid values","title":"Output"},{"location":"opcodes/dict_iter.html#execution-time","text":"Performance","title":"Execution time"},{"location":"opcodes/dict_iter.html#usage","text":"There are two ways to use dict_iter , either in a while loop, or using gotos ; iterate in a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"key: %s value: %f \" , k idx , S key , k value od ; iterate with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"key: %s value: %f \" , k idx , S key , k value kgoto loop break :","title":"Usage"},{"location":"opcodes/dict_iter.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* # Example file for dict_iter opcode */ instr 1 /* dict_iter xkey, xvalue, kidx dict_iter ihandle [,kreset=1] kidx: holds the number of pairs yielded since last reset. It is set to -1 when iteration has stopped (in this case, xkey and xvalue are invalid and should not be used) kreset = 0 -> after iterating over all pairs iteration stops In this mode, iteration happens at most once 1 -> iteration starts over every k-cycle 2 -> iteration restarts after stopping */ i dict dict_new \"str:float\" , 0 , \"foo\" , 1 , \"bar\" , 2 , \"baz\" , 15 , \"bee\" , 9 k t timeinstk ; iterate with a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"while) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value od ; the same but with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"loop) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value kgoto loop break : endin </ CsInstruments > < CsScore > i 1 0 0.05 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_iter.html#see-also","text":"dict_new dict_size","title":"See also"},{"location":"opcodes/dict_iter.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_new.html","text":"dict_new Abstract Create a hashtable Description A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. A hashtable can be either local, in which case its lifespan is fixed to the lifespan of the note it was created in; or it can be global, in which case it is not deallocated when the note is released and is kept alive until either the end of the performance, or until freed via dict_free dict_new runs only at i-time Syntax idict dict_new Stype [, isglobal=0] idict dict_new Stype, isglobal, key0, value0, key1, value1, ... dict_new executes only at init time . NB : With the second variant it is possible to create a dict and give it initial values at init-time. Arguments Stype : a string describing the type of the key and the value. Possible values are: \"sf\" or \"str:float\": string \u2192 float \"ss\" or \"str:str\": string \u2192 string \"is\" or \"\u00ecnt:str\": int \u2192 string \"if\" or \"int:float\": int \u2192 float isglobal : if 1, the dict will outlive the instrument it was created in and will stay active until either the end of the performance or if destroyed via dict_free . Default is 0 (local) key0 , value0 , etc: initial pairs can be set at creation time, matching the types declared with Stype Output idict : identifies this dict with an integer. This integer can be passed around to another instrument and will always resolve to the same dict, as long as this dict is still alive. This can be checked via dict_query idict, \"exists\" Execution Time Init Examples < CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > See also dict_free dict_set Credits","title":"dict_new"},{"location":"opcodes/dict_new.html#dict_new","text":"","title":"dict_new"},{"location":"opcodes/dict_new.html#abstract","text":"Create a hashtable","title":"Abstract"},{"location":"opcodes/dict_new.html#description","text":"A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. A hashtable can be either local, in which case its lifespan is fixed to the lifespan of the note it was created in; or it can be global, in which case it is not deallocated when the note is released and is kept alive until either the end of the performance, or until freed via dict_free dict_new runs only at i-time","title":"Description"},{"location":"opcodes/dict_new.html#syntax","text":"idict dict_new Stype [, isglobal=0] idict dict_new Stype, isglobal, key0, value0, key1, value1, ... dict_new executes only at init time . NB : With the second variant it is possible to create a dict and give it initial values at init-time.","title":"Syntax"},{"location":"opcodes/dict_new.html#arguments","text":"Stype : a string describing the type of the key and the value. Possible values are: \"sf\" or \"str:float\": string \u2192 float \"ss\" or \"str:str\": string \u2192 string \"is\" or \"\u00ecnt:str\": int \u2192 string \"if\" or \"int:float\": int \u2192 float isglobal : if 1, the dict will outlive the instrument it was created in and will stay active until either the end of the performance or if destroyed via dict_free . Default is 0 (local) key0 , value0 , etc: initial pairs can be set at creation time, matching the types declared with Stype","title":"Arguments"},{"location":"opcodes/dict_new.html#output","text":"idict : identifies this dict with an integer. This integer can be passed around to another instrument and will always resolve to the same dict, as long as this dict is still alive. This can be checked via dict_query idict, \"exists\"","title":"Output"},{"location":"opcodes/dict_new.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/dict_new.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_new.html#see-also","text":"dict_free dict_set","title":"See also"},{"location":"opcodes/dict_new.html#credits","text":"","title":"Credits"},{"location":"opcodes/dict_print.html","text":"dict_print Abstract Prints the contents of a dict Description dict_print can be used to print the contents of a dict, mostly for debugging purposes dict_print can print both at i-time or k-time Syntax dict_print idict [, ktrig=1] Arguments \u00ecdict : the handle of the dict, as returned by dict_new ktrig : when to print the dict. Printing will take place whenever ktrig is -1 or if ktrig is a positive and higher than the last trig Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" , \"foo\" , 10 , \"bar\" , 20 , \"baz\" , 30 print_dict i dict , 1 ; print with a metro i dict2 dict_new \"ss\" , \"foo\" , \"foofoo\" , \"bar\" , \"barbar\" , \"baz\" , \"bazbaz\" k trig metro 2 print_dict i dict2 , k trig turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer > See also dict_iter dict_set dict_query Credits Eduardo Moguillansky, 2019","title":"dict_print"},{"location":"opcodes/dict_print.html#dict_print","text":"","title":"dict_print"},{"location":"opcodes/dict_print.html#abstract","text":"Prints the contents of a dict","title":"Abstract"},{"location":"opcodes/dict_print.html#description","text":"dict_print can be used to print the contents of a dict, mostly for debugging purposes dict_print can print both at i-time or k-time","title":"Description"},{"location":"opcodes/dict_print.html#syntax","text":"dict_print idict [, ktrig=1]","title":"Syntax"},{"location":"opcodes/dict_print.html#arguments","text":"\u00ecdict : the handle of the dict, as returned by dict_new ktrig : when to print the dict. Printing will take place whenever ktrig is -1 or if ktrig is a positive and higher than the last trig","title":"Arguments"},{"location":"opcodes/dict_print.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/dict_print.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" , \"foo\" , 10 , \"bar\" , 20 , \"baz\" , 30 print_dict i dict , 1 ; print with a metro i dict2 dict_new \"ss\" , \"foo\" , \"foofoo\" , \"bar\" , \"barbar\" , \"baz\" , \"bazbaz\" k trig metro 2 print_dict i dict2 , k trig turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_print.html#see-also","text":"dict_iter dict_set dict_query","title":"See also"},{"location":"opcodes/dict_print.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_query.html","text":"dict_query Abstract Query different properties of a dict Description Properties of a dict which do not need a separate opcode (because they are not used very frequently) are merged togehter in this opcode. Possible properties are: exists : return 1 if the handle points to a valid dict size : returns the size of this dict (similar to dict_size) type : returns an integer identifying the type of this dict 11 : number -> number 12 : number -> string 21 : string -> number 22 : string -> string keys : returns an array with all the keys defined in this dict (the type of the returned array depends on the type of the keys) values : returns an array with all the values (the type of the returned array depends on the type of the values). NB : the order in which keys and values are returned represents the corresponding pairs, so keys[i] and values[i] belong to the same pair. dict_query executes at k-time . Syntax kexists dict_query idict, \"exists\" ksize dict_query idict, \"size\" ktype dict_query idict, \"type\" SKeys[] dict_query idict, \"keys\" kKeys[] dict_query idict, \"keys\" kValues[] dict_query idict, \"values\" SValues[] dict_query idict, \"values\" Arguments idict : the handle of the dict, as returned by dict_new Output NB : the arrays returned from keys and values can have either an S- or a k-type, depending on the type definition of the array Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for dict_query ... dict_query idict, Scmd where Scmd can be: 'size', 'type', 'exists', 'keys', 'values' */ instr 1 ; get all the keys as an array i dict1 dict_new \"sf\" , 0 , \"keyA\" , 1 , \"keyB\" , 2 , \"keyC\" , 3 ; check that the dict exists k exists dict_query i dict1 , \"exists\" k type dict_query i dict1 , \"type\" printf \"dict exists = %d , type = %d \\n \" , 1 , k exists , k type S Keys [] dict_query i dict1 , \"keys\" printarray S Keys ; now check a bogus handle k exists999 dict_query 999 , \"exists\" printf \"dict 999 exists = %d \\n \" , 1 , k exists999 ; get the keys from a different dict i dict2 dict_new \"if\" , 0 , 1 , 100 , 10 , 1000 , 2 , 200 k Keys [] dict_query i dict2 , \"keys\" printarray k Keys , 1 , \" %.0f \" printf \"idict2 has size= %d \\n \" , 1 , dict_query ( i dict2 , \"size\" ) ; get values as an array i dict3 dict_new \"is\" , 0 , 10 , \"foo\" , 20 , \"bar\" , 30 , \"baz\" S vals [] dict_query i dict3 , \"values\" printarray S vals k Vals [] dict_query i dict2 , \"values\" printarray k Vals ; query the type of the dict k type dict_query i dict2 , \"type\" printf \"the type of dict %d is %d \\n \" , 1 , i dict2 , k type turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 </ CsScore > </ CsoundSynthesizer > See also dict_iter dict_size Credits Eduardo Moguillansky, 2019","title":"dict_query"},{"location":"opcodes/dict_query.html#dict_query","text":"","title":"dict_query"},{"location":"opcodes/dict_query.html#abstract","text":"Query different properties of a dict","title":"Abstract"},{"location":"opcodes/dict_query.html#description","text":"Properties of a dict which do not need a separate opcode (because they are not used very frequently) are merged togehter in this opcode. Possible properties are: exists : return 1 if the handle points to a valid dict size : returns the size of this dict (similar to dict_size) type : returns an integer identifying the type of this dict 11 : number -> number 12 : number -> string 21 : string -> number 22 : string -> string keys : returns an array with all the keys defined in this dict (the type of the returned array depends on the type of the keys) values : returns an array with all the values (the type of the returned array depends on the type of the values). NB : the order in which keys and values are returned represents the corresponding pairs, so keys[i] and values[i] belong to the same pair. dict_query executes at k-time .","title":"Description"},{"location":"opcodes/dict_query.html#syntax","text":"kexists dict_query idict, \"exists\" ksize dict_query idict, \"size\" ktype dict_query idict, \"type\" SKeys[] dict_query idict, \"keys\" kKeys[] dict_query idict, \"keys\" kValues[] dict_query idict, \"values\" SValues[] dict_query idict, \"values\"","title":"Syntax"},{"location":"opcodes/dict_query.html#arguments","text":"idict : the handle of the dict, as returned by dict_new","title":"Arguments"},{"location":"opcodes/dict_query.html#output","text":"NB : the arrays returned from keys and values can have either an S- or a k-type, depending on the type definition of the array","title":"Output"},{"location":"opcodes/dict_query.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/dict_query.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for dict_query ... dict_query idict, Scmd where Scmd can be: 'size', 'type', 'exists', 'keys', 'values' */ instr 1 ; get all the keys as an array i dict1 dict_new \"sf\" , 0 , \"keyA\" , 1 , \"keyB\" , 2 , \"keyC\" , 3 ; check that the dict exists k exists dict_query i dict1 , \"exists\" k type dict_query i dict1 , \"type\" printf \"dict exists = %d , type = %d \\n \" , 1 , k exists , k type S Keys [] dict_query i dict1 , \"keys\" printarray S Keys ; now check a bogus handle k exists999 dict_query 999 , \"exists\" printf \"dict 999 exists = %d \\n \" , 1 , k exists999 ; get the keys from a different dict i dict2 dict_new \"if\" , 0 , 1 , 100 , 10 , 1000 , 2 , 200 k Keys [] dict_query i dict2 , \"keys\" printarray k Keys , 1 , \" %.0f \" printf \"idict2 has size= %d \\n \" , 1 , dict_query ( i dict2 , \"size\" ) ; get values as an array i dict3 dict_new \"is\" , 0 , 10 , \"foo\" , 20 , \"bar\" , 30 , \"baz\" S vals [] dict_query i dict3 , \"values\" printarray S vals k Vals [] dict_query i dict2 , \"values\" printarray k Vals ; query the type of the dict k type dict_query i dict2 , \"type\" printf \"the type of dict %d is %d \\n \" , 1 , i dict2 , k type turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_query.html#see-also","text":"dict_iter dict_size","title":"See also"},{"location":"opcodes/dict_query.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_set.html","text":"dict_set Abstract Set (or remove) a value from a hashtable Description A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_set sets the value corresponding to a key if the key is already present, or inserts a key:value pair otherwise. NB : Without a value, dict_set deletes the key:value pair from the dict. dict_set executes can execute at i-time and k-time . Tip It is possible to set multiple values at i-time directly with dict_new Syntax dict_set idict, xkey, xvalue dict_set idict, xkey Arguments idict : the handle of the dict, as returned by dict_new xkey : the key to set. Its type must match the type definition of the dict. (a string or a possitive integer) xvalue : the value to set. Its type must match the type definition of the dict (a str or a numeric value) Note If xvalue is not given, dict_set removes the key from the dict Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > See also dict_new dict_get Credits Eduardo Moguillansky, 2019","title":"dict_set"},{"location":"opcodes/dict_set.html#dict_set","text":"","title":"dict_set"},{"location":"opcodes/dict_set.html#abstract","text":"Set (or remove) a value from a hashtable","title":"Abstract"},{"location":"opcodes/dict_set.html#description","text":"A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_set sets the value corresponding to a key if the key is already present, or inserts a key:value pair otherwise. NB : Without a value, dict_set deletes the key:value pair from the dict. dict_set executes can execute at i-time and k-time . Tip It is possible to set multiple values at i-time directly with dict_new","title":"Description"},{"location":"opcodes/dict_set.html#syntax","text":"dict_set idict, xkey, xvalue dict_set idict, xkey","title":"Syntax"},{"location":"opcodes/dict_set.html#arguments","text":"idict : the handle of the dict, as returned by dict_new xkey : the key to set. Its type must match the type definition of the dict. (a string or a possitive integer) xvalue : the value to set. Its type must match the type definition of the dict (a str or a numeric value) Note If xvalue is not given, dict_set removes the key from the dict","title":"Arguments"},{"location":"opcodes/dict_set.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/dict_set.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_set.html#see-also","text":"dict_new dict_get","title":"See also"},{"location":"opcodes/dict_set.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_size.html","text":"dict_size Abstract Returns the number of key:value pairs in a dict Description A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_size returns the number of such key:value pairs inside a dict. If the handle passed does not point to a valid dict, dict_size returns -1. It is thus possible to use it to check that the passed handle is valid (similar to dict_query idict \"exists\" , see dict_query ) dict_size can be used together with dict_iter to iterate over the key:value pairs Syntax isize dict_size idict ksize dict_size idict dict_size executes both at i-time and k-time . Arguments \u00ecdict : the handle of the dict, as returned by dict_new Output ksize : the number of key:value pairs in the dict Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size dict_set i dict , \"foo\" , 4 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size ; size does not change now dict_set i dict , \"foo\" , 10 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size ; we delete a key, size is reduced dict_set i dict , \"foo\" k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer > See also dict_iter dict_set Credits Eduardo Moguillansky, 2019","title":"dict_size"},{"location":"opcodes/dict_size.html#dict_size","text":"","title":"dict_size"},{"location":"opcodes/dict_size.html#abstract","text":"Returns the number of key:value pairs in a dict","title":"Abstract"},{"location":"opcodes/dict_size.html#description","text":"A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_size returns the number of such key:value pairs inside a dict. If the handle passed does not point to a valid dict, dict_size returns -1. It is thus possible to use it to check that the passed handle is valid (similar to dict_query idict \"exists\" , see dict_query ) dict_size can be used together with dict_iter to iterate over the key:value pairs","title":"Description"},{"location":"opcodes/dict_size.html#syntax","text":"isize dict_size idict ksize dict_size idict dict_size executes both at i-time and k-time .","title":"Syntax"},{"location":"opcodes/dict_size.html#arguments","text":"\u00ecdict : the handle of the dict, as returned by dict_new","title":"Arguments"},{"location":"opcodes/dict_size.html#output","text":"ksize : the number of key:value pairs in the dict","title":"Output"},{"location":"opcodes/dict_size.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/dict_size.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size dict_set i dict , \"foo\" , 4 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size ; size does not change now dict_set i dict , \"foo\" , 10 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size ; we delete a key, size is reduced dict_set i dict , \"foo\" k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_size.html#see-also","text":"dict_iter dict_set","title":"See also"},{"location":"opcodes/dict_size.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/diode_ringmod.html","text":"diode_ringmod Abstract A ring modulator with optional non-linearities Description diode_ringmod is a ring modulator with optional non-linearities. It implements a built-in sinusoidal carrier signal. The carrier is passed through a diode simulation prior to being multiplied with the input. This signal passes through a feedback stage. Sinewave : Diode Rect ( abs ( x )* 2 - 0.2 ) : _ * Input : Feedback knonlinearities controls the amount of jitter in the carrier's freq and feedback amount. diode_ringmod is a port of Loser's ringmodulator jsfx plugin distributed with REAPER Syntax aout diode_ringmod ain, kfreq, kdiode=0, kfeedback=0, knonlinear=0, koversample=0 Arguments ain : the input signal kfreq : the carrier's frequency (a sine wave) kdiode : if 1, the carrier is passed through a diode rectification stage kfeedback : the amount of feedback (between 0 and 1, 0=no feedback) knonlinear : the amount of non linearities (between 0 and 1, 0=no non linearities) koversample : if 1, oversampling x 2 is performed Output aout : audio output of the ring modulator Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac - d - m0 -+ rtmidi = virtual - M0 </ CsOptions > < CsInstruments > /* This is the example file for diode_ringmod NB: diode_ringmod is a port of the jsfx plugin Loser/ringmodulator, which implements diode rectification and non linear behavior in the feedback path. aout diode_ringmode a1, kmodfreq, kdiode=1, kfeedback=0, knonlin=0.2, koversample=0 kmodfreq: frequency of the mod. signal kdiode: if 1, a diode rectification stage is applied to the mod. signal kfeedback: range is 0 to 1. knonlin: range 0 to 1, implements non-linearities in feedback and mod. freq (for the first case only, which used the builtin oscillator) koversample: if 1, 2x oversampling is used. */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ga Outs [] init 2 FLpanel \"dioderingmod\" , 443 , 360 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i __w , i __h , i __line = 300 , 30 , 60 i y , i __marginx = 30 , 30 i _v1 FLvalue \"\" , 50 , 30 , 333 , i y gk ModFrequency , i _s1 FLslider \"Mod Frequency (Hz)\" , 20.0 , 3000.0 , 0 , 3 , \\ i _v1 , i __w , i __h , i __marginx , i y i y += i __line i _v2 FLvalue \"\" , 50 , 30 , 333 , i y gk Diode , i _s2 FLslider \"Diode\" , 0.0 , 1.0 , 0 , 3 , \\ i _v2 , i __w , i __h , i __marginx , i y i y += i __line i _v3 FLvalue \"\" , 50 , 30 , 333 , i y gk Feedback , i _s3 FLslider \"Feedback\" , 0.0 , 1.0 , 0 , 3 , \\ i _v3 , i __w , i __h , i __marginx , i y i y += i __line i _v4 FLvalue \"\" , 50 , 30 , 333 , i y gk Nonlinearities , i _s4 FLslider \"Non-Linearities\" , 0.0 , 1.0 , 0 , 3 , \\ i _v4 , i __w , i __h , i __marginx , i y i y += i __line i _v5 FLvalue \"\" , 50 , 30 , 333 , i y gk Oversample , i _s5 FLslider \"Oversample (x2)\" , 0.0 , 1.0 , 0 , 3 , \\ i _v5 , i __w , i __h , i __marginx , i y FLpanelEnd FLrun FLsetVal_i 440.0 , i _s1 ; Mod Frequency (Hz) FLsetVal_i 0.0 , i _s2 ; Diode FLsetVal_i 0.0 , i _s3 ; Feedback FLsetVal_i 0.1 , i _s4 ; Non-Linearities FLsetVal_i 0.0 , i _s5 ; Oversample (x2); --- end ui massign 1 , 1 instr 1 i midinote notnum i freq mtof i midinote i vel1 ampmidi 127 i db bpf i vel1 , 0 , - 120 , 64 , - 20 , 90 , - 12 , 127 , 0 i amp = ampdb ( i db ) * 0.2 a sig vco2 i amp , i freq ; asig oscili iamp, ifreq a env adsr 0.01 , 0.1 , 0.8 , 0.2 a sig *= a env ga Outs [ 0 ] = ga Outs [ 0 ] + a sig endin instr 100 a 1 = ga Outs [ 0 ] a 2 diode_ringmod a 1 , gk ModFrequency , gk Diode , gk Feedback , gk Nonlinearities , gk Oversample outs a 2 , a 2 ga Outs [ 0 ] = 0 endin </ CsInstruments > < CsScore > i 100 0 3600 </ CsScore > </ CsoundSynthesizer > < bsbPanel > < label > Widgets </ label > < objectName /> < x > 100 </ x > < y > 100 </ y > < w idth > 320 </ w idth > < height > 240 </ height > < visible > true </ visible > < uuid /> < bgcolor mode = \"nobackground\" > < r > 255 </ r > < g > 255 </ g > < b > 255 </ b > </ bgcolor > </ bsbPanel > < bsbPresets > </ bsbPresets > See also hilbert Reference https://en.wikipedia.org/wiki/Ring_modulation Credits Eduardo Moguillansky, 2019","title":"diode_ringmod"},{"location":"opcodes/diode_ringmod.html#diode_ringmod","text":"","title":"diode_ringmod"},{"location":"opcodes/diode_ringmod.html#abstract","text":"A ring modulator with optional non-linearities","title":"Abstract"},{"location":"opcodes/diode_ringmod.html#description","text":"diode_ringmod is a ring modulator with optional non-linearities. It implements a built-in sinusoidal carrier signal. The carrier is passed through a diode simulation prior to being multiplied with the input. This signal passes through a feedback stage. Sinewave : Diode Rect ( abs ( x )* 2 - 0.2 ) : _ * Input : Feedback knonlinearities controls the amount of jitter in the carrier's freq and feedback amount. diode_ringmod is a port of Loser's ringmodulator jsfx plugin distributed with REAPER","title":"Description"},{"location":"opcodes/diode_ringmod.html#syntax","text":"aout diode_ringmod ain, kfreq, kdiode=0, kfeedback=0, knonlinear=0, koversample=0","title":"Syntax"},{"location":"opcodes/diode_ringmod.html#arguments","text":"ain : the input signal kfreq : the carrier's frequency (a sine wave) kdiode : if 1, the carrier is passed through a diode rectification stage kfeedback : the amount of feedback (between 0 and 1, 0=no feedback) knonlinear : the amount of non linearities (between 0 and 1, 0=no non linearities) koversample : if 1, oversampling x 2 is performed","title":"Arguments"},{"location":"opcodes/diode_ringmod.html#output","text":"aout : audio output of the ring modulator","title":"Output"},{"location":"opcodes/diode_ringmod.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/diode_ringmod.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac - d - m0 -+ rtmidi = virtual - M0 </ CsOptions > < CsInstruments > /* This is the example file for diode_ringmod NB: diode_ringmod is a port of the jsfx plugin Loser/ringmodulator, which implements diode rectification and non linear behavior in the feedback path. aout diode_ringmode a1, kmodfreq, kdiode=1, kfeedback=0, knonlin=0.2, koversample=0 kmodfreq: frequency of the mod. signal kdiode: if 1, a diode rectification stage is applied to the mod. signal kfeedback: range is 0 to 1. knonlin: range 0 to 1, implements non-linearities in feedback and mod. freq (for the first case only, which used the builtin oscillator) koversample: if 1, 2x oversampling is used. */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ga Outs [] init 2 FLpanel \"dioderingmod\" , 443 , 360 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i __w , i __h , i __line = 300 , 30 , 60 i y , i __marginx = 30 , 30 i _v1 FLvalue \"\" , 50 , 30 , 333 , i y gk ModFrequency , i _s1 FLslider \"Mod Frequency (Hz)\" , 20.0 , 3000.0 , 0 , 3 , \\ i _v1 , i __w , i __h , i __marginx , i y i y += i __line i _v2 FLvalue \"\" , 50 , 30 , 333 , i y gk Diode , i _s2 FLslider \"Diode\" , 0.0 , 1.0 , 0 , 3 , \\ i _v2 , i __w , i __h , i __marginx , i y i y += i __line i _v3 FLvalue \"\" , 50 , 30 , 333 , i y gk Feedback , i _s3 FLslider \"Feedback\" , 0.0 , 1.0 , 0 , 3 , \\ i _v3 , i __w , i __h , i __marginx , i y i y += i __line i _v4 FLvalue \"\" , 50 , 30 , 333 , i y gk Nonlinearities , i _s4 FLslider \"Non-Linearities\" , 0.0 , 1.0 , 0 , 3 , \\ i _v4 , i __w , i __h , i __marginx , i y i y += i __line i _v5 FLvalue \"\" , 50 , 30 , 333 , i y gk Oversample , i _s5 FLslider \"Oversample (x2)\" , 0.0 , 1.0 , 0 , 3 , \\ i _v5 , i __w , i __h , i __marginx , i y FLpanelEnd FLrun FLsetVal_i 440.0 , i _s1 ; Mod Frequency (Hz) FLsetVal_i 0.0 , i _s2 ; Diode FLsetVal_i 0.0 , i _s3 ; Feedback FLsetVal_i 0.1 , i _s4 ; Non-Linearities FLsetVal_i 0.0 , i _s5 ; Oversample (x2); --- end ui massign 1 , 1 instr 1 i midinote notnum i freq mtof i midinote i vel1 ampmidi 127 i db bpf i vel1 , 0 , - 120 , 64 , - 20 , 90 , - 12 , 127 , 0 i amp = ampdb ( i db ) * 0.2 a sig vco2 i amp , i freq ; asig oscili iamp, ifreq a env adsr 0.01 , 0.1 , 0.8 , 0.2 a sig *= a env ga Outs [ 0 ] = ga Outs [ 0 ] + a sig endin instr 100 a 1 = ga Outs [ 0 ] a 2 diode_ringmod a 1 , gk ModFrequency , gk Diode , gk Feedback , gk Nonlinearities , gk Oversample outs a 2 , a 2 ga Outs [ 0 ] = 0 endin </ CsInstruments > < CsScore > i 100 0 3600 </ CsScore > </ CsoundSynthesizer > < bsbPanel > < label > Widgets </ label > < objectName /> < x > 100 </ x > < y > 100 </ y > < w idth > 320 </ w idth > < height > 240 </ height > < visible > true </ visible > < uuid /> < bgcolor mode = \"nobackground\" > < r > 255 </ r > < g > 255 </ g > < b > 255 </ b > </ bgcolor > </ bsbPanel > < bsbPresets > </ bsbPresets >","title":"Examples"},{"location":"opcodes/diode_ringmod.html#see-also","text":"hilbert","title":"See also"},{"location":"opcodes/diode_ringmod.html#reference","text":"https://en.wikipedia.org/wiki/Ring_modulation","title":"Reference"},{"location":"opcodes/diode_ringmod.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/file_exists.html","text":"file_exists Abstract Returns 1 if a file exists and can be read Description file_exists checks if a given file path exists and returns 1 if it does, 0 otherwise. It doesn't check any search path of csound and does not expand any variables (like \"~\" in unix). Syntax iexists file_exists Spath Arguments Spath : the path to check Output iexists : 1 if the file exists, 0 otherwise Execution Time Init Examples < CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > /* Example file for file_exists file_exists returns 1 if a given path refers to an existing file */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 i exists f ile_exists \"file_exists.csd\" print i exists turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer > See also filevalid system Credits Eduardo Moguillansky, 2019","title":"file_exists"},{"location":"opcodes/file_exists.html#file_exists","text":"","title":"file_exists"},{"location":"opcodes/file_exists.html#abstract","text":"Returns 1 if a file exists and can be read","title":"Abstract"},{"location":"opcodes/file_exists.html#description","text":"file_exists checks if a given file path exists and returns 1 if it does, 0 otherwise. It doesn't check any search path of csound and does not expand any variables (like \"~\" in unix).","title":"Description"},{"location":"opcodes/file_exists.html#syntax","text":"iexists file_exists Spath","title":"Syntax"},{"location":"opcodes/file_exists.html#arguments","text":"Spath : the path to check","title":"Arguments"},{"location":"opcodes/file_exists.html#output","text":"iexists : 1 if the file exists, 0 otherwise","title":"Output"},{"location":"opcodes/file_exists.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/file_exists.html#examples","text":"< CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > /* Example file for file_exists file_exists returns 1 if a given path refers to an existing file */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 i exists f ile_exists \"file_exists.csd\" print i exists turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/file_exists.html#see-also","text":"filevalid system","title":"See also"},{"location":"opcodes/file_exists.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/jsfx.html","text":"jsfx Abstract Instantiates and runs a jsfx script Description jsfx allows to instantiate and run a jsfx audio plugin within csound. There are two ways to run a jsfx script in csound. The simplest way is implemented in this plugin, jsfx , which allows to compile and control a jsfx plugin in one opcode. As an alternative, it is also possible to decouple these actions, first compiling a script (see jsfx_new ) and then calling jsfx_setslider and jsfx_play . Afterwords, slider values can be read via jsfx_getslider Note jsfx is an audio programming language implemented pritarily as part of the DAW REAPER . It is a scriptiong language with a built-in jit compiler which translates it to machine code on the fly. It allows the user to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. Note A jsfx script has a certain number of audio input / output channels, and a series of \"sliders\", which are parameters operating at control rate. A script can also use these sliders to send control values, which can be read in csound via jsfx_getslider See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc. Syntax ihandle, aout1 [, aout2, ...] jsfx Spath, ain1 [, ain2, ...] [, id0, kval1, id1, kval2, ...] Arguments Spath : the path to the jsfx script. Either an absolute path, a relative path to the .csd file, or a filename alone, in which case it will be searched first in the current dir and in $SSDIR, if defined. ain1 , ain2 , etc: audio input channels. It is recommended that the number of input streams matches the number of channels expected in the plugin. If you pass less that the expected channels, the rest will be zeroed, and if passing more, only the number of audio channels expected by the plugin will actually be processed idx , kvalx : a jsfx script allows to define up to 64 control parameters, which are called slider s. Each slider has an idx (starting from 1) and a value. Here you can control as many sliders as you need. Each slider consists of a pair of values, an id (i- value) identifying the slider (this corresponds to the sliderx value in the jsfx script) and the value itself (a k- value) Output ihandle : a handle to the jsfx plugin created, which allows to operate on it later, for instance to read slider values via jsfx_getslider aout1 , aout2 : audio output channels. It is recommended that the number of output streams matches the number of channels expected in the plugin. If you pass less that the expected channels, the rest will be zeroed, and if passing more, only the number of audio channels expected by the plugin will actually be processed Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for jsfx opcode gi snd ftgen 0 , 0 , 0 , - 1 , \"bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i h , a 1 jsfx \"tubeharmonics.jsfx\" , a sig , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out if gk dump == 1 then jsfx_dump i h , metro ( 4 ) endif outs a 1 , a 1 endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer > See also jsfx_new jsfx_play jsfx_setslider jsfx_getslider Credits Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"jsfx"},{"location":"opcodes/jsfx.html#jsfx","text":"","title":"jsfx"},{"location":"opcodes/jsfx.html#abstract","text":"Instantiates and runs a jsfx script","title":"Abstract"},{"location":"opcodes/jsfx.html#description","text":"jsfx allows to instantiate and run a jsfx audio plugin within csound. There are two ways to run a jsfx script in csound. The simplest way is implemented in this plugin, jsfx , which allows to compile and control a jsfx plugin in one opcode. As an alternative, it is also possible to decouple these actions, first compiling a script (see jsfx_new ) and then calling jsfx_setslider and jsfx_play . Afterwords, slider values can be read via jsfx_getslider Note jsfx is an audio programming language implemented pritarily as part of the DAW REAPER . It is a scriptiong language with a built-in jit compiler which translates it to machine code on the fly. It allows the user to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. Note A jsfx script has a certain number of audio input / output channels, and a series of \"sliders\", which are parameters operating at control rate. A script can also use these sliders to send control values, which can be read in csound via jsfx_getslider See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc.","title":"Description"},{"location":"opcodes/jsfx.html#syntax","text":"ihandle, aout1 [, aout2, ...] jsfx Spath, ain1 [, ain2, ...] [, id0, kval1, id1, kval2, ...]","title":"Syntax"},{"location":"opcodes/jsfx.html#arguments","text":"Spath : the path to the jsfx script. Either an absolute path, a relative path to the .csd file, or a filename alone, in which case it will be searched first in the current dir and in $SSDIR, if defined. ain1 , ain2 , etc: audio input channels. It is recommended that the number of input streams matches the number of channels expected in the plugin. If you pass less that the expected channels, the rest will be zeroed, and if passing more, only the number of audio channels expected by the plugin will actually be processed idx , kvalx : a jsfx script allows to define up to 64 control parameters, which are called slider s. Each slider has an idx (starting from 1) and a value. Here you can control as many sliders as you need. Each slider consists of a pair of values, an id (i- value) identifying the slider (this corresponds to the sliderx value in the jsfx script) and the value itself (a k- value)","title":"Arguments"},{"location":"opcodes/jsfx.html#output","text":"ihandle : a handle to the jsfx plugin created, which allows to operate on it later, for instance to read slider values via jsfx_getslider aout1 , aout2 : audio output channels. It is recommended that the number of output streams matches the number of channels expected in the plugin. If you pass less that the expected channels, the rest will be zeroed, and if passing more, only the number of audio channels expected by the plugin will actually be processed","title":"Output"},{"location":"opcodes/jsfx.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/jsfx.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for jsfx opcode gi snd ftgen 0 , 0 , 0 , - 1 , \"bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i h , a 1 jsfx \"tubeharmonics.jsfx\" , a sig , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out if gk dump == 1 then jsfx_dump i h , metro ( 4 ) endif outs a 1 , a 1 endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/jsfx.html#see-also","text":"jsfx_new jsfx_play jsfx_setslider jsfx_getslider","title":"See also"},{"location":"opcodes/jsfx.html#credits","text":"Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"Credits"},{"location":"opcodes/jsfx_getslider.html","text":"jsfx_setslider Abstract Gets a slider value of a jsfx instance Description With jsfx_getslider it is possible to get the current values of any slider defined in a jsfx script, mostly after calling jsfx or jsfx_play . A jsfx plugin defines a series of up to 64 sliders, which are control parameters used by the script. A slider can also be used to output values to the caller, for example to indicate the gain reduction in a compressor plugin, or the frequency in a pitch tracking plugin. A slider definition in a jsfx script has the form: slider7 : 0 < 0 , 20 , 0.01 > Gain Reduction This defines a control parameter with default value 0 , between 0 and 20 , with a precission (an increment) of 0.01 and a label \"Gain Reduction\". To read the value of that slider: kgainreduction = jsfx_getslider(ihandle, 7) Note Any slider which is not set via jsfx_setslider retains its default value. A value will always be confined to the range in the slider definition and will also be quantized to the increment in the slider definition. To disable any quantization, set the increment to 0 in the jsfx script Note jsfx is an audio programming language implemented primarily as part of the DAW REAPER . It is a scripting language with a built-in compiler which translates it to machine code. It allows to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc. Syntax kvalue jsfx_getslider ihandle, kid Arguments ihandle : the handle created via jsfx_new or jsfx kidx : the slider number (this corresponds to the sliderx value in the jsfx script) Output kvalue : value of the slider Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for the opcodes jsfx_new, jsfx_play and jsfx_setslider gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i handle jsfx_new \"tubeharmonics.jsfx\" print i handle jsfx_setslider i handle , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out a out jsfx_play i handle , a sig if gk dump == 1 then jsfx_dump i handle , metro ( 4 ) endif k 7 jsfx_getslider i handle , 7 printf \"k7: %f \\r \" , changed2 ( k 7 ), k 7 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer > See also jsfx jsfx_new jsfx_play jsfx_setslider Credits Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"jsfx_setslider"},{"location":"opcodes/jsfx_getslider.html#jsfx_setslider","text":"","title":"jsfx_setslider"},{"location":"opcodes/jsfx_getslider.html#abstract","text":"Gets a slider value of a jsfx instance","title":"Abstract"},{"location":"opcodes/jsfx_getslider.html#description","text":"With jsfx_getslider it is possible to get the current values of any slider defined in a jsfx script, mostly after calling jsfx or jsfx_play . A jsfx plugin defines a series of up to 64 sliders, which are control parameters used by the script. A slider can also be used to output values to the caller, for example to indicate the gain reduction in a compressor plugin, or the frequency in a pitch tracking plugin. A slider definition in a jsfx script has the form: slider7 : 0 < 0 , 20 , 0.01 > Gain Reduction This defines a control parameter with default value 0 , between 0 and 20 , with a precission (an increment) of 0.01 and a label \"Gain Reduction\". To read the value of that slider: kgainreduction = jsfx_getslider(ihandle, 7) Note Any slider which is not set via jsfx_setslider retains its default value. A value will always be confined to the range in the slider definition and will also be quantized to the increment in the slider definition. To disable any quantization, set the increment to 0 in the jsfx script Note jsfx is an audio programming language implemented primarily as part of the DAW REAPER . It is a scripting language with a built-in compiler which translates it to machine code. It allows to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc.","title":"Description"},{"location":"opcodes/jsfx_getslider.html#syntax","text":"kvalue jsfx_getslider ihandle, kid","title":"Syntax"},{"location":"opcodes/jsfx_getslider.html#arguments","text":"ihandle : the handle created via jsfx_new or jsfx kidx : the slider number (this corresponds to the sliderx value in the jsfx script)","title":"Arguments"},{"location":"opcodes/jsfx_getslider.html#output","text":"kvalue : value of the slider","title":"Output"},{"location":"opcodes/jsfx_getslider.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/jsfx_getslider.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for the opcodes jsfx_new, jsfx_play and jsfx_setslider gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i handle jsfx_new \"tubeharmonics.jsfx\" print i handle jsfx_setslider i handle , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out a out jsfx_play i handle , a sig if gk dump == 1 then jsfx_dump i handle , metro ( 4 ) endif k 7 jsfx_getslider i handle , 7 printf \"k7: %f \\r \" , changed2 ( k 7 ), k 7 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/jsfx_getslider.html#see-also","text":"jsfx jsfx_new jsfx_play jsfx_setslider","title":"See also"},{"location":"opcodes/jsfx_getslider.html#credits","text":"Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"Credits"},{"location":"opcodes/jsfx_new.html","text":"jsfx_new Abstract Instantiates a jsfx script Description jsfx_new instantiates and compiles a jsfx script (at init time). It returns a handle which can be used to modify control values and perform audio io. It is also possible to instantiate and play a script with only one opcode via jsfx . Note jsfx is an audio programming language implemented pritarily as part of the DAW REAPER . It is a scriptiong language with a built-in jit compiler which translates it to machine code on the fly. It allows the user to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. !!! Note jsfx input / output A jsfx script has a certain number of audio input / output channels, and a series of \"sliders\", which are parameters operating at control rate. A script can also use these sliders to send control values, which can be read in csound via [jsfx_getslider] See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc. Syntax ihandle jsfx_new Spath Arguments Spath : the path to the jsfx script. Either an absolute path, a relative path to the .csd file, or a filename alone, in which case it will be searched first in the current dir and in $SSDIR, if defined. Output ihandle : a handle to the jsfx plugin created, which allows to operate on it later, for instance to perform audio io via jsfx_play Execution Time Init Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for the opcodes jsfx_new, jsfx_play and jsfx_setslider gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i handle jsfx_new \"tubeharmonics.jsfx\" print i handle jsfx_setslider i handle , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out a out jsfx_play i handle , a sig if gk dump == 1 then jsfx_dump i handle , metro ( 4 ) endif k 7 jsfx_getslider i handle , 7 printf \"k7: %f \\r \" , changed2 ( k 7 ), k 7 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer > See also jsfx jsfx_play jsfx_setslider jsfx_getslider Credits Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"jsfx_new"},{"location":"opcodes/jsfx_new.html#jsfx_new","text":"","title":"jsfx_new"},{"location":"opcodes/jsfx_new.html#abstract","text":"Instantiates a jsfx script","title":"Abstract"},{"location":"opcodes/jsfx_new.html#description","text":"jsfx_new instantiates and compiles a jsfx script (at init time). It returns a handle which can be used to modify control values and perform audio io. It is also possible to instantiate and play a script with only one opcode via jsfx . Note jsfx is an audio programming language implemented pritarily as part of the DAW REAPER . It is a scriptiong language with a built-in jit compiler which translates it to machine code on the fly. It allows the user to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. !!! Note jsfx input / output A jsfx script has a certain number of audio input / output channels, and a series of \"sliders\", which are parameters operating at control rate. A script can also use these sliders to send control values, which can be read in csound via [jsfx_getslider] See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc.","title":"Description"},{"location":"opcodes/jsfx_new.html#syntax","text":"ihandle jsfx_new Spath","title":"Syntax"},{"location":"opcodes/jsfx_new.html#arguments","text":"Spath : the path to the jsfx script. Either an absolute path, a relative path to the .csd file, or a filename alone, in which case it will be searched first in the current dir and in $SSDIR, if defined.","title":"Arguments"},{"location":"opcodes/jsfx_new.html#output","text":"ihandle : a handle to the jsfx plugin created, which allows to operate on it later, for instance to perform audio io via jsfx_play","title":"Output"},{"location":"opcodes/jsfx_new.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/jsfx_new.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for the opcodes jsfx_new, jsfx_play and jsfx_setslider gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i handle jsfx_new \"tubeharmonics.jsfx\" print i handle jsfx_setslider i handle , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out a out jsfx_play i handle , a sig if gk dump == 1 then jsfx_dump i handle , metro ( 4 ) endif k 7 jsfx_getslider i handle , 7 printf \"k7: %f \\r \" , changed2 ( k 7 ), k 7 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/jsfx_new.html#see-also","text":"jsfx jsfx_play jsfx_setslider jsfx_getslider","title":"See also"},{"location":"opcodes/jsfx_new.html#credits","text":"Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"Credits"},{"location":"opcodes/jsfx_play.html","text":"jsfx_play Abstract Processes audio through a jsfx script Description jsfx_play calls the actual sample processing code defined in a jsfx script. The script must have been initialized via jsfx_new , which instantiates and compiles the script and returns a handle. Note jsfx is an audio programming language implemented primarily as part of the DAW REAPER . It is a scriptiong language with a built-in compiler which translates it to machine code on the fly. It allows the user to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. !!! Note jsfx input / output A jsfx script has a certain number of audio input / output channels. The number of audio inputs / outputs passed to the script does not need to match the number of channels defined in the script but it is advised to do so. More precisely, if a plugin is stereo, passing only one channel will not reduce the work performed by the plugin. A plugin also defines a series of \"sliders\", which are parameters operating at control rate. A script can also use these sliders to send control values back, which can be read in csound via [jsfx_getslider] See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc. Syntax a1 [, a2, a3, ...] jsfx_play ihandle, ain1 [, ain2, ain3, ...] Arguments ain1 , ain2 , ...: the audio signals passed as input. The amount of channels processed is min(expected number of streams, given number of streams) Output a1 , a2 , ...: the output audio generated by the plugin Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for the opcodes jsfx_new, jsfx_play and jsfx_setslider gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i handle jsfx_new \"tubeharmonics.jsfx\" print i handle jsfx_setslider i handle , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out a out jsfx_play i handle , a sig if gk dump == 1 then jsfx_dump i handle , metro ( 4 ) endif k 7 jsfx_getslider i handle , 7 printf \"k7: %f \\r \" , changed2 ( k 7 ), k 7 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer > See also jsfx_new jsfx_setslider jsfx_getslider Credits Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"jsfx_play"},{"location":"opcodes/jsfx_play.html#jsfx_play","text":"","title":"jsfx_play"},{"location":"opcodes/jsfx_play.html#abstract","text":"Processes audio through a jsfx script","title":"Abstract"},{"location":"opcodes/jsfx_play.html#description","text":"jsfx_play calls the actual sample processing code defined in a jsfx script. The script must have been initialized via jsfx_new , which instantiates and compiles the script and returns a handle. Note jsfx is an audio programming language implemented primarily as part of the DAW REAPER . It is a scriptiong language with a built-in compiler which translates it to machine code on the fly. It allows the user to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. !!! Note jsfx input / output A jsfx script has a certain number of audio input / output channels. The number of audio inputs / outputs passed to the script does not need to match the number of channels defined in the script but it is advised to do so. More precisely, if a plugin is stereo, passing only one channel will not reduce the work performed by the plugin. A plugin also defines a series of \"sliders\", which are parameters operating at control rate. A script can also use these sliders to send control values back, which can be read in csound via [jsfx_getslider] See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc.","title":"Description"},{"location":"opcodes/jsfx_play.html#syntax","text":"a1 [, a2, a3, ...] jsfx_play ihandle, ain1 [, ain2, ain3, ...]","title":"Syntax"},{"location":"opcodes/jsfx_play.html#arguments","text":"ain1 , ain2 , ...: the audio signals passed as input. The amount of channels processed is min(expected number of streams, given number of streams)","title":"Arguments"},{"location":"opcodes/jsfx_play.html#output","text":"a1 , a2 , ...: the output audio generated by the plugin","title":"Output"},{"location":"opcodes/jsfx_play.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/jsfx_play.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for the opcodes jsfx_new, jsfx_play and jsfx_setslider gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i handle jsfx_new \"tubeharmonics.jsfx\" print i handle jsfx_setslider i handle , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out a out jsfx_play i handle , a sig if gk dump == 1 then jsfx_dump i handle , metro ( 4 ) endif k 7 jsfx_getslider i handle , 7 printf \"k7: %f \\r \" , changed2 ( k 7 ), k 7 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/jsfx_play.html#see-also","text":"jsfx_new jsfx_setslider jsfx_getslider","title":"See also"},{"location":"opcodes/jsfx_play.html#credits","text":"Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"Credits"},{"location":"opcodes/jsfx_setslider.html","text":"jsfx_setslider Abstract Sets the slider values of a jsfx script Description With jsfx_setslider it is possible to set the values of any number of sliders defined in a jsfx script, mostly prior to calling jsfx_play . A jsfx plugin defines a series of up to 64 sliders, which are control parameters used by the script. A slider definition in a jsfx script has the form: slider3 : 1.5 < 0 , 4 , 0.01 > Compression Ratio This defines a control parameter with default value 1.5 , between 0 and 4 , with a precission (an increment) of 0.01 and a label \"Copression Ratio\". kcomprat = 2.5 jsfx_setslider ihandle, 3, kcomprat The code above will set the slider #3 (the index passed corresponds with the slider number) to the value of kcomprat The value of any slider can be read via jsfx_getvalue (only one value at a time). Note It is possible to call jsfx_setslider with any number of sliders. It is not necessary to set all the sliders defined in the script. Any slider which is not set via jsfx_setslider retains its default value. A value will always be confined to the range in the slider definition and will also be quantized to the increment in the slider definition. To disable any quantization, set the increment to 0 in the jsfx script Note jsfx is an audio programming language implemented primarily as part of the DAW REAPER . It is a scriptiong language with a built-in compiler which translates it to machine code. It allows the user to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc. Syntax jsfx_setslider ihandle, id1, kval1 [, id2, kval2, id3, kval3, ...] Arguments ihandle : the handle created via jsfx_new or jsfx idx , kvalx : a jsfx script allows to define up to 64 control parameters, which are called slider s. Each slider has an idx (starting from 1) and a value. Here you can control as many sliders as you need. Each slider consists of a pair of values, an id identifying the slider (this corresponds to the sliderx value in the jsfx script) and the value itself (a k- value) Output Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for the opcodes jsfx_new, jsfx_play and jsfx_setslider gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i handle jsfx_new \"tubeharmonics.jsfx\" print i handle jsfx_setslider i handle , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out a out jsfx_play i handle , a sig if gk dump == 1 then jsfx_dump i handle , metro ( 4 ) endif k 7 jsfx_getslider i handle , 7 printf \"k7: %f \\r \" , changed2 ( k 7 ), k 7 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer > See also jsfx jsfx_new jsfx_play jsfx_getslider Credits Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"jsfx_setslider"},{"location":"opcodes/jsfx_setslider.html#jsfx_setslider","text":"","title":"jsfx_setslider"},{"location":"opcodes/jsfx_setslider.html#abstract","text":"Sets the slider values of a jsfx script","title":"Abstract"},{"location":"opcodes/jsfx_setslider.html#description","text":"With jsfx_setslider it is possible to set the values of any number of sliders defined in a jsfx script, mostly prior to calling jsfx_play . A jsfx plugin defines a series of up to 64 sliders, which are control parameters used by the script. A slider definition in a jsfx script has the form: slider3 : 1.5 < 0 , 4 , 0.01 > Compression Ratio This defines a control parameter with default value 1.5 , between 0 and 4 , with a precission (an increment) of 0.01 and a label \"Copression Ratio\". kcomprat = 2.5 jsfx_setslider ihandle, 3, kcomprat The code above will set the slider #3 (the index passed corresponds with the slider number) to the value of kcomprat The value of any slider can be read via jsfx_getvalue (only one value at a time). Note It is possible to call jsfx_setslider with any number of sliders. It is not necessary to set all the sliders defined in the script. Any slider which is not set via jsfx_setslider retains its default value. A value will always be confined to the range in the slider definition and will also be quantized to the increment in the slider definition. To disable any quantization, set the increment to 0 in the jsfx script Note jsfx is an audio programming language implemented primarily as part of the DAW REAPER . It is a scriptiong language with a built-in compiler which translates it to machine code. It allows the user to operate at the sample level (like defining an udo with setksmps 1 but more efficient). It is around 2x to 2.5x slower than hand-coded C. See https://www.reaper.fm/sdk/js/js.php for more information about the syntax, etc.","title":"Description"},{"location":"opcodes/jsfx_setslider.html#syntax","text":"jsfx_setslider ihandle, id1, kval1 [, id2, kval2, id3, kval3, ...]","title":"Syntax"},{"location":"opcodes/jsfx_setslider.html#arguments","text":"ihandle : the handle created via jsfx_new or jsfx idx , kvalx : a jsfx script allows to define up to 64 control parameters, which are called slider s. Each slider has an idx (starting from 1) and a value. Here you can control as many sliders as you need. Each slider consists of a pair of values, an id identifying the slider (this corresponds to the sliderx value in the jsfx script) and the value itself (a k- value)","title":"Arguments"},{"location":"opcodes/jsfx_setslider.html#output","text":"","title":"Output"},{"location":"opcodes/jsfx_setslider.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/jsfx_setslider.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for the opcodes jsfx_new, jsfx_play and jsfx_setslider gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx - tubeharmonics\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i handle jsfx_new \"tubeharmonics.jsfx\" print i handle jsfx_setslider i handle , 1 , gk even , 2 , gk odd , 3 , gk flct , 4 , gk inpt , 5 , gk out a out jsfx_play i handle , a sig if gk dump == 1 then jsfx_dump i handle , metro ( 4 ) endif k 7 jsfx_getslider i handle , 7 printf \"k7: %f \\r \" , changed2 ( k 7 ), k 7 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/jsfx_setslider.html#see-also","text":"jsfx jsfx_new jsfx_play jsfx_getslider","title":"See also"},{"location":"opcodes/jsfx_setslider.html#credits","text":"Eduardo Moguillansky, 2019 Uses the open-source implementation of the jsfx language by Pascal Gauthier et al. Based heavily on the pd external jsfx~ . https://github.com/asb2m10/jsusfx","title":"Credits"},{"location":"opcodes/lfnoise.html","text":"lfnoise Abstract low frequency, band-limited noise Description Generates random values at a rate given by the nearest integer division of the sample rate by the freq argument. If kinterp==0, between generated values 0 is output. Otherwise the output is the result of interpolating between the generated values. Output is always band limited. Syntax aout lfnoise krate, kinterp=0 Arguments krate : the frequency to generate new values kinterp : if 1, the output is the result of linear interpolation between the generated values Output aout : if kinterp==0, then this is the output random values at the given frequency, or 0. If kinterp==1, then output is the result of interpolation between two generated values. Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* Example file for lfnoise lfnoise generates a random value between 0-1 at the given frequency. If kinterp=1, then values are interpolated; otherwise, they are held until next value */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 FLpanel \"lfnoise\" , 400 , 200 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 322 , 20 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk freq , i h1 FLslider \"freq\" , 0 , 200 , 0 , 3 , i disp1 , 300 , 30 , 20 , 20 gk interp , i h2 FLbutton \"interpolate\" , 1 , 0 , 3 , 100 , 50 , 20 , 80 , - 1 gk gain , i h3 FLslider \"gain\" , 0 , 1 , 0 , 3 , - 1 , 300 , 30 , 20 , 140 FLpanelEnd FLrun FLsetVal_i 8 , i h1 FLsetVal_i 0.1 , i h3 instr 1 a out lfnoise gk freq , gk interp a out *= interp ( gk gain ) outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer > See also dust2 crackle Credits Eduardo Moguillansky, 2019 (port of pd/else's lfnoise , which is itself a merge of supercollider's LFNoise0 and LFNoise1 )","title":"lfnoise"},{"location":"opcodes/lfnoise.html#lfnoise","text":"","title":"lfnoise"},{"location":"opcodes/lfnoise.html#abstract","text":"low frequency, band-limited noise","title":"Abstract"},{"location":"opcodes/lfnoise.html#description","text":"Generates random values at a rate given by the nearest integer division of the sample rate by the freq argument. If kinterp==0, between generated values 0 is output. Otherwise the output is the result of interpolating between the generated values. Output is always band limited.","title":"Description"},{"location":"opcodes/lfnoise.html#syntax","text":"aout lfnoise krate, kinterp=0","title":"Syntax"},{"location":"opcodes/lfnoise.html#arguments","text":"krate : the frequency to generate new values kinterp : if 1, the output is the result of linear interpolation between the generated values","title":"Arguments"},{"location":"opcodes/lfnoise.html#output","text":"aout : if kinterp==0, then this is the output random values at the given frequency, or 0. If kinterp==1, then output is the result of interpolation between two generated values.","title":"Output"},{"location":"opcodes/lfnoise.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/lfnoise.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* Example file for lfnoise lfnoise generates a random value between 0-1 at the given frequency. If kinterp=1, then values are interpolated; otherwise, they are held until next value */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 FLpanel \"lfnoise\" , 400 , 200 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 322 , 20 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk freq , i h1 FLslider \"freq\" , 0 , 200 , 0 , 3 , i disp1 , 300 , 30 , 20 , 20 gk interp , i h2 FLbutton \"interpolate\" , 1 , 0 , 3 , 100 , 50 , 20 , 80 , - 1 gk gain , i h3 FLslider \"gain\" , 0 , 1 , 0 , 3 , - 1 , 300 , 30 , 20 , 140 FLpanelEnd FLrun FLsetVal_i 8 , i h1 FLsetVal_i 0.1 , i h3 instr 1 a out lfnoise gk freq , gk interp a out *= interp ( gk gain ) outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/lfnoise.html#see-also","text":"dust2 crackle","title":"See also"},{"location":"opcodes/lfnoise.html#credits","text":"Eduardo Moguillansky, 2019 (port of pd/else's lfnoise , which is itself a merge of supercollider's LFNoise0 and LFNoise1 )","title":"Credits"},{"location":"opcodes/linenv.html","text":"linenv Abstract A triggerable linear envelope with sustain segment Description linenv is similar to linsegr with an additional gate argument, allowing to retrigger it at will. One of the values can be defined as a sustain point, meaning that as long as the gate is held, the envelope enters a sustain state when reaching this point. When the gate is set to 0, the envelope traverses the rest of the defined points. Syntax xout linenv kgate, isustindex, kval0, [ktime1, kval1, ktime2, kval2, ...] Arguments kgate : whenever this switches from 0 to 1 a new envelope starts isustindex : the index of the sustain point. For example, if isustindex is 2, then when the envelope reaches kval2 (after ktime0+ktime1), it enters a sustain phase, where its value remains unmodified until the gate is set to 0. If no sustain point is desired, set isustindex to -1 kval0 , ktime1 , ...: a linear envelope, similar to linsegr . The release part can have as many segments as desired. ktimex values are defined as time interval between two values, not as absolute timestamps Output xout : value of the envelope (k- or a- rate) Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* This is the example file for opcode \"linenv\" linenv is a triggerable envelope with a sustain segment aout linenv kgate, isustidx, kval0, ktime1, kval1, ..., ktimen, kvaln NB: use isustidx=-1 if no sustain is desired NB: use xtratim if necessary to allow for release segment */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gk gate init 0 FLpanel \"linenv\" , 240 , 100 , 100 , 100 gk gate , gi h1 FLbutton \" Gate\" , 1 , 0 , 2 , 80 , 40 , 10 , 10 , - 1 FLpanelEnd FLrun instr 1 k gate = sc_trig : k ( metro ( 1 / 2 ), 0.5 ) k env linenv k gate , 1 , 0 , 0.15 , 1 , 0.1 , 0 printf \"t: %f , kenv: %f \\n \" , timeinstk (), timeinsts (), k env k env *= 0.2 a sig = pinker () * interp ( k env ) outs a sig , a sig endin instr 2 i period = 2 i gatedur = 1 k gate = sc_trig : k ( metro ( 1 / i period ), i gatedur ) a env linenv k gate , 1 , 0 , 0.2 , 1 , 0.1 , 0 a sig = oscili : a ( 0.2 , 1000 ) * a env FLsetVal changed ( k gate ), k gate , gi h1 outs a sig , a sig endin instr 3 a sig pinker a env linenv gk gate , 2 , 0 , 0.05 , 1 , 0.1 , 0.2 , 0.5 , 0 a sig *= a env outs a sig , a sig endin </ CsInstruments > < CsScore > ; i1 0 10 i 2 0 10 ; i3 0 100 </ CsScore > </ CsoundSynthesizer > See also ramptrig linsegr bpf Credits Eduardo Moguillansky, 2019 (idea based on pd/else's envgen and supercollider's envgen )","title":"linenv"},{"location":"opcodes/linenv.html#linenv","text":"","title":"linenv"},{"location":"opcodes/linenv.html#abstract","text":"A triggerable linear envelope with sustain segment","title":"Abstract"},{"location":"opcodes/linenv.html#description","text":"linenv is similar to linsegr with an additional gate argument, allowing to retrigger it at will. One of the values can be defined as a sustain point, meaning that as long as the gate is held, the envelope enters a sustain state when reaching this point. When the gate is set to 0, the envelope traverses the rest of the defined points.","title":"Description"},{"location":"opcodes/linenv.html#syntax","text":"xout linenv kgate, isustindex, kval0, [ktime1, kval1, ktime2, kval2, ...]","title":"Syntax"},{"location":"opcodes/linenv.html#arguments","text":"kgate : whenever this switches from 0 to 1 a new envelope starts isustindex : the index of the sustain point. For example, if isustindex is 2, then when the envelope reaches kval2 (after ktime0+ktime1), it enters a sustain phase, where its value remains unmodified until the gate is set to 0. If no sustain point is desired, set isustindex to -1 kval0 , ktime1 , ...: a linear envelope, similar to linsegr . The release part can have as many segments as desired. ktimex values are defined as time interval between two values, not as absolute timestamps","title":"Arguments"},{"location":"opcodes/linenv.html#output","text":"xout : value of the envelope (k- or a- rate)","title":"Output"},{"location":"opcodes/linenv.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/linenv.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* This is the example file for opcode \"linenv\" linenv is a triggerable envelope with a sustain segment aout linenv kgate, isustidx, kval0, ktime1, kval1, ..., ktimen, kvaln NB: use isustidx=-1 if no sustain is desired NB: use xtratim if necessary to allow for release segment */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gk gate init 0 FLpanel \"linenv\" , 240 , 100 , 100 , 100 gk gate , gi h1 FLbutton \" Gate\" , 1 , 0 , 2 , 80 , 40 , 10 , 10 , - 1 FLpanelEnd FLrun instr 1 k gate = sc_trig : k ( metro ( 1 / 2 ), 0.5 ) k env linenv k gate , 1 , 0 , 0.15 , 1 , 0.1 , 0 printf \"t: %f , kenv: %f \\n \" , timeinstk (), timeinsts (), k env k env *= 0.2 a sig = pinker () * interp ( k env ) outs a sig , a sig endin instr 2 i period = 2 i gatedur = 1 k gate = sc_trig : k ( metro ( 1 / i period ), i gatedur ) a env linenv k gate , 1 , 0 , 0.2 , 1 , 0.1 , 0 a sig = oscili : a ( 0.2 , 1000 ) * a env FLsetVal changed ( k gate ), k gate , gi h1 outs a sig , a sig endin instr 3 a sig pinker a env linenv gk gate , 2 , 0 , 0.05 , 1 , 0.1 , 0.2 , 0.5 , 0 a sig *= a env outs a sig , a sig endin </ CsInstruments > < CsScore > ; i1 0 10 i 2 0 10 ; i3 0 100 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/linenv.html#see-also","text":"ramptrig linsegr bpf","title":"See also"},{"location":"opcodes/linenv.html#credits","text":"Eduardo Moguillansky, 2019 (idea based on pd/else's envgen and supercollider's envgen )","title":"Credits"},{"location":"opcodes/pargread.html","text":"pargread Abstract Read parg values from any active instrument instance Description pargread can be used to query parg vales of a running instance (possibly a fractional instrument number) of an instrument. Together with pargwrite it can be used to establish a two-way communication between two running instances of any two instruments. It no instance is found that matches the given instrument number, the output value is set to inotfound . Reading a parg which has not been set as the instance was scheduled (either in the score or via the multiple scheduling opcodes, like \"event\", \"schedule\", etc) will result in undefined behaviour . Syntax output : i | k pargread instrnum , index : i | k [, inotfound =- 1 ] Arguments instrnum (i): the (fractional) instrument number to modify index (i or k): the index of the parg to read. If kindex is 4, then p4 will be modified inotfound : the value to return if instrnum is not found (should be different from any expected value) Output output (i or k): the current value of the given parg Execution Time Init (if output is of i-type) Performance (if output is of k-type) Examples < CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > /* Example file for pargread ivalue pargread instrnum, indx [, inotfound=-1] pargread reads a parg value from an active instrument Returns inotfound if instrnum is not active */ instr 1 print p4 endin instr 2 i p4 pargread 1.01 , 4 printf \"<<<< p4 for instr 1.01 is %f >>>> \\n \" , 1 , i p4 turnoff endin </ CsInstruments > < CsScore > i 1.01 0 2 95 i 2 1 0.1 </ CsScore > </ CsoundSynthesizer > See also pargwrite pset p ) passign Credits Eduardo Moguillansky, 2019","title":"pargread"},{"location":"opcodes/pargread.html#pargread","text":"","title":"pargread"},{"location":"opcodes/pargread.html#abstract","text":"Read parg values from any active instrument instance","title":"Abstract"},{"location":"opcodes/pargread.html#description","text":"pargread can be used to query parg vales of a running instance (possibly a fractional instrument number) of an instrument. Together with pargwrite it can be used to establish a two-way communication between two running instances of any two instruments. It no instance is found that matches the given instrument number, the output value is set to inotfound . Reading a parg which has not been set as the instance was scheduled (either in the score or via the multiple scheduling opcodes, like \"event\", \"schedule\", etc) will result in undefined behaviour .","title":"Description"},{"location":"opcodes/pargread.html#syntax","text":"output : i | k pargread instrnum , index : i | k [, inotfound =- 1 ]","title":"Syntax"},{"location":"opcodes/pargread.html#arguments","text":"instrnum (i): the (fractional) instrument number to modify index (i or k): the index of the parg to read. If kindex is 4, then p4 will be modified inotfound : the value to return if instrnum is not found (should be different from any expected value)","title":"Arguments"},{"location":"opcodes/pargread.html#output","text":"output (i or k): the current value of the given parg","title":"Output"},{"location":"opcodes/pargread.html#execution-time","text":"Init (if output is of i-type) Performance (if output is of k-type)","title":"Execution Time"},{"location":"opcodes/pargread.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > /* Example file for pargread ivalue pargread instrnum, indx [, inotfound=-1] pargread reads a parg value from an active instrument Returns inotfound if instrnum is not active */ instr 1 print p4 endin instr 2 i p4 pargread 1.01 , 4 printf \"<<<< p4 for instr 1.01 is %f >>>> \\n \" , 1 , i p4 turnoff endin </ CsInstruments > < CsScore > i 1.01 0 2 95 i 2 1 0.1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pargread.html#see-also","text":"pargwrite pset p ) passign","title":"See also"},{"location":"opcodes/pargread.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/pargwrite.html","text":"pargwrite Abstract Modify parg values of an active instrument instance Description pargwrite can be used to modify a running instance (possibly a fractional instrument number) of an instrument, modifying parg values also after the instance has been started. It no instance is found that matches the given instrument number, a warning will be printed to the console and this opcode will fail silently. If the instance ceases to exist during another instrument is modifying its parg values, nothing happens. At the moment there is no bounds checking regarding the parg index. Writing to a parg which has not been set as the instance was scheduled (either in the score or via the multiple scheduling opcodes, like \"event\", \"schedule\", etc) will result in undefined behaviour . Syntax pargwrite instrnum, i/kindex, i/kvalue Arguments instrnum : the (fractional) instrument number to modify iindex / kindex : the index of the parg to modify. If kindex is 4, then p4 will be modified ivalue / kvalue : the new value of the given parg Output Execution Time Init (if index and value are i-values) Performance (if either index or value are k-variables) Examples < CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > /* Example file for pargread ivalue pargread instrnum, indx [, inotfound=-1] pargread reads a parg value from an active instrument Returns inotfound if instrnum is not active */ instr 1 k 4 = p4 printf \"instance: %.3f , p4: %f \\n \" , metro ( 10 ), p1 , k 4 endin instr 2 k val line 10 , p3 , 20 pargwrite 1.01 , 4 , k val endin </ CsInstruments > < CsScore > i 1.01 0 2 101 i 1.02 0 2 102 i 2 1 0.5 </ CsScore > </ CsoundSynthesizer > See also pargread pset p ) passign Credits Eduardo Moguillansky, 2019","title":"pargwrite"},{"location":"opcodes/pargwrite.html#pargwrite","text":"","title":"pargwrite"},{"location":"opcodes/pargwrite.html#abstract","text":"Modify parg values of an active instrument instance","title":"Abstract"},{"location":"opcodes/pargwrite.html#description","text":"pargwrite can be used to modify a running instance (possibly a fractional instrument number) of an instrument, modifying parg values also after the instance has been started. It no instance is found that matches the given instrument number, a warning will be printed to the console and this opcode will fail silently. If the instance ceases to exist during another instrument is modifying its parg values, nothing happens. At the moment there is no bounds checking regarding the parg index. Writing to a parg which has not been set as the instance was scheduled (either in the score or via the multiple scheduling opcodes, like \"event\", \"schedule\", etc) will result in undefined behaviour .","title":"Description"},{"location":"opcodes/pargwrite.html#syntax","text":"pargwrite instrnum, i/kindex, i/kvalue","title":"Syntax"},{"location":"opcodes/pargwrite.html#arguments","text":"instrnum : the (fractional) instrument number to modify iindex / kindex : the index of the parg to modify. If kindex is 4, then p4 will be modified ivalue / kvalue : the new value of the given parg","title":"Arguments"},{"location":"opcodes/pargwrite.html#output","text":"","title":"Output"},{"location":"opcodes/pargwrite.html#execution-time","text":"Init (if index and value are i-values) Performance (if either index or value are k-variables)","title":"Execution Time"},{"location":"opcodes/pargwrite.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > /* Example file for pargread ivalue pargread instrnum, indx [, inotfound=-1] pargread reads a parg value from an active instrument Returns inotfound if instrnum is not active */ instr 1 k 4 = p4 printf \"instance: %.3f , p4: %f \\n \" , metro ( 10 ), p1 , k 4 endin instr 2 k val line 10 , p3 , 20 pargwrite 1.01 , 4 , k val endin </ CsInstruments > < CsScore > i 1.01 0 2 101 i 1.02 0 2 102 i 2 1 0.5 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pargwrite.html#see-also","text":"pargread pset p ) passign","title":"See also"},{"location":"opcodes/pargwrite.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/poly.html","text":"poly Abstract poly creates and controls multiple parallel version of an opcode Description poly creates a user given number of instances of an opcode, each with its own state, inputs and outputs. The resulting output is an array where each element holds the output of the corresponding instance. In general, an opcode has a signature, given by the number and types of its output and input arguments. For example, the opcode oscili as used like aout oscili kamp, kfreq has a signature a / kk ( a as output, kk as input). To follow this example, to create 10 parallel versions of this opcode (an oscillator bank) it is possible to use poly like this: k Freqs [] fillarray 100 , 110 , 200 , 220 , 300 , 330 , 400 , 440 , 500 , 550 a Out [] poly 10 , \"oscili\" , 0.1 , k Freqs Notice that it is possible to set one value for each instance, as given by kFreqs , or one value to be shared by all instances, as given by the amplitude 0.1 . By changing the array kFreqs it is possible to modify the frequency of each oscillator. It is of course possible to chain multiple poly s to generate complex effect chains, and poly can also be used with k-values. NB : At the moment poly works only with builtin opcodes . This might change in the future Syntax out1[], [ out2[], ... ] poly inuminstances, Sopcode, xarg0, [xarg1, ...] Arguments inuminstances : the number of instances of Sopcode to instantiate Sopcode : the name of the opcode xargs : any number of arguments, either i-, k- or a-rate, either scalar or arrays, or strings, as needed by the given opcode. String arrays are not yet supported The number and type of the input arguments depend on the arguments passed to the given opcode. The same applies for the output arguments NB : output arguments are always arrays, input arguments can be arrays, in which case they must be at least the size of inuminstances , or scalars, in which case the same value is shared by multiple instances Output The output is one or more arrays of k- or a-type, corresponding to the opcode. For instance, an opcode like aout oscili 0.1, kfreq will output an array of audio channels. An opcode like pan2 will output two audio arrays. Examples LISTEN < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 0dbfs = 1 ; create an array of random values between 0-1 ; inum: number of elements in the array opcode rndarr , i[] , i i num xin i Out [] init i num i 0 = 0 while i 0 < i num do i Out [ i 0 ] = unirand ( 1 ) i 0 += 1 od xout i Out endop ; multiple oscillators, mixed down to mono instr 1 ; number of oscillators i num = 100 ; fundamental k midi = line ( ntom : i ( \"2G\" ), p3 , ntom : i ( \"1C\" )) k f0 = mtof ( k midi ) ; each oscillator is an overtone of f0 k Ratios [] genarray_i 1 , i num ; harmonicity over time k exp line 1 , p3 , 1.32 ; the freq. of each oscillator k Freqs [] = ( k Ratios ^ k exp ) * k f0 ; array of random phases, to avoid synchronous start i Phs [] rndarr i num ; generate the oscillators. a Oscils [] poly i num , \"oscili\" , 1 / i num , k Freqs , - 1 , i Phs a mono sumarray a Oscils a mono *= linsegr : a ( 0 , 0.05 , 1 , 0.05 , 0 ) outs a mono , a mono endin ; poly instances stacked as a processing pipe instr 2 ; amount of polyphony i num = 30 i Freqs [] rndarr i num ; the ratios of the overtones k Ratios [] genarray_i 1 , i num ; a down gliss k m0 linseg ntom : i ( \"2C\" ), p3 * 0.8 , ntom : i ( \"1C\" ) k f0 = mtof ( k m0 ) ; harmonicity curve k p linsegb 1 , p3 * 0.8 , 1.68 ; calculate actual freqs. k Freqs [] = ( k Ratios ^ k p ) * k f0 ; lfo freqs. used for AM and panning k f linsegb 0.1 , p3 * 0.62 , 0.8 , p3 * 0.8 , 0.8 , p3 * 0.96 , 12 , p3 , 60 k LfoFreqs [] = i Freqs * k f ; multiple noise instances, amplitude modulated a A [] poly i num , \"noise\" , 0.5 , 0.3 a Amps [] poly i num , \"oscili\" , 1 , k LfoFreqs * 0.6 a A *= a Amps ; filter noise with bandpass k Q linsegb 0.5 , p3 * 0.5 , 0.02 , p3 , 0.0001 k Bands [] = k Freqs * k Q a B [] poly i num , \"resonr\" , a A , k Freqs , k Bands ; panning. poly works also with k-rate and with ; opcodes producing multiple outputs, like pan2 k PanPos [] poly i num , \"lfo\" , 0.5 , k LfoFreqs k PanPos += 0.5 ; lfo in the range 0-1 for panning a L [], a R [] poly i num , \"pan2\" , a B , k PanPos a left sumarray a L a right sumarray a R ; compress / fade a ref init 1 a sig = 0.707 * ( a left + a right ) a gain compress2 a ref , a sig , - 90 , - 48 , - 24 , 2.5 , 0.05 , 0.2 , 0.05 a left *= a gain a right *= a gain a gain2 compress2 a ref , ( a left + a right ) * 0.707 , - 90 , - 6 , - 3 , 20 , 0.002 , 0.010 , 0.02 a env = a gain2 * cossegr : a ( 0 , 1 , 1 , 0.1 , 0 ) outs a left * a env , a right * a env endin opcode test , a , k k freq xin a out oscili 0.1 , k freq xout a out endop instr 3 ; test udo k freqs [] fillarray 440 , 443 a A [] poly 2 , \"test\" , k freqs a 0 sumarray a A outs a 0 , a 0 endin </ CsInstruments > < CsScore > i 1 0 8 i 2 9 50 ; i 3 0 1 </ CsScore > </ CsoundSynthesizer > See also maparray polyseq Credits Eduardo Moguillansky, 2019","title":"poly"},{"location":"opcodes/poly.html#poly","text":"","title":"poly"},{"location":"opcodes/poly.html#abstract","text":"poly creates and controls multiple parallel version of an opcode","title":"Abstract"},{"location":"opcodes/poly.html#description","text":"poly creates a user given number of instances of an opcode, each with its own state, inputs and outputs. The resulting output is an array where each element holds the output of the corresponding instance. In general, an opcode has a signature, given by the number and types of its output and input arguments. For example, the opcode oscili as used like aout oscili kamp, kfreq has a signature a / kk ( a as output, kk as input). To follow this example, to create 10 parallel versions of this opcode (an oscillator bank) it is possible to use poly like this: k Freqs [] fillarray 100 , 110 , 200 , 220 , 300 , 330 , 400 , 440 , 500 , 550 a Out [] poly 10 , \"oscili\" , 0.1 , k Freqs Notice that it is possible to set one value for each instance, as given by kFreqs , or one value to be shared by all instances, as given by the amplitude 0.1 . By changing the array kFreqs it is possible to modify the frequency of each oscillator. It is of course possible to chain multiple poly s to generate complex effect chains, and poly can also be used with k-values. NB : At the moment poly works only with builtin opcodes . This might change in the future","title":"Description"},{"location":"opcodes/poly.html#syntax","text":"out1[], [ out2[], ... ] poly inuminstances, Sopcode, xarg0, [xarg1, ...]","title":"Syntax"},{"location":"opcodes/poly.html#arguments","text":"inuminstances : the number of instances of Sopcode to instantiate Sopcode : the name of the opcode xargs : any number of arguments, either i-, k- or a-rate, either scalar or arrays, or strings, as needed by the given opcode. String arrays are not yet supported The number and type of the input arguments depend on the arguments passed to the given opcode. The same applies for the output arguments NB : output arguments are always arrays, input arguments can be arrays, in which case they must be at least the size of inuminstances , or scalars, in which case the same value is shared by multiple instances","title":"Arguments"},{"location":"opcodes/poly.html#output","text":"The output is one or more arrays of k- or a-type, corresponding to the opcode. For instance, an opcode like aout oscili 0.1, kfreq will output an array of audio channels. An opcode like pan2 will output two audio arrays.","title":"Output"},{"location":"opcodes/poly.html#examples","text":"LISTEN < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 0dbfs = 1 ; create an array of random values between 0-1 ; inum: number of elements in the array opcode rndarr , i[] , i i num xin i Out [] init i num i 0 = 0 while i 0 < i num do i Out [ i 0 ] = unirand ( 1 ) i 0 += 1 od xout i Out endop ; multiple oscillators, mixed down to mono instr 1 ; number of oscillators i num = 100 ; fundamental k midi = line ( ntom : i ( \"2G\" ), p3 , ntom : i ( \"1C\" )) k f0 = mtof ( k midi ) ; each oscillator is an overtone of f0 k Ratios [] genarray_i 1 , i num ; harmonicity over time k exp line 1 , p3 , 1.32 ; the freq. of each oscillator k Freqs [] = ( k Ratios ^ k exp ) * k f0 ; array of random phases, to avoid synchronous start i Phs [] rndarr i num ; generate the oscillators. a Oscils [] poly i num , \"oscili\" , 1 / i num , k Freqs , - 1 , i Phs a mono sumarray a Oscils a mono *= linsegr : a ( 0 , 0.05 , 1 , 0.05 , 0 ) outs a mono , a mono endin ; poly instances stacked as a processing pipe instr 2 ; amount of polyphony i num = 30 i Freqs [] rndarr i num ; the ratios of the overtones k Ratios [] genarray_i 1 , i num ; a down gliss k m0 linseg ntom : i ( \"2C\" ), p3 * 0.8 , ntom : i ( \"1C\" ) k f0 = mtof ( k m0 ) ; harmonicity curve k p linsegb 1 , p3 * 0.8 , 1.68 ; calculate actual freqs. k Freqs [] = ( k Ratios ^ k p ) * k f0 ; lfo freqs. used for AM and panning k f linsegb 0.1 , p3 * 0.62 , 0.8 , p3 * 0.8 , 0.8 , p3 * 0.96 , 12 , p3 , 60 k LfoFreqs [] = i Freqs * k f ; multiple noise instances, amplitude modulated a A [] poly i num , \"noise\" , 0.5 , 0.3 a Amps [] poly i num , \"oscili\" , 1 , k LfoFreqs * 0.6 a A *= a Amps ; filter noise with bandpass k Q linsegb 0.5 , p3 * 0.5 , 0.02 , p3 , 0.0001 k Bands [] = k Freqs * k Q a B [] poly i num , \"resonr\" , a A , k Freqs , k Bands ; panning. poly works also with k-rate and with ; opcodes producing multiple outputs, like pan2 k PanPos [] poly i num , \"lfo\" , 0.5 , k LfoFreqs k PanPos += 0.5 ; lfo in the range 0-1 for panning a L [], a R [] poly i num , \"pan2\" , a B , k PanPos a left sumarray a L a right sumarray a R ; compress / fade a ref init 1 a sig = 0.707 * ( a left + a right ) a gain compress2 a ref , a sig , - 90 , - 48 , - 24 , 2.5 , 0.05 , 0.2 , 0.05 a left *= a gain a right *= a gain a gain2 compress2 a ref , ( a left + a right ) * 0.707 , - 90 , - 6 , - 3 , 20 , 0.002 , 0.010 , 0.02 a env = a gain2 * cossegr : a ( 0 , 1 , 1 , 0.1 , 0 ) outs a left * a env , a right * a env endin opcode test , a , k k freq xin a out oscili 0.1 , k freq xout a out endop instr 3 ; test udo k freqs [] fillarray 440 , 443 a A [] poly 2 , \"test\" , k freqs a 0 sumarray a A outs a 0 , a 0 endin </ CsInstruments > < CsScore > i 1 0 8 i 2 9 50 ; i 3 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/poly.html#see-also","text":"maparray polyseq","title":"See also"},{"location":"opcodes/poly.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/polyseq.html","text":"polyseq Abstract polyseq creates and controls multiple sequential version of an opcode Description polyseq creates a user given number of instances of an opcode, each with its own state. The output of an instance is routed to the input of the next instance, forming a chain. Each instance can be controlled individually. We differentiate between chained and multiplexed arguments. chained arguments are the ones which are mapped from one opcode instance to the next, so that the output of one instance is routed to the input of the next. multiplexed are passed after the chained arguments and work as they do with poly : if an array is passed, then each instance is delivered one element of this array, and if a scalar value is passed, then all instances share the same argument. Example All this is best explained with an example: ; these two signal chains produce the same result a 0 pinker k Freqs [] fillarray 100 , 150 , 300 , 330 a eq rbjeq a 0 , k Freqs [ 0 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 1 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 2 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 3 ], 2 , 10 , 1 , 8 a seq polyseq 4 , \"rbjeq\" , a 0 , k Freqs , 2 , 10 , 1 , 8 Syntax xouts polyseq numinstances:i, opcodename:s, xins, params ... polyseq can have any number of inputs and outputs, as long as the opcode used has matching inputs and outputs. Arguments inuminstances : the number of instances of Sopcode to instantiate Sopcode : the name of the opcode xins : any number of arguments, either k- or a-rate, which should correspond to the outputs of the opcode The number and type of the input arguments depend on the arguments passed to the given opcode. The same applies for the output arguments Output xouts : any number of arguments of type k or a , as output by the opcode Examples LISTEN < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 0dbfs = 1 ; Example file for polyseq instr 1 ; A simple parametric eq. ; On the left channel, the reference signal, ; on the right, the polyseq implementation. ; These should be the same a 0 pinker a 0 *= ampdb ( - 12 ) k Freqs [] fillarray 400 , 1400 , 3000 , 4400 , 8000 , 12000 k Qs [] fillarray 10 , 20 , 10 , 20 , 10 , 20 k V = ampdb ( 18 ) a ref = a 0 a ref rbjeq a ref , k Freqs [ 0 ], k V , k Qs [ 0 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 1 ], k V , k Qs [ 1 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 2 ], k V , k Qs [ 2 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 3 ], k V , k Qs [ 3 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 4 ], k V , k Qs [ 4 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 5 ], k V , k Qs [ 5 ], 1 , 8 a seq polyseq lenarray ( k Freqs ), \"rbjeq\" , a 0 , k Freqs , k V , k Qs , 1 , 8 outs a ref , a seq endin opcode rndarr , i[] , iii i num , i min , i max xin i Out [] init i num i 0 = 0 i delta = i max - i min while i 0 < i num do i Out [ i 0 ] = i min + unirand ( i delta ) i 0 += 1 od xout i Out endop instr 2 ; two varying eqs a 0 = pinker () * ampdb ( - 8 ) k Freqs0 [] fillarray 50 , 130 , 400 , 500 , 1400 , 3000 , 4400 , 5000 , 8000 i num lenarray k Freqs0 i Freqslfo [] rndarr i num , 0.05 , 0.4 k Lfos [] poly i num , \"lfo\" , 0.1 , i Freqslfo k FreqsL [] = k Freqs0 * ( 1 + k Lfos ) k FreqsR [] = k Freqs0 * ( 1 + k Lfos * 1.62 ) k Qs [] poly i num , \"lfo\" , 5 , i Freqslfo * 1.5 k Qs += 7.5 a eqL polyseq i num , \"rbjeq\" , a 0 , k FreqsL , ampdb ( 10 ), k Qs , 1 , 8 a eqR polyseq i num , \"rbjeq\" , a 0 , k FreqsR , ampdb ( 12 ), k Qs * 1.5 , 1 , 8 ; declick a env = linsegr ( 0 , 0.5 , 1 , 0.5 , 0 ) outs a eqL * a env , a eqR * a env endin </ CsInstruments > < CsScore > i 1 0 5 i 2 5 20 </ CsScore > </ CsoundSynthesizer > See also maparray poly Credits Eduardo Moguillansky, 2019","title":"polyseq"},{"location":"opcodes/polyseq.html#polyseq","text":"","title":"polyseq"},{"location":"opcodes/polyseq.html#abstract","text":"polyseq creates and controls multiple sequential version of an opcode","title":"Abstract"},{"location":"opcodes/polyseq.html#description","text":"polyseq creates a user given number of instances of an opcode, each with its own state. The output of an instance is routed to the input of the next instance, forming a chain. Each instance can be controlled individually. We differentiate between chained and multiplexed arguments. chained arguments are the ones which are mapped from one opcode instance to the next, so that the output of one instance is routed to the input of the next. multiplexed are passed after the chained arguments and work as they do with poly : if an array is passed, then each instance is delivered one element of this array, and if a scalar value is passed, then all instances share the same argument.","title":"Description"},{"location":"opcodes/polyseq.html#example","text":"All this is best explained with an example: ; these two signal chains produce the same result a 0 pinker k Freqs [] fillarray 100 , 150 , 300 , 330 a eq rbjeq a 0 , k Freqs [ 0 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 1 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 2 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 3 ], 2 , 10 , 1 , 8 a seq polyseq 4 , \"rbjeq\" , a 0 , k Freqs , 2 , 10 , 1 , 8","title":"Example"},{"location":"opcodes/polyseq.html#syntax","text":"xouts polyseq numinstances:i, opcodename:s, xins, params ... polyseq can have any number of inputs and outputs, as long as the opcode used has matching inputs and outputs.","title":"Syntax"},{"location":"opcodes/polyseq.html#arguments","text":"inuminstances : the number of instances of Sopcode to instantiate Sopcode : the name of the opcode xins : any number of arguments, either k- or a-rate, which should correspond to the outputs of the opcode The number and type of the input arguments depend on the arguments passed to the given opcode. The same applies for the output arguments","title":"Arguments"},{"location":"opcodes/polyseq.html#output","text":"xouts : any number of arguments of type k or a , as output by the opcode","title":"Output"},{"location":"opcodes/polyseq.html#examples","text":"LISTEN < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 0dbfs = 1 ; Example file for polyseq instr 1 ; A simple parametric eq. ; On the left channel, the reference signal, ; on the right, the polyseq implementation. ; These should be the same a 0 pinker a 0 *= ampdb ( - 12 ) k Freqs [] fillarray 400 , 1400 , 3000 , 4400 , 8000 , 12000 k Qs [] fillarray 10 , 20 , 10 , 20 , 10 , 20 k V = ampdb ( 18 ) a ref = a 0 a ref rbjeq a ref , k Freqs [ 0 ], k V , k Qs [ 0 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 1 ], k V , k Qs [ 1 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 2 ], k V , k Qs [ 2 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 3 ], k V , k Qs [ 3 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 4 ], k V , k Qs [ 4 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 5 ], k V , k Qs [ 5 ], 1 , 8 a seq polyseq lenarray ( k Freqs ), \"rbjeq\" , a 0 , k Freqs , k V , k Qs , 1 , 8 outs a ref , a seq endin opcode rndarr , i[] , iii i num , i min , i max xin i Out [] init i num i 0 = 0 i delta = i max - i min while i 0 < i num do i Out [ i 0 ] = i min + unirand ( i delta ) i 0 += 1 od xout i Out endop instr 2 ; two varying eqs a 0 = pinker () * ampdb ( - 8 ) k Freqs0 [] fillarray 50 , 130 , 400 , 500 , 1400 , 3000 , 4400 , 5000 , 8000 i num lenarray k Freqs0 i Freqslfo [] rndarr i num , 0.05 , 0.4 k Lfos [] poly i num , \"lfo\" , 0.1 , i Freqslfo k FreqsL [] = k Freqs0 * ( 1 + k Lfos ) k FreqsR [] = k Freqs0 * ( 1 + k Lfos * 1.62 ) k Qs [] poly i num , \"lfo\" , 5 , i Freqslfo * 1.5 k Qs += 7.5 a eqL polyseq i num , \"rbjeq\" , a 0 , k FreqsL , ampdb ( 10 ), k Qs , 1 , 8 a eqR polyseq i num , \"rbjeq\" , a 0 , k FreqsR , ampdb ( 12 ), k Qs * 1.5 , 1 , 8 ; declick a env = linsegr ( 0 , 0.5 , 1 , 0.5 , 0 ) outs a eqL * a env , a eqR * a env endin </ CsInstruments > < CsScore > i 1 0 5 i 2 5 20 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/polyseq.html#see-also","text":"maparray poly","title":"See also"},{"location":"opcodes/polyseq.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/ramptrig.html","text":"ramptrig Abstract A triggerable ramp between 0 and 1 Description ramptrig is a phasor between 0 and 1, with the difference that it stops after reaching its end point. Whenever it is triggered it rewinds to 0 and starts ramping to 1 in the given duration. A trigger detected whenever the value is possitive and higher than the previous value. Usage as envelope generator Together with bpf this can be used to emulate supercollider's Env and EnvGen , where ramptrig is used as a triggerable phasor, passed as an argument to bpf , which generates the envelope. See examples Syntax kout ramptrig ktrig, kdur, ivaluepost=1, ivaluepre=0 kout, kfinished ramptrig ktrig, kdur, ivaluepost=1, ivaluepre=0 Arguments ktrig : whenever this is possitive and higher than last value, kout is rewinded to 0 kdur : the duration of the ramp ivaluepost : value when ramp reaches its end (default=1) ivaluepre : value previous to any trigger (default=0) Output kout : value of the ramp, between 0 and 1. It can also be ivaluepost or ivaluepre if these are set to any other value than the default kfinished : will be one whenever the ramp reaches its end value. Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > ; This is the example file of ramptrig ; ramptrig is a triggerable ramp from 0 to 1 ; xout ramptrig xtrig, kdur sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; Use Case #1: An envelope which can be retriggered instr 1 ; Duration of envelope k dur = 4 ; This is the gate, could be any irregular signal, midi, osc, etc. k trig metro 0.5 ; Whenever ktrig is possitive and higher than previous value, ; kx ramps from 0 to 1 in kdur seconds k x ramptrig k trig , k dur ; actual envelope k env bpf k x * k dur , 0 , 0 , 0.02 , 1 , k dur , 0 a sig oscili 0.2 , 1000 ; asig pinker a sig *= interp ( k env ) outs a sig , a sig endin ; Use Case #2: Use finished trigger to signal something instr 2 k trig metro 1 / 4 k trig delayk k trig , 0.5 i dur = 2 k phase , k finished1 ramptrig k trig , 2 printf \"finished! \\n \" , k finished1 k env bpf k phase * i dur , 0 , 0 , 0.5 , 1 , 0.8 , 0.5 , 1 , 1 , i dur , 0 a sig = pinker () * interp ( k env ) outs a sig , a sig endin </ CsInstruments > < CsScore > i 1 0 10 ; i2 0 12 ; i3 0 20 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also linenv sc_phasor bpf Credits Eduardo Moguillansky, 2019","title":"ramptrig"},{"location":"opcodes/ramptrig.html#ramptrig","text":"","title":"ramptrig"},{"location":"opcodes/ramptrig.html#abstract","text":"A triggerable ramp between 0 and 1","title":"Abstract"},{"location":"opcodes/ramptrig.html#description","text":"ramptrig is a phasor between 0 and 1, with the difference that it stops after reaching its end point. Whenever it is triggered it rewinds to 0 and starts ramping to 1 in the given duration. A trigger detected whenever the value is possitive and higher than the previous value. Usage as envelope generator Together with bpf this can be used to emulate supercollider's Env and EnvGen , where ramptrig is used as a triggerable phasor, passed as an argument to bpf , which generates the envelope. See examples","title":"Description"},{"location":"opcodes/ramptrig.html#syntax","text":"kout ramptrig ktrig, kdur, ivaluepost=1, ivaluepre=0 kout, kfinished ramptrig ktrig, kdur, ivaluepost=1, ivaluepre=0","title":"Syntax"},{"location":"opcodes/ramptrig.html#arguments","text":"ktrig : whenever this is possitive and higher than last value, kout is rewinded to 0 kdur : the duration of the ramp ivaluepost : value when ramp reaches its end (default=1) ivaluepre : value previous to any trigger (default=0)","title":"Arguments"},{"location":"opcodes/ramptrig.html#output","text":"kout : value of the ramp, between 0 and 1. It can also be ivaluepost or ivaluepre if these are set to any other value than the default kfinished : will be one whenever the ramp reaches its end value.","title":"Output"},{"location":"opcodes/ramptrig.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/ramptrig.html#examples","text":"< CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > ; This is the example file of ramptrig ; ramptrig is a triggerable ramp from 0 to 1 ; xout ramptrig xtrig, kdur sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; Use Case #1: An envelope which can be retriggered instr 1 ; Duration of envelope k dur = 4 ; This is the gate, could be any irregular signal, midi, osc, etc. k trig metro 0.5 ; Whenever ktrig is possitive and higher than previous value, ; kx ramps from 0 to 1 in kdur seconds k x ramptrig k trig , k dur ; actual envelope k env bpf k x * k dur , 0 , 0 , 0.02 , 1 , k dur , 0 a sig oscili 0.2 , 1000 ; asig pinker a sig *= interp ( k env ) outs a sig , a sig endin ; Use Case #2: Use finished trigger to signal something instr 2 k trig metro 1 / 4 k trig delayk k trig , 0.5 i dur = 2 k phase , k finished1 ramptrig k trig , 2 printf \"finished! \\n \" , k finished1 k env bpf k phase * i dur , 0 , 0 , 0.5 , 1 , 0.8 , 0.5 , 1 , 1 , i dur , 0 a sig = pinker () * interp ( k env ) outs a sig , a sig endin </ CsInstruments > < CsScore > i 1 0 10 ; i2 0 12 ; i3 0 20 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/ramptrig.html#see-also","text":"linenv sc_phasor bpf","title":"See also"},{"location":"opcodes/ramptrig.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/schmitt.html","text":"schmitt Abstract A schmitt trigger (a comparator with hysteresis). Description Implements a schmitt trigger, which is a comparator with hysteresis. Whenever the input is higher than khigh , output is 1 and stays 1 until input drops beneath klow . Output is 1 if the input is higher than khigh if signal is increasing Output is 0 if the input is lower than klow if signal is decreasing Note schmitt is particularly useful for implementing effects like a noise gate, to avoid fast opening and closing at the threshold. It can be further refined together with sc_lagud to add attack / release times to the opening of the gate or with sc_trig to assure a minimum open time for the gate Port of pd/else's schmitt Syntax xout schmitt xin, khigh, klow Arguments xin : input signal (k- or audio rate). The rate of xin must match the rate of xout khigh : high value of the comparator, output is 1 whenever input is higher than this klow : low value of the comparator, output is 0 whenever input is lower than this Output xout : output value of the comparator (0 or 1). Rate of xout is the same as xin Execution Time Performance (k or audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 /* Example file for schmitt opcode aout schmitt ain, khigh, klow kout schmitt kin, khigh, klow schmitt is a schmitt trigger (a gate with hysteresis), out is 1 if higher than khigh, 0 if lower than klow */ FLpanel \"schmitt\" , 400 , 300 , 50 , 50 i disp1 FLvalue \"\" , 40 , 30 , 322 , 20 i disp2 FLvalue \"\" , 40 , 30 , 322 , 80 i disp3 FLvalue \"\" , 40 , 30 , 322 , 140 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk signal , gi h1 FLslider \"signal\" , - 1 , 1 , 0 , 1 , i disp1 , 300 , 30 , 20 , 20 gk low , gi h2 FLslider \"low\" , - 1 , 1 , 0 , 3 , i disp2 , 300 , 30 , 20 , 80 gk high , gi h3 FLslider \"high\" , - 1 , 1 , 0 , 3 , i disp3 , 300 , 30 , 20 , 140 k schmitt , gi h4 FLbutton \"out\" , 1 , 0 , 3 , 50 , 50 , 20 , 200 , - 1 FLpanelEnd FLrun FLsetVal_i - 0.5 , gi h2 FLsetVal_i 0.5 , gi h3 instr 1 a in oscili 1 , 0.25 a out schmitt a in , gk high , gk low k guitrig metro 24 FLsetVal k guitrig , k ( a in ), gi h1 FLsetVal k guitrig , k ( a out ), gi h4 endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer > See also sc_lagud sc_trig Credits Eduardo Moguillansky, 2019","title":"schmitt"},{"location":"opcodes/schmitt.html#schmitt","text":"","title":"schmitt"},{"location":"opcodes/schmitt.html#abstract","text":"A schmitt trigger (a comparator with hysteresis).","title":"Abstract"},{"location":"opcodes/schmitt.html#description","text":"Implements a schmitt trigger, which is a comparator with hysteresis. Whenever the input is higher than khigh , output is 1 and stays 1 until input drops beneath klow . Output is 1 if the input is higher than khigh if signal is increasing Output is 0 if the input is lower than klow if signal is decreasing Note schmitt is particularly useful for implementing effects like a noise gate, to avoid fast opening and closing at the threshold. It can be further refined together with sc_lagud to add attack / release times to the opening of the gate or with sc_trig to assure a minimum open time for the gate Port of pd/else's schmitt","title":"Description"},{"location":"opcodes/schmitt.html#syntax","text":"xout schmitt xin, khigh, klow","title":"Syntax"},{"location":"opcodes/schmitt.html#arguments","text":"xin : input signal (k- or audio rate). The rate of xin must match the rate of xout khigh : high value of the comparator, output is 1 whenever input is higher than this klow : low value of the comparator, output is 0 whenever input is lower than this","title":"Arguments"},{"location":"opcodes/schmitt.html#output","text":"xout : output value of the comparator (0 or 1). Rate of xout is the same as xin","title":"Output"},{"location":"opcodes/schmitt.html#execution-time","text":"Performance (k or audio)","title":"Execution Time"},{"location":"opcodes/schmitt.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 /* Example file for schmitt opcode aout schmitt ain, khigh, klow kout schmitt kin, khigh, klow schmitt is a schmitt trigger (a gate with hysteresis), out is 1 if higher than khigh, 0 if lower than klow */ FLpanel \"schmitt\" , 400 , 300 , 50 , 50 i disp1 FLvalue \"\" , 40 , 30 , 322 , 20 i disp2 FLvalue \"\" , 40 , 30 , 322 , 80 i disp3 FLvalue \"\" , 40 , 30 , 322 , 140 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk signal , gi h1 FLslider \"signal\" , - 1 , 1 , 0 , 1 , i disp1 , 300 , 30 , 20 , 20 gk low , gi h2 FLslider \"low\" , - 1 , 1 , 0 , 3 , i disp2 , 300 , 30 , 20 , 80 gk high , gi h3 FLslider \"high\" , - 1 , 1 , 0 , 3 , i disp3 , 300 , 30 , 20 , 140 k schmitt , gi h4 FLbutton \"out\" , 1 , 0 , 3 , 50 , 50 , 20 , 200 , - 1 FLpanelEnd FLrun FLsetVal_i - 0.5 , gi h2 FLsetVal_i 0.5 , gi h3 instr 1 a in oscili 1 , 0.25 a out schmitt a in , gk high , gk low k guitrig metro 24 FLsetVal k guitrig , k ( a in ), gi h1 FLsetVal k guitrig , k ( a out ), gi h4 endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/schmitt.html#see-also","text":"sc_lagud sc_trig","title":"See also"},{"location":"opcodes/schmitt.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/sigmdrive.html","text":"sigmdrive Abstract Analog \"soft clipping\" distortion by applying non-linear transfer functions. Description sigmdrive simulates analog \"soft clipping\" by applying non-linear transfer functions. Two different sigmoid equations are implemented. mode 0 out = tanh(in * drivefactor) mode 1 if in > 0 then out = 1.0 - pow(1. - in, drivefactor) if in <= 0 then out = pow(1. + x, drivefactor) - 1.0 Syntax aout sigmdrive ain, xdrivefactor, kmode=0 Arguments ain : the input audio signal xdrivefactor : a k- or a- value, normally greater than 1. A higher value implies more distortion kmode : the distortion mode. 0=tanh, 1=pow (see above) Output aout : the distorted audio Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* sigmdrive: a sigmoid distortion aout sigmdrive ain, kdrive, kmode=0 kdrive: how much distortion (range 0-1) kmode: 0 = tanh, 1 = pow */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 FLpanel \"sigmdrive\" , 400 , 200 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 322 , 20 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk drive , i drivehandle1 FLslider \"drive\" , 0 , 10 , 0 , 3 , i disp1 , 300 , 30 , 20 , 20 gk mode , i drivehandle2 FLbutton \"mode\" , 1 , 0 , 3 , 60 , 50 , 20 , 80 , - 1 FLpanelEnd FLrun instr 1 a in oscili 0.2 , 440 a out sigmdrive a in , port : k ( gk drive , 0.2 ), gk mode outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer > See also tubeharmonics distort1 tanh powershape Credits Eduardo Moguillansky, 2019 (based on pd/else's drive~ - https://github.com/porres/pd-else)","title":"sigmdrive"},{"location":"opcodes/sigmdrive.html#sigmdrive","text":"","title":"sigmdrive"},{"location":"opcodes/sigmdrive.html#abstract","text":"Analog \"soft clipping\" distortion by applying non-linear transfer functions.","title":"Abstract"},{"location":"opcodes/sigmdrive.html#description","text":"sigmdrive simulates analog \"soft clipping\" by applying non-linear transfer functions. Two different sigmoid equations are implemented.","title":"Description"},{"location":"opcodes/sigmdrive.html#mode-0","text":"out = tanh(in * drivefactor)","title":"mode 0"},{"location":"opcodes/sigmdrive.html#mode-1","text":"if in > 0 then out = 1.0 - pow(1. - in, drivefactor) if in <= 0 then out = pow(1. + x, drivefactor) - 1.0","title":"mode 1"},{"location":"opcodes/sigmdrive.html#syntax","text":"aout sigmdrive ain, xdrivefactor, kmode=0","title":"Syntax"},{"location":"opcodes/sigmdrive.html#arguments","text":"ain : the input audio signal xdrivefactor : a k- or a- value, normally greater than 1. A higher value implies more distortion kmode : the distortion mode. 0=tanh, 1=pow (see above)","title":"Arguments"},{"location":"opcodes/sigmdrive.html#output","text":"aout : the distorted audio","title":"Output"},{"location":"opcodes/sigmdrive.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/sigmdrive.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* sigmdrive: a sigmoid distortion aout sigmdrive ain, kdrive, kmode=0 kdrive: how much distortion (range 0-1) kmode: 0 = tanh, 1 = pow */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 FLpanel \"sigmdrive\" , 400 , 200 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 322 , 20 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk drive , i drivehandle1 FLslider \"drive\" , 0 , 10 , 0 , 3 , i disp1 , 300 , 30 , 20 , 20 gk mode , i drivehandle2 FLbutton \"mode\" , 1 , 0 , 3 , 60 , 50 , 20 , 80 , - 1 FLpanelEnd FLrun instr 1 a in oscili 0.2 , 440 a out sigmdrive a in , port : k ( gk drive , 0.2 ), gk mode outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/sigmdrive.html#see-also","text":"tubeharmonics distort1 tanh powershape","title":"See also"},{"location":"opcodes/sigmdrive.html#credits","text":"Eduardo Moguillansky, 2019 (based on pd/else's drive~ - https://github.com/porres/pd-else)","title":"Credits"},{"location":"opcodes/standardchaos.html","text":"standardchaos Abstract Standard map chaotic generator Description standardchaos is a chaotic generator, the sound is generated with the following difference equations; y[n] = (y[n-1] + k * sin(x[n-1])) % 2pi; x[n] = (x[n-1] + y[n]) % 2pi; out = (x[n] - pi) / pi Syntax aout standardchaos krate, kk=1, ix=0.5, iy=0 Arguments krate : from 0 to nyquist kk : a value for k in the above equation ix : initial value for x iy : initial value for y Output aout : audio output of the chaotic generator Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 /* Example file for standardchaos opcode aout standardchaos krate, kk, ix=0.5, iy=0 Standard map chaotic generator, the sound is generated with the difference equations; y[n] = (y[n-1] + k * sin(x[n-1])) % 2pi; x[n] = (x[n-1] + y[n]) % 2pi; out = (x[n] - pi) / pi; */ FLpanel \"standardchaos\" , 600 , 300 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 522 , 20 i disp2 FLvalue \"\" , 50 , 30 , 522 , 80 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk rate , gi h1 FLslider \"rate\" , 0 , 20000 , 0 , 3 , i disp1 , 500 , 30 , 20 , 20 gk k , gi h2 FLslider \"k\" , 0 , 10 , 0 , 3 , i disp2 , 500 , 30 , 20 , 80 FLpanelEnd FLrun FLsetVal_i 1618 , gi h1 FLsetVal_i 1 , gi h2 instr 1 i x = 0.5 i y = 1 i gain = 0.3 a out standardchaos gk rate , gk k , i x , i y a out *= i gain outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer > See also crackle chuap dust2 Credits Eduardo Moguillansky, 2019 (based on pd/else's standard~ - https://github.com/porres/pd-else)","title":"standardchaos"},{"location":"opcodes/standardchaos.html#standardchaos","text":"","title":"standardchaos"},{"location":"opcodes/standardchaos.html#abstract","text":"Standard map chaotic generator","title":"Abstract"},{"location":"opcodes/standardchaos.html#description","text":"standardchaos is a chaotic generator, the sound is generated with the following difference equations; y[n] = (y[n-1] + k * sin(x[n-1])) % 2pi; x[n] = (x[n-1] + y[n]) % 2pi; out = (x[n] - pi) / pi","title":"Description"},{"location":"opcodes/standardchaos.html#syntax","text":"aout standardchaos krate, kk=1, ix=0.5, iy=0","title":"Syntax"},{"location":"opcodes/standardchaos.html#arguments","text":"krate : from 0 to nyquist kk : a value for k in the above equation ix : initial value for x iy : initial value for y","title":"Arguments"},{"location":"opcodes/standardchaos.html#output","text":"aout : audio output of the chaotic generator","title":"Output"},{"location":"opcodes/standardchaos.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/standardchaos.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 /* Example file for standardchaos opcode aout standardchaos krate, kk, ix=0.5, iy=0 Standard map chaotic generator, the sound is generated with the difference equations; y[n] = (y[n-1] + k * sin(x[n-1])) % 2pi; x[n] = (x[n-1] + y[n]) % 2pi; out = (x[n] - pi) / pi; */ FLpanel \"standardchaos\" , 600 , 300 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 522 , 20 i disp2 FLvalue \"\" , 50 , 30 , 522 , 80 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk rate , gi h1 FLslider \"rate\" , 0 , 20000 , 0 , 3 , i disp1 , 500 , 30 , 20 , 20 gk k , gi h2 FLslider \"k\" , 0 , 10 , 0 , 3 , i disp2 , 500 , 30 , 20 , 80 FLpanelEnd FLrun FLsetVal_i 1618 , gi h1 FLsetVal_i 1 , gi h2 instr 1 i x = 0.5 i y = 1 i gain = 0.3 a out standardchaos gk rate , gk k , i x , i y a out *= i gain outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/standardchaos.html#see-also","text":"crackle chuap dust2","title":"See also"},{"location":"opcodes/standardchaos.html#credits","text":"Eduardo Moguillansky, 2019 (based on pd/else's standard~ - https://github.com/porres/pd-else)","title":"Credits"},{"location":"opcodes/tubeharmonics.html","text":"tubeharmonics Abstract A distortion with control for odd/even harmonics Description Simulates the behaviour of a vacuum tube circuit stage. Adds odd and even harmonics to the signal. Has flux and program dependent saturation. A port of REAPER 's \"Tube Harmonics\" jsfx plugin Syntax aout tubeharmonics ain, keven, kodd, kfluctuation=0, kindrive=0, koutdrive=0, kgain=0 Arguments ain : the input signal keven : amount of even harmonics (between 0-1) kodd : amount of odd harmonics (between 0-1) kfluctuation : non linearities (between 0-1, default 0) kindrive : amount of input drive (in dB, default=0 dB) koutdrive : amount of output drive (in dB, default=0 dB) koutgain : output gain, in dB (default=0 dB) Output aout : audio output Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for jsfx opcode gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i gain = 0 a 1 , a 2 tubeharmonics a sig , a sig , gk even , gk odd , gk flct , gk inpt , gk out , i gain outs a 1 , a 2 endin </ CsInstruments > < CsScore > i 1 0 300 </ CsScore > </ CsoundSynthesizer > See also sigmdrive tanh distort1 Credits Eduardo Moguillansky, 2019","title":"tubeharmonics"},{"location":"opcodes/tubeharmonics.html#tubeharmonics","text":"","title":"tubeharmonics"},{"location":"opcodes/tubeharmonics.html#abstract","text":"A distortion with control for odd/even harmonics","title":"Abstract"},{"location":"opcodes/tubeharmonics.html#description","text":"Simulates the behaviour of a vacuum tube circuit stage. Adds odd and even harmonics to the signal. Has flux and program dependent saturation. A port of REAPER 's \"Tube Harmonics\" jsfx plugin","title":"Description"},{"location":"opcodes/tubeharmonics.html#syntax","text":"aout tubeharmonics ain, keven, kodd, kfluctuation=0, kindrive=0, koutdrive=0, kgain=0","title":"Syntax"},{"location":"opcodes/tubeharmonics.html#arguments","text":"ain : the input signal keven : amount of even harmonics (between 0-1) kodd : amount of odd harmonics (between 0-1) kfluctuation : non linearities (between 0-1, default 0) kindrive : amount of input drive (in dB, default=0 dB) koutdrive : amount of output drive (in dB, default=0 dB) koutgain : output gain, in dB (default=0 dB)","title":"Arguments"},{"location":"opcodes/tubeharmonics.html#output","text":"aout : audio output","title":"Output"},{"location":"opcodes/tubeharmonics.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/tubeharmonics.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ;; This is the example file for jsfx opcode gi snd ftgen 0 , 0 , 0 , - 1 , \"snd/bourre-fragment-1.flac\" , 0 , 0 , 1 FLpanel \"jsfx\" , 400 , 500 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i w , i h = 300 , 30 i line = i h * 2 i y , i x = i h , i h * 0.5 ; min max exp gk which , i 0 FLslider \"source\" , 0 , 2 , 0 , 3 , - 1 , i w , i h , i x , i y i y += i line i v1 FLvalue \"\" , 50 , 30 , 322 , i y gk even , i 1 FLslider \"even harmonics\" , 0 , 1 , 0 , 3 , i v1 , i w , i h , i x , i y i y += i line i v2 FLvalue \"\" , 50 , 30 , 322 , i y gk odd , i 2 FLslider \"odd harmonics\" , 0 , 1 , 0 , 3 , i v2 , i w , i h , i x , i y i y += i line i v3 FLvalue \"\" , 50 , 30 , 322 , i y gk flct , i 3 FLslider \"fluctuation\" , 0 , 1 , 0 , 3 , i v3 , i w , i h , i x , i y i y += i line i v4 FLvalue \"\" , 50 , 30 , 322 , i y gk inpt , i 4 FLslider \"Input (dB)\" , - 12 , 12 , 0 , 3 , i v4 , i w , i h , i x , i y i y += i line i v5 FLvalue \"\" , 50 , 30 , 322 , i y gk out , i 5 FLslider \"Output (dB)\" , - 12 , 12 , 0 , 3 , i v5 , i w , i h , i x , i y i y += i line FLcolor 150 , 100 , 150 , 200 , 200 , 100 gk dump , i 6 FLbutton \"Dump variables\" , 1 , 0 , 2 , i w / 2 , i h , i x , i y , - 1 FLpanelEnd FLrun FLsetVal_i 0 , i 0 FLsetVal_i 0.3 , i 1 FLsetVal_i 0.3 , i 2 FLsetVal_i 0.1 , i 3 FLsetVal_i 0 , i 4 FLsetVal_i 0 , i 5 FLsetVal_i 0 , i 6 opcode loopsamp , a , i i ft xin i loopend = nsamp ( i ft ) / sr a sig flooper2 1 , 1 , 0 , i loopend , 0.1 , i ft xout a sig endop opcode select3 , a , kaaa k which , a 1 , a 2 , a 3 xin if ( k which < 1 ) then a sig = a 1 * ( 1 - k which ) + a 2 * k which else a sig = a 2 * ( 2 - k which ) + a 3 * ( k which - 1 ) endif xout a sig endop instr 1 a 1 loopsamp gi snd a 3 vco2 0.5 , ntof : i ( \"3C\" ) a 2 oscili 0.5 , 1000 a sig select3 gk which , a 1 , a 2 , a 3 i gain = 0 a 1 , a 2 tubeharmonics a sig , a sig , gk even , gk odd , gk flct , gk inpt , gk out , i gain outs a 1 , a 2 endin </ CsInstruments > < CsScore > i 1 0 300 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/tubeharmonics.html#see-also","text":"sigmdrive tanh distort1","title":"See also"},{"location":"opcodes/tubeharmonics.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"}]}