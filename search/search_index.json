{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Csound Plugins Welcome to the csound-plugins wiki! This is a collection of plugins for csound Installation See Installation klib A hashtable for csound dict_new : Create a hashtable dict_free : Free a hashtable dict_get : Get a value from a hashtable dict_set : Set (or remove) a value from a hashtable dict_size : Returns the number of key:value pairs in a dict dict_query : Query different properties of a dict dict_print : Prints the contents of a dict dict_iter : Iterate over the key-value pairs of a dict cacheput : Put a string inside the cache cacheget : Get a string inside the cache cachepop : Get a cached string and remove it from the cache poly Multiple (parallel or sequential) instances of an opcode poly : poly creates and controls multiple parallel version of an opcode polyseq : polyseq creates and controls multiple sequential version of an opcode sched Schedule an action when note is stopped atstop : Schedule an instrument at the end of the current instrument else These opcdes are ports from or based on puredata/else crackle : generates noise based on a chaotic equation ramptrig : A triggerable ramp between 0 and 1 rampgate : A triggerable envelope with sustain segment sigmdrive : Analog \"soft clipping\" distortion by applying non-linear transfer functions. standardchaos : Standard map chaotic generator lfnoise : low frequency, band-limited noise","title":"Csound Plugins"},{"location":"index.html#csound-plugins","text":"Welcome to the csound-plugins wiki! This is a collection of plugins for csound","title":"Csound Plugins"},{"location":"index.html#installation","text":"See Installation","title":"Installation"},{"location":"index.html#klib","text":"A hashtable for csound dict_new : Create a hashtable dict_free : Free a hashtable dict_get : Get a value from a hashtable dict_set : Set (or remove) a value from a hashtable dict_size : Returns the number of key:value pairs in a dict dict_query : Query different properties of a dict dict_print : Prints the contents of a dict dict_iter : Iterate over the key-value pairs of a dict cacheput : Put a string inside the cache cacheget : Get a string inside the cache cachepop : Get a cached string and remove it from the cache","title":"klib"},{"location":"index.html#poly","text":"Multiple (parallel or sequential) instances of an opcode poly : poly creates and controls multiple parallel version of an opcode polyseq : polyseq creates and controls multiple sequential version of an opcode","title":"poly"},{"location":"index.html#sched","text":"Schedule an action when note is stopped atstop : Schedule an instrument at the end of the current instrument","title":"sched"},{"location":"index.html#else","text":"These opcdes are ports from or based on puredata/else crackle : generates noise based on a chaotic equation ramptrig : A triggerable ramp between 0 and 1 rampgate : A triggerable envelope with sustain segment sigmdrive : Analog \"soft clipping\" distortion by applying non-linear transfer functions. standardchaos : Standard map chaotic generator lfnoise : low frequency, band-limited noise","title":"else"},{"location":"Contributing.html","text":"Contributing To submit an opcode clone this repository and make a pull request Organisation An opcode is normally implemented as part of a library, to allow for different versions and related opcodes to share functionality. Each library lives in its own directory. The tree can be structured as follows: mylib/ CMakeLists.txt manifest.json [ README.md ] src/ mylib.c examples/ foo.csd bar.csd docs/ foo.md bar.md For each opcode defined in mylib.c there should be an example opcode.csd and a manual page opcode.md . Optionally it is possible to include a README.md where a short description of the opcodes in this library is given Put your tree under src and you should be able to build your plugin. Build We use cmake as a build tool. For simple opcodes with no extra dependencies, a simple CMakeLists.txt would suffice: make_plugin(mylib src/mylib.c) Installation At the root folder of this repository, do mkdir build cd build cmake .. make sudo make install Manifest A manifest is used to automate documentation of the opcodes (wiki, pdf documentation, etc). The manifest is a .json file. It should have the minimal form: { \"name\" : \"mylib\" , \"opcodes\" : [ \"foo\" , \"bar\" ], \"author\" : \"name\" , \"author_email\" : \"name@email.com\" , \"license\" : \"LGPL\" , \"description\" : \"Description of this package\" , \"url\" : \"http://github.com/...\" } In this case, three opcodes are defined, and these names should correspond to the .csd example living inside of the examples folder, and a .md file living inside the docs folder.","title":"Contributing"},{"location":"Contributing.html#contributing","text":"To submit an opcode clone this repository and make a pull request","title":"Contributing"},{"location":"Contributing.html#organisation","text":"An opcode is normally implemented as part of a library, to allow for different versions and related opcodes to share functionality. Each library lives in its own directory. The tree can be structured as follows: mylib/ CMakeLists.txt manifest.json [ README.md ] src/ mylib.c examples/ foo.csd bar.csd docs/ foo.md bar.md For each opcode defined in mylib.c there should be an example opcode.csd and a manual page opcode.md . Optionally it is possible to include a README.md where a short description of the opcodes in this library is given Put your tree under src and you should be able to build your plugin.","title":"Organisation"},{"location":"Contributing.html#build","text":"We use cmake as a build tool. For simple opcodes with no extra dependencies, a simple CMakeLists.txt would suffice: make_plugin(mylib src/mylib.c)","title":"Build"},{"location":"Contributing.html#installation","text":"At the root folder of this repository, do mkdir build cd build cmake .. make sudo make install","title":"Installation"},{"location":"Contributing.html#manifest","text":"A manifest is used to automate documentation of the opcodes (wiki, pdf documentation, etc). The manifest is a .json file. It should have the minimal form: { \"name\" : \"mylib\" , \"opcodes\" : [ \"foo\" , \"bar\" ], \"author\" : \"name\" , \"author_email\" : \"name@email.com\" , \"license\" : \"LGPL\" , \"description\" : \"Description of this package\" , \"url\" : \"http://github.com/...\" } In this case, three opcodes are defined, and these names should correspond to the .csd example living inside of the examples folder, and a .md file living inside the docs folder.","title":"Manifest"},{"location":"Installation.html","text":"Installation From Source The source lives at https://github.com/csound-plugins/csound-plugins Dependencies a compiler cmake csound >= 6.13 git clone https://github.com/csound-plugins/csound-plugins cd csound-plugins mkdir build cd build cmake .. make sudo make install","title":"Installation"},{"location":"Installation.html#installation","text":"","title":"Installation"},{"location":"Installation.html#from-source","text":"The source lives at https://github.com/csound-plugins/csound-plugins","title":"From Source"},{"location":"Installation.html#dependencies","text":"a compiler cmake csound >= 6.13 git clone https://github.com/csound-plugins/csound-plugins cd csound-plugins mkdir build cd build cmake .. make sudo make install","title":"Dependencies"},{"location":"opcodes/atstop.html","text":"atstop Abstract Schedule an instrument at the end of the current instrument Description atstop can be used to schedule an instrument event as the last action of a given instrument, during the process of being deallocated. This can be used to notify when the note has actually stopped, or to schedule a chain of events, free any table or dict allocated, etc. The advantage over the release opcode is that atstop is guaranteed to be run after the note has stopped, so there is no danger in deallocating resources being used by this note, there are no conflicts with release envelopes, etc. Release time vs deinit time The event is not scheduled at release time (see below \"Release time vs Deinit time\") but at the moment the note is freed. Release time is when the note is within its release phase , which will only happen if the note has an envelope with a release segment (like linsegr ), or if it has setup extra time with xtratim . The opcode release can be used to query if the current note is being released. The instrument keeps running in release phase as long as the release part of the envelope is finished or the extra time allocated via xtratim is through. Deinit time is the moment the note is actually being freed, so the instrument is not running anymore at this point. Syntax atstop instrnum [, idelay=0, idur=-1, p4, p5, ...] atstop Sinstrname [, idelay=0, idur=-1, p4, p5, ...] atstop executes only at init time . Arguments instrnum / Sintrname : the number or the name of the instr to be scheduled idelay : the time offset after the stop time of this note to start this instrument idur : the duration of the event p4 , p5 , ...: any other p-arguments, as used with similar opcodes like schedule , event , etc. Execution Time Init Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* # This is the example file for the atstop opcode atstop schedules an instrument at the end of the note This might be useful to notify that a note stopped, or to schedule a chain of notes, etc. NB: the scheduled event is NOT triggered at release time, which might be when this note is still playing, if the note has some release envelope, but when the note is being deleted ## Syntax atstop Sinstrname, idelay, idur, ... atstop instrnum, idelay, idur, ... * Sinstrname / instrnum: the name or the instrument number to schedule * idelay: time offset to this note stop * idur: duration of the scheduled event (-1 = forever) */ sr = 44100 ksmps = 64 0dbfs = 1 nchnls = 2 opcode myvco , a , ii i amp , i freq xin a 0 vco2 , i amp , i freq a 0 += vco2 ( i amp , i freq + 2 ) a 0 += vco2 ( i amp , i freq / 2 ) xout a 0 endop ; brownian walk instr 1 i midi = p4 a 0 myvco 0.1 , mtof : i ( i midi ) outs a 0 , a 0 i delta = round (( rnd ( 4 ) - 1 ) * 2 ) / 2 i delta = i delta != 0 ? i delta : - 0.5 i midi2 = i midi + i delta i midi2 = i midi2 < 96 ? i midi2 : 48 i durnext = round ( rnd ( 0.25 ) * 8 ) / 8 a tstop 1 , 0 , i durnext , i midi2 endin ; ping-pong instr 2 i midi = p4 i midi = i midi < 96 ? i midi : 48 a 0 myvco 0.1 , mtof : i ( i midi ) a 0 *= linsegr ( 0 , 0.05 , 1 , 0.05 , 0 ) outs a 0 , a 0 a tstop 3 , 0 , p3 * 0.97 , i midi + 1 endin instr 3 i midi = p4 i midi = i midi < 88 ? i midi : 48 a 0 oscili 0.8 , mtof : i ( i midi ) a 0 *= linsegr ( 0 , 0.05 , 1 , 0.050 , 0 ) outs a 0 , a 0 a tstop 2 , 0 , p3 * 0.95 , i midi + 1 endin ; test calling a named instr at stop instr 10 a 0 oscili 0.1 , 440 outs a 0 , a 0 a tstop \"foo\" , 0.5 , 1 , 1000 endin instr foo i freq = p4 a 0 oscili 0.1 , i freq outs a 0 , a 0 endin ; test simple case with optional pargs instr first a tstop \"second\" , 1 , - 1 , 0.5 a tstop \"second\" , 0.5 a tstop 200 endin instr second printf \"second! p4 = %f \\n \" , 1 , p4 turnoff endin instr 200 printf \"200! \\n \" , 1 turnoff endin instr StopPerformance exitnow endin </ CsInstruments > < CsScore > ; i 1 0 0.25 36 ; i 2 0 0.25 48 ; i 10 0 1 ; i \"StopPerformance\" 10 1 i \"first\" 1 0.5 f 0 5 </ CsScore > </ CsoundSynthesizer > See also schedule event release xtratim Credits Eduardo Moguillansky, 2019","title":"atstop"},{"location":"opcodes/atstop.html#atstop","text":"","title":"atstop"},{"location":"opcodes/atstop.html#abstract","text":"Schedule an instrument at the end of the current instrument","title":"Abstract"},{"location":"opcodes/atstop.html#description","text":"atstop can be used to schedule an instrument event as the last action of a given instrument, during the process of being deallocated. This can be used to notify when the note has actually stopped, or to schedule a chain of events, free any table or dict allocated, etc. The advantage over the release opcode is that atstop is guaranteed to be run after the note has stopped, so there is no danger in deallocating resources being used by this note, there are no conflicts with release envelopes, etc. Release time vs deinit time The event is not scheduled at release time (see below \"Release time vs Deinit time\") but at the moment the note is freed. Release time is when the note is within its release phase , which will only happen if the note has an envelope with a release segment (like linsegr ), or if it has setup extra time with xtratim . The opcode release can be used to query if the current note is being released. The instrument keeps running in release phase as long as the release part of the envelope is finished or the extra time allocated via xtratim is through. Deinit time is the moment the note is actually being freed, so the instrument is not running anymore at this point.","title":"Description"},{"location":"opcodes/atstop.html#syntax","text":"atstop instrnum [, idelay=0, idur=-1, p4, p5, ...] atstop Sinstrname [, idelay=0, idur=-1, p4, p5, ...] atstop executes only at init time .","title":"Syntax"},{"location":"opcodes/atstop.html#arguments","text":"instrnum / Sintrname : the number or the name of the instr to be scheduled idelay : the time offset after the stop time of this note to start this instrument idur : the duration of the event p4 , p5 , ...: any other p-arguments, as used with similar opcodes like schedule , event , etc.","title":"Arguments"},{"location":"opcodes/atstop.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/atstop.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* # This is the example file for the atstop opcode atstop schedules an instrument at the end of the note This might be useful to notify that a note stopped, or to schedule a chain of notes, etc. NB: the scheduled event is NOT triggered at release time, which might be when this note is still playing, if the note has some release envelope, but when the note is being deleted ## Syntax atstop Sinstrname, idelay, idur, ... atstop instrnum, idelay, idur, ... * Sinstrname / instrnum: the name or the instrument number to schedule * idelay: time offset to this note stop * idur: duration of the scheduled event (-1 = forever) */ sr = 44100 ksmps = 64 0dbfs = 1 nchnls = 2 opcode myvco , a , ii i amp , i freq xin a 0 vco2 , i amp , i freq a 0 += vco2 ( i amp , i freq + 2 ) a 0 += vco2 ( i amp , i freq / 2 ) xout a 0 endop ; brownian walk instr 1 i midi = p4 a 0 myvco 0.1 , mtof : i ( i midi ) outs a 0 , a 0 i delta = round (( rnd ( 4 ) - 1 ) * 2 ) / 2 i delta = i delta != 0 ? i delta : - 0.5 i midi2 = i midi + i delta i midi2 = i midi2 < 96 ? i midi2 : 48 i durnext = round ( rnd ( 0.25 ) * 8 ) / 8 a tstop 1 , 0 , i durnext , i midi2 endin ; ping-pong instr 2 i midi = p4 i midi = i midi < 96 ? i midi : 48 a 0 myvco 0.1 , mtof : i ( i midi ) a 0 *= linsegr ( 0 , 0.05 , 1 , 0.05 , 0 ) outs a 0 , a 0 a tstop 3 , 0 , p3 * 0.97 , i midi + 1 endin instr 3 i midi = p4 i midi = i midi < 88 ? i midi : 48 a 0 oscili 0.8 , mtof : i ( i midi ) a 0 *= linsegr ( 0 , 0.05 , 1 , 0.050 , 0 ) outs a 0 , a 0 a tstop 2 , 0 , p3 * 0.95 , i midi + 1 endin ; test calling a named instr at stop instr 10 a 0 oscili 0.1 , 440 outs a 0 , a 0 a tstop \"foo\" , 0.5 , 1 , 1000 endin instr foo i freq = p4 a 0 oscili 0.1 , i freq outs a 0 , a 0 endin ; test simple case with optional pargs instr first a tstop \"second\" , 1 , - 1 , 0.5 a tstop \"second\" , 0.5 a tstop 200 endin instr second printf \"second! p4 = %f \\n \" , 1 , p4 turnoff endin instr 200 printf \"200! \\n \" , 1 turnoff endin instr StopPerformance exitnow endin </ CsInstruments > < CsScore > ; i 1 0 0.25 36 ; i 2 0 0.25 48 ; i 10 0 1 ; i \"StopPerformance\" 10 1 i \"first\" 1 0.5 f 0 5 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/atstop.html#see-also","text":"schedule event release xtratim","title":"See also"},{"location":"opcodes/atstop.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/cacheget.html","text":"cacheget Abstract Get a string inside the cache Description The cache- opcodes implement a global string cache. This can be useful to pass multiple strings between instruments using the event opcode. This is similar to the strset and strget opcodes but automatically asigns an idx to each distints string inside the cache (we guarantee that passing twice the same string will return the same index) cacheget executes both at i-time and k-time , depending on the type of the input variable Syntax Sstr cacheget idx Sstr cacheget kdx Arguments idx / kdx : the numeric id representing the string, as returned by cacheput Output Sstr : the string inside the cache, corresponding to idx Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for cacheput / cacheget cacheput and cacheget implement a method to internalize strings, similar to strset and strget, but without having to take care about setting the indices cacheput puts a strin into the cache and returns an idx identifying this string. If a string is put into the cache which already exists, we guarantee that the index returned is the same. idx cacheput Sstr i-time kdx cacheput Sstr k-time cacheget retrieves a str previously put in the cache. If the index does not point to an existing string, a performance error is raised Sstr cacheget idx i-time Sstr cacheget kdx k-time Both opcodes work at both i- and k-time, depending on the arguments */ ; Use cacheput/get to pass multiple strings between instruments instr 1 event_i \"i\" , 2 , 0 , - 1 , cacheput : i ( \"foo\" ), cacheput : i ( \"bar\" ) turnoff endin instr 2 S 1 cacheget p4 S 2 cacheget p5 prints \"S1= %s S2= %s \\n \" , S 1 , S 2 turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 f 0 1 </ CsScore > </ CsoundSynthesizer > See also cacheput Credits Eduardo Moguillansky, 2019","title":"cacheget"},{"location":"opcodes/cacheget.html#cacheget","text":"","title":"cacheget"},{"location":"opcodes/cacheget.html#abstract","text":"Get a string inside the cache","title":"Abstract"},{"location":"opcodes/cacheget.html#description","text":"The cache- opcodes implement a global string cache. This can be useful to pass multiple strings between instruments using the event opcode. This is similar to the strset and strget opcodes but automatically asigns an idx to each distints string inside the cache (we guarantee that passing twice the same string will return the same index) cacheget executes both at i-time and k-time , depending on the type of the input variable","title":"Description"},{"location":"opcodes/cacheget.html#syntax","text":"Sstr cacheget idx Sstr cacheget kdx","title":"Syntax"},{"location":"opcodes/cacheget.html#arguments","text":"idx / kdx : the numeric id representing the string, as returned by cacheput","title":"Arguments"},{"location":"opcodes/cacheget.html#output","text":"Sstr : the string inside the cache, corresponding to idx","title":"Output"},{"location":"opcodes/cacheget.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/cacheget.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for cacheput / cacheget cacheput and cacheget implement a method to internalize strings, similar to strset and strget, but without having to take care about setting the indices cacheput puts a strin into the cache and returns an idx identifying this string. If a string is put into the cache which already exists, we guarantee that the index returned is the same. idx cacheput Sstr i-time kdx cacheput Sstr k-time cacheget retrieves a str previously put in the cache. If the index does not point to an existing string, a performance error is raised Sstr cacheget idx i-time Sstr cacheget kdx k-time Both opcodes work at both i- and k-time, depending on the arguments */ ; Use cacheput/get to pass multiple strings between instruments instr 1 event_i \"i\" , 2 , 0 , - 1 , cacheput : i ( \"foo\" ), cacheput : i ( \"bar\" ) turnoff endin instr 2 S 1 cacheget p4 S 2 cacheget p5 prints \"S1= %s S2= %s \\n \" , S 1 , S 2 turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 f 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/cacheget.html#see-also","text":"cacheput","title":"See also"},{"location":"opcodes/cacheget.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/cachepop.html","text":"cachepop Abstract Get a cached string and remove it from the cache Description The cache- opcodes implement a global string cache. This can be useful to pass multiple strings between instruments using the event opcode. This is similar to the strset and strget opcodes but automatically asigns an idx to each distints string inside the cache (we guarantee that passing twice the same string will return the same index). cachepop is similar to cacheget but after retrievin the value from the cache it is removed. This can be useful for cases where one-of strings are passed between instruments and do not need to survive the current note Syntax Sstr cachepop idx Arguments idx : the numeric id representing the string, as returned by cacheput Output Sstr : the string inside the cache, corresponding to idx Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for cacheput / cacheget / cachepop cacheput and cacheget implement a method to internalize strings, similar to strset and strget, but without having to take care about setting the indices. cachepop is similar to cacheget but removes the entry from the cache. cacheput puts a strin into the cache and returns an idx identifying this string. If a string is put into the cache which already exists, we guarantee that the index returned is the same. */ ; Use cacheput/pop to pass multiple strings between instruments instr 1 event_i \"i\" , 2 , 0 , - 1 , cacheput : i ( \"foo\" ), cacheput : i ( \"bar\" ) turnoff endin instr 2 S 1 cachepop p4 S 2 cachepop p5 ; these strings are no longer in the cache prints \"S1= %s S2= %s \\n \" , S 1 , S 2 turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 f 0 1 </ CsScore > </ CsoundSynthesizer > See also cacheput cacheget Credits Eduardo Moguillansky, 2019","title":"cachepop"},{"location":"opcodes/cachepop.html#cachepop","text":"","title":"cachepop"},{"location":"opcodes/cachepop.html#abstract","text":"Get a cached string and remove it from the cache","title":"Abstract"},{"location":"opcodes/cachepop.html#description","text":"The cache- opcodes implement a global string cache. This can be useful to pass multiple strings between instruments using the event opcode. This is similar to the strset and strget opcodes but automatically asigns an idx to each distints string inside the cache (we guarantee that passing twice the same string will return the same index). cachepop is similar to cacheget but after retrievin the value from the cache it is removed. This can be useful for cases where one-of strings are passed between instruments and do not need to survive the current note","title":"Description"},{"location":"opcodes/cachepop.html#syntax","text":"Sstr cachepop idx","title":"Syntax"},{"location":"opcodes/cachepop.html#arguments","text":"idx : the numeric id representing the string, as returned by cacheput","title":"Arguments"},{"location":"opcodes/cachepop.html#output","text":"Sstr : the string inside the cache, corresponding to idx","title":"Output"},{"location":"opcodes/cachepop.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/cachepop.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for cacheput / cacheget / cachepop cacheput and cacheget implement a method to internalize strings, similar to strset and strget, but without having to take care about setting the indices. cachepop is similar to cacheget but removes the entry from the cache. cacheput puts a strin into the cache and returns an idx identifying this string. If a string is put into the cache which already exists, we guarantee that the index returned is the same. */ ; Use cacheput/pop to pass multiple strings between instruments instr 1 event_i \"i\" , 2 , 0 , - 1 , cacheput : i ( \"foo\" ), cacheput : i ( \"bar\" ) turnoff endin instr 2 S 1 cachepop p4 S 2 cachepop p5 ; these strings are no longer in the cache prints \"S1= %s S2= %s \\n \" , S 1 , S 2 turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 f 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/cachepop.html#see-also","text":"cacheput cacheget","title":"See also"},{"location":"opcodes/cachepop.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/cacheput.html","text":"cacheput Abstract Put a string inside the cache Description The cache- opcodes implement a global string cache. This can be useful to pass multiple strings between instruments using the event opcode. This is similar to the strset and strget opcodes but automatically asigns an idx to each distints string inside the cache (we guarantee that passing twice the same string will return the same index) Syntax idx cacheput Sstr kdx cacheput Sstr Arguments Sstr : the string to be put inside the cache Output idx / kdx : the numeric id representing the string passed Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for cacheput / cacheget cacheput and cacheget implement a method to internalize strings, similar to strset and strget, but without having to take care about setting the indices cacheput puts a strin into the cache and returns an idx identifying this string. If a string is put into the cache which already exists, we guarantee that the index returned is the same. idx cacheput Sstr i-time kdx cacheput Sstr k-time cacheget retrieves a str previously put in the cache. If the index does not point to an existing string, a performance error is raised Sstr cacheget idx i-time Sstr cacheget kdx k-time Both opcodes work at both i- and k-time, depending on the arguments */ ; Use cacheput/get to pass multiple strings between instruments instr 1 event_i \"i\" , 2 , 0 , - 1 , cacheput : i ( \"foo\" ), cacheput : i ( \"bar\" ) turnoff endin instr 2 S 1 cacheget p4 S 2 cacheget p5 prints \"S1= %s S2= %s \\n \" , S 1 , S 2 turnoff endin instr 10 k trig metro 10 k i init 0 if k trig == 1 then k i += 1 event \"i\" , 20 , 0 , - 1 , cacheput : k ( sprintfk ( \"key %d \" , k i )) endif endin instr 20 S 1 cacheget p4 prints \"S1 = %s \\n \" , S 1 turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 i 10 + 1 f 0 1 </ CsScore > </ CsoundSynthesizer > See also cacheget Credits Eduardo Moguillansky, 2019","title":"cacheput"},{"location":"opcodes/cacheput.html#cacheput","text":"","title":"cacheput"},{"location":"opcodes/cacheput.html#abstract","text":"Put a string inside the cache","title":"Abstract"},{"location":"opcodes/cacheput.html#description","text":"The cache- opcodes implement a global string cache. This can be useful to pass multiple strings between instruments using the event opcode. This is similar to the strset and strget opcodes but automatically asigns an idx to each distints string inside the cache (we guarantee that passing twice the same string will return the same index)","title":"Description"},{"location":"opcodes/cacheput.html#syntax","text":"idx cacheput Sstr kdx cacheput Sstr","title":"Syntax"},{"location":"opcodes/cacheput.html#arguments","text":"Sstr : the string to be put inside the cache","title":"Arguments"},{"location":"opcodes/cacheput.html#output","text":"idx / kdx : the numeric id representing the string passed","title":"Output"},{"location":"opcodes/cacheput.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/cacheput.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for cacheput / cacheget cacheput and cacheget implement a method to internalize strings, similar to strset and strget, but without having to take care about setting the indices cacheput puts a strin into the cache and returns an idx identifying this string. If a string is put into the cache which already exists, we guarantee that the index returned is the same. idx cacheput Sstr i-time kdx cacheput Sstr k-time cacheget retrieves a str previously put in the cache. If the index does not point to an existing string, a performance error is raised Sstr cacheget idx i-time Sstr cacheget kdx k-time Both opcodes work at both i- and k-time, depending on the arguments */ ; Use cacheput/get to pass multiple strings between instruments instr 1 event_i \"i\" , 2 , 0 , - 1 , cacheput : i ( \"foo\" ), cacheput : i ( \"bar\" ) turnoff endin instr 2 S 1 cacheget p4 S 2 cacheget p5 prints \"S1= %s S2= %s \\n \" , S 1 , S 2 turnoff endin instr 10 k trig metro 10 k i init 0 if k trig == 1 then k i += 1 event \"i\" , 20 , 0 , - 1 , cacheput : k ( sprintfk ( \"key %d \" , k i )) endif endin instr 20 S 1 cacheget p4 prints \"S1 = %s \\n \" , S 1 turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 i 10 + 1 f 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/cacheput.html#see-also","text":"cacheget","title":"See also"},{"location":"opcodes/cacheput.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/crackle.html","text":"crackle Abstract generates noise based on a chaotic equation Description crackle is a chaotic generator, the sound is generated with the following equation y[n] = p * y[n-1]- y[n-2] - 0.05 Port of supercollider's Crackle Syntax aout crackle kp Arguments kp : the p parameter in the equation, a value between 1.0 and 2.0 Output aout : audio output of the chaotic generator Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* # This is the example file for the crackle opcode crackle is a port of supercollider's crackle (taken from pd/else) crackle is a chaotic noise generator based on the equation: y[n] = p * y[n-1] - y[n-2] - 0.05 ## Syntax aout crackle kp=0.5 * kp: value for p in the equation (default = 0.5) * aout: noise signal */ sr = 44100 ksmps = 64 0dbfs = 1 nchnls = 2 instr 1 k P [] fillarray 1.0 , 1.2 , 1.3 , 1.35 , 1.4 , 1.5 , 1.8 , 1.9 , 1.97 , 2.0 k idx = int ( line ( 0 , p3 , lenarray ( k P ))) k p = k P [ k idx ] printk2 k p a out crackle k p a out *= 0.5 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 15 </ CsScore > </ CsoundSynthesizer > See also standardchaos chuap dust2 Credits Eduardo Moguillansky, 2019","title":"crackle"},{"location":"opcodes/crackle.html#crackle","text":"","title":"crackle"},{"location":"opcodes/crackle.html#abstract","text":"generates noise based on a chaotic equation","title":"Abstract"},{"location":"opcodes/crackle.html#description","text":"crackle is a chaotic generator, the sound is generated with the following equation y[n] = p * y[n-1]- y[n-2] - 0.05 Port of supercollider's Crackle","title":"Description"},{"location":"opcodes/crackle.html#syntax","text":"aout crackle kp","title":"Syntax"},{"location":"opcodes/crackle.html#arguments","text":"kp : the p parameter in the equation, a value between 1.0 and 2.0","title":"Arguments"},{"location":"opcodes/crackle.html#output","text":"aout : audio output of the chaotic generator","title":"Output"},{"location":"opcodes/crackle.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/crackle.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* # This is the example file for the crackle opcode crackle is a port of supercollider's crackle (taken from pd/else) crackle is a chaotic noise generator based on the equation: y[n] = p * y[n-1] - y[n-2] - 0.05 ## Syntax aout crackle kp=0.5 * kp: value for p in the equation (default = 0.5) * aout: noise signal */ sr = 44100 ksmps = 64 0dbfs = 1 nchnls = 2 instr 1 k P [] fillarray 1.0 , 1.2 , 1.3 , 1.35 , 1.4 , 1.5 , 1.8 , 1.9 , 1.97 , 2.0 k idx = int ( line ( 0 , p3 , lenarray ( k P ))) k p = k P [ k idx ] printk2 k p a out crackle k p a out *= 0.5 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 15 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/crackle.html#see-also","text":"standardchaos chuap dust2","title":"See also"},{"location":"opcodes/crackle.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_free.html","text":"dict_free Abstract Free a hashtable Description frees the hashtable either at init time or at the end of the note (similar to ftfree) A dict can only be freed if it was created as global (see dict_new ). To be able to pass a dict between notes, a note can create a global dict and pass its handle to another note. When the first note is released, the dict lives on (because it is global), and it will be either freed at the end of the performance or explicitely by calling dict_free dict_free executes only at init time . Syntax dict_free idict [, iwhen=0] Arguments idict : the handle of the dict to be freed iwhen : similar to ftfree if iwhen == 0 : free the dict now if iwhen == 1 : free the dict at the end of this note Execution Time Init Examples < CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > See also dict_new Credits Eduardo Moguillansky, 2019","title":"dict_free"},{"location":"opcodes/dict_free.html#dict_free","text":"","title":"dict_free"},{"location":"opcodes/dict_free.html#abstract","text":"Free a hashtable","title":"Abstract"},{"location":"opcodes/dict_free.html#description","text":"frees the hashtable either at init time or at the end of the note (similar to ftfree) A dict can only be freed if it was created as global (see dict_new ). To be able to pass a dict between notes, a note can create a global dict and pass its handle to another note. When the first note is released, the dict lives on (because it is global), and it will be either freed at the end of the performance or explicitely by calling dict_free dict_free executes only at init time .","title":"Description"},{"location":"opcodes/dict_free.html#syntax","text":"dict_free idict [, iwhen=0]","title":"Syntax"},{"location":"opcodes/dict_free.html#arguments","text":"idict : the handle of the dict to be freed iwhen : similar to ftfree if iwhen == 0 : free the dict now if iwhen == 1 : free the dict at the end of this note","title":"Arguments"},{"location":"opcodes/dict_free.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/dict_free.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_free.html#see-also","text":"dict_new","title":"See also"},{"location":"opcodes/dict_free.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_get.html","text":"dict_get Abstract Get a value from a hashtable Description A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_get returns the value for a given key. If the key is not present, a default value is returned (the empty string for string values, or an user given default for number values) Syntax kvalue dict_get idict, Skeym [idefault=0] kvalue dict_get idict, kkey, [idefault=0] Svalue dict_get idict, Skey Svalue dict_get idict, kkey The type of key and value depend on the type definition of the dict , see dict_new dict_get executes both at i-time and k-time . Arguments \u00ecdict : the handle of the dict, as returned by dict_new Skey / kkey : the key to be queries, as previously set by dict_set idefault : if the key is not present, this value is returned (defaults to 0) Output kvalue / Svalue : the value corresponding to the key, or a default if the key is not found For dicts with a string value, an empty string is returned when the key is not found. For dicts with a numeric value, a user given default is returned (default=0) Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > < CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > /* # Example file for the dict_ opcode family A dict is a hashtable, mapping a string or an integer key to a string or float value. The type of the key and value are set at creation time and can't be modified later on The lifespan of a dict can be attached to the instr it was created in, or it can be global, in which case it lives until the end of the performance, or until it is explicitely destroyed (see dict_free) A dict is identified by a handler, which is an integer value, and thus can be passed around between intruments, the handlers can be part of other structures, like arrays or other dicts, etc. # Opcodes ## dict_new ihandle dict_new Stype [, iglobal=0, key, value, key, value, ...] Creates a new dictionary, either local to the instr or global Stype: a string identifying the types of key and value. \"ss\" : string -> string \"sf\" : string -> float \"is\" : int -> string \"if\" : int -> float iglobal: if 1, the dict is global and lives until the end of the performance, or until explicitely destroyed by dict_free Optionally the dict can be populated at creation time with a series of key:value pairs ## dict_free dict_free idict [, iwhen=0] frees the hashtable either at init time or at the end of the note (similar to ftfree) This is needed when passing a dict from one instrument to another * iwhen = 0, free now * iwhen = 1, free at the end of this note ## dict_set dict_set idict, Skey, kvalue ; k-time dict_set idict, kkey, kvalue ; k-time dict_set idict, ikey, ivalue ; i-time Set a key:value pair idict dict_new \"sf\" dict_set idict, \"key\", kvalue Without a value, deletes the key:value pair ## dict_get kvalue dict_get idict, \"key\" [, kdefault=0] Get the value at a given key. For string values, an empty string is returned when the key is not found. For int values, a default value given by the user is returned when the key is not found. ## dict_print dict_print ihandle, [ktrig] Prints the contents of the dict, either at i-time if no trigger is given, or at k-time whenever ktrig is possitive and different from the last value. Use -1 to print at every k-cycle. NB: All opcodes work at k-tim. The hashtables with int-keys work also at i-time whenever key and value are of i-type (for both set and get actions) */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve teh value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, mapping strings to strings i dict2 dict_new \"ss\" dict_set i dict2 , \"baz\" , \"bazvalue\" dict_set i dict2 , \"hoo\" , \"hoovalue\" S baz dict_get i dict2 , \"baz\" S hoo dict_get i dict2 , \"hoo\" printf \">>>> baz: %s , hoo: %s \\n \" , 1 , S baz , S hoo turnoff endin instr 2 ;; set and get if timeinstk () > 1 kgoto perf ;; this starts at 1 i maxcnt = 100 i dict dict_new \"ss\" k cnt = 0 while k cnt < i maxcnt do S key sprintfk \"key_ %d \" , k cnt S value sprintfk \"value_ %d \" , k cnt dict_set i dict , S key , S value k cnt += 1 od perf : k cnt = 0 while k cnt < i maxcnt do S key sprintfk \"key_ %d \" , k cnt ; the same for get, the key can change at k-time S value dict_get i dict , S key printf \"key: %s , value: %s \\n \" , k cnt , S key , S value k cnt += 1 od endin instr 3 /* dict_iter xkey, xvalue, kidx dict_iter ihandle [,kreset=1] kidx: holds the number of pairs yielded since last reset. It is set to -1 when iteration has stopped (in this case, xkey and xvalue are invalid and should not be used) kreset = 0 -> after iterating over all pairs iteration stops In this mode, iteration happens at most once 1 -> iteration starts over every k-cycle 2 -> iteration restarts after stopping */ k t timeinstk if k t > 1 kgoto perf i dict dict_new \"sf\" dict_set i dict , \"foo\" , 1 dict_set i dict , \"bar\" , 2 dict_set i dict , \"baz\" , 15 dict_set i dict , \"bee\" , 9 perf : ; iterate with a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"while) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value od ; the same but with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"loop) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value kgoto loop break : endin instr 4 ; test deleting a key ; ~~~~~~~~~~~~~~~~~~~ i dict dict_new \"ss\" ; set a key:value pair dict_set i dict , \"foo\" , \"foovalue\" ; get the value, print it S foo dict_get i dict , \"foo\" printf \"key: foo value: %s \\n \" , 1 , S foo ; dict_set without value deletes the key:value pair dict_set i dict , \"foo\" ; now check that the pair is gone S foo dict_get i dict , \"foo\" if ( strlen ( S foo ) == 0 ) then printf \"key does not exist \\n \" , 1 endif turnoff endin instr 5 ; dicts can be passed between instruments ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ if timeinstk () > 1 goto perf ; create a dict which survives this note i dict1 dict_new \"sf\" , 1 ; set some initial values once dict_set i dict1 , \"foo\" , 1 dict_set i dict1 , \"bar\" , 2 ; launch instr 6, which will outlive this note, pass idict as p4 event \"i\" , \"midifydict\" , 0 , p3 + 1 , i dict1 perf : k foo dict_get i dict1 , \"foo\" printk2 k foo endin instr modifydict ; here we modify instr 5's dictionary ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; the dict was created by instr 5 i dict = p4 k foo line 0 , p3 - 1 , 10 dict_set i dict , \"foo\" , k foo dict_free i dict , 1 ; 1 = free dict when note ends endin instr 7 ; it is possible to create a new dict and set initial ; values at once. This is only executed at i-time i dict dict_new \"sf\" , 0 , \"foo\" , 10 , \"bar\" , 20 , \"baz\" , 30 k baz dict_get i dict , \"baz\" k bar dict_get i dict , \"bar\" k xx dict_get i dict , \"xx\" , 99 printf \"baz: %f bar: %f xx: %f \\n \" , 1 , k baz , k bar , k xx turnoff endin instr 8 ; get all the keys as an array i dict1 dict_new \"sf\" , 0 , \"keyA\" , 1 , \"keyB\" , 2 , \"keyC\" , 3 S Keys [] dict_query i dict1 , \"keys\" printarray S Keys i dict2 dict_new \"if\" , 0 , 1 , 100 , 10 , 1000 , 2 , 200 k Keys [] dict_query i dict2 , \"keys\" printarray k Keys , 1 , \" %.0f \" ; get values as an array i dict3 dict_new \"is\" , 0 , 10 , \"foo\" , 20 , \"bar\" , 30 , \"baz\" S vals [] dict_query i dict3 , \"values\" printarray S vals k Vals [] dict_query i dict2 , \"values\" printarray k Vals turnoff endin ; One convenient use of dicts is to pass arguments to an instr instr 100 ; create our communication dict, set initial values i dict dict_new \"sf\" , 0 , \"amp\" , 0.1 , \"freq\" , 1000 ; the launched instr will last longer, so will have to deal with ; this dict ceasing to exist event_i \"i\" , 101 , 0 , p3 + 1 , i dict ; now we can control the synth with the dict dict_set i dict , \"freq\" , linseg : k ( 440 , p3 , 455 ) a 0 oscili 0.1 , 440 outch 1 , a 0 endin ; a variation on dict_get where we either get the value corresponding to a key, ; or the last value, if the dict does not exist opcode dict_receive , k , iSi i dict , S key , i val0 xin k last init i val0 if ( dict_size ( i dict ) > 0 ) then k val dict_get i dict , S key , i val0 k last = k val else k val = k last endif xout k val endop instr 101 i dict = p4 ; get the value for a given key. when the dict does not exist, just ; outputs the last value k amp dict_receive i dict , \"amp\" , 0.1 k freq dict_receive i dict , \"freq\" , 1000 a 0 oscili k amp , k freq outch 2 , a 0 endin </ CsInstruments > < CsScore > ; i 1 0 0.01 ; i 2 0 0.01 i 8 0 0.1 i 100 0 10 f 0 1 </ CsScore > </ CsoundSynthesizer > See also dict_new dict_set Credits Eduardo Moguillansky, 2019","title":"dict_get"},{"location":"opcodes/dict_get.html#dict_get","text":"","title":"dict_get"},{"location":"opcodes/dict_get.html#abstract","text":"Get a value from a hashtable","title":"Abstract"},{"location":"opcodes/dict_get.html#description","text":"A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_get returns the value for a given key. If the key is not present, a default value is returned (the empty string for string values, or an user given default for number values)","title":"Description"},{"location":"opcodes/dict_get.html#syntax","text":"kvalue dict_get idict, Skeym [idefault=0] kvalue dict_get idict, kkey, [idefault=0] Svalue dict_get idict, Skey Svalue dict_get idict, kkey The type of key and value depend on the type definition of the dict , see dict_new dict_get executes both at i-time and k-time .","title":"Syntax"},{"location":"opcodes/dict_get.html#arguments","text":"\u00ecdict : the handle of the dict, as returned by dict_new Skey / kkey : the key to be queries, as previously set by dict_set idefault : if the key is not present, this value is returned (defaults to 0)","title":"Arguments"},{"location":"opcodes/dict_get.html#output","text":"kvalue / Svalue : the value corresponding to the key, or a default if the key is not found For dicts with a string value, an empty string is returned when the key is not found. For dicts with a numeric value, a user given default is returned (default=0)","title":"Output"},{"location":"opcodes/dict_get.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/dict_get.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > < CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > /* # Example file for the dict_ opcode family A dict is a hashtable, mapping a string or an integer key to a string or float value. The type of the key and value are set at creation time and can't be modified later on The lifespan of a dict can be attached to the instr it was created in, or it can be global, in which case it lives until the end of the performance, or until it is explicitely destroyed (see dict_free) A dict is identified by a handler, which is an integer value, and thus can be passed around between intruments, the handlers can be part of other structures, like arrays or other dicts, etc. # Opcodes ## dict_new ihandle dict_new Stype [, iglobal=0, key, value, key, value, ...] Creates a new dictionary, either local to the instr or global Stype: a string identifying the types of key and value. \"ss\" : string -> string \"sf\" : string -> float \"is\" : int -> string \"if\" : int -> float iglobal: if 1, the dict is global and lives until the end of the performance, or until explicitely destroyed by dict_free Optionally the dict can be populated at creation time with a series of key:value pairs ## dict_free dict_free idict [, iwhen=0] frees the hashtable either at init time or at the end of the note (similar to ftfree) This is needed when passing a dict from one instrument to another * iwhen = 0, free now * iwhen = 1, free at the end of this note ## dict_set dict_set idict, Skey, kvalue ; k-time dict_set idict, kkey, kvalue ; k-time dict_set idict, ikey, ivalue ; i-time Set a key:value pair idict dict_new \"sf\" dict_set idict, \"key\", kvalue Without a value, deletes the key:value pair ## dict_get kvalue dict_get idict, \"key\" [, kdefault=0] Get the value at a given key. For string values, an empty string is returned when the key is not found. For int values, a default value given by the user is returned when the key is not found. ## dict_print dict_print ihandle, [ktrig] Prints the contents of the dict, either at i-time if no trigger is given, or at k-time whenever ktrig is possitive and different from the last value. Use -1 to print at every k-cycle. NB: All opcodes work at k-tim. The hashtables with int-keys work also at i-time whenever key and value are of i-type (for both set and get actions) */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve teh value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, mapping strings to strings i dict2 dict_new \"ss\" dict_set i dict2 , \"baz\" , \"bazvalue\" dict_set i dict2 , \"hoo\" , \"hoovalue\" S baz dict_get i dict2 , \"baz\" S hoo dict_get i dict2 , \"hoo\" printf \">>>> baz: %s , hoo: %s \\n \" , 1 , S baz , S hoo turnoff endin instr 2 ;; set and get if timeinstk () > 1 kgoto perf ;; this starts at 1 i maxcnt = 100 i dict dict_new \"ss\" k cnt = 0 while k cnt < i maxcnt do S key sprintfk \"key_ %d \" , k cnt S value sprintfk \"value_ %d \" , k cnt dict_set i dict , S key , S value k cnt += 1 od perf : k cnt = 0 while k cnt < i maxcnt do S key sprintfk \"key_ %d \" , k cnt ; the same for get, the key can change at k-time S value dict_get i dict , S key printf \"key: %s , value: %s \\n \" , k cnt , S key , S value k cnt += 1 od endin instr 3 /* dict_iter xkey, xvalue, kidx dict_iter ihandle [,kreset=1] kidx: holds the number of pairs yielded since last reset. It is set to -1 when iteration has stopped (in this case, xkey and xvalue are invalid and should not be used) kreset = 0 -> after iterating over all pairs iteration stops In this mode, iteration happens at most once 1 -> iteration starts over every k-cycle 2 -> iteration restarts after stopping */ k t timeinstk if k t > 1 kgoto perf i dict dict_new \"sf\" dict_set i dict , \"foo\" , 1 dict_set i dict , \"bar\" , 2 dict_set i dict , \"baz\" , 15 dict_set i dict , \"bee\" , 9 perf : ; iterate with a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"while) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value od ; the same but with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"loop) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value kgoto loop break : endin instr 4 ; test deleting a key ; ~~~~~~~~~~~~~~~~~~~ i dict dict_new \"ss\" ; set a key:value pair dict_set i dict , \"foo\" , \"foovalue\" ; get the value, print it S foo dict_get i dict , \"foo\" printf \"key: foo value: %s \\n \" , 1 , S foo ; dict_set without value deletes the key:value pair dict_set i dict , \"foo\" ; now check that the pair is gone S foo dict_get i dict , \"foo\" if ( strlen ( S foo ) == 0 ) then printf \"key does not exist \\n \" , 1 endif turnoff endin instr 5 ; dicts can be passed between instruments ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ if timeinstk () > 1 goto perf ; create a dict which survives this note i dict1 dict_new \"sf\" , 1 ; set some initial values once dict_set i dict1 , \"foo\" , 1 dict_set i dict1 , \"bar\" , 2 ; launch instr 6, which will outlive this note, pass idict as p4 event \"i\" , \"midifydict\" , 0 , p3 + 1 , i dict1 perf : k foo dict_get i dict1 , \"foo\" printk2 k foo endin instr modifydict ; here we modify instr 5's dictionary ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; the dict was created by instr 5 i dict = p4 k foo line 0 , p3 - 1 , 10 dict_set i dict , \"foo\" , k foo dict_free i dict , 1 ; 1 = free dict when note ends endin instr 7 ; it is possible to create a new dict and set initial ; values at once. This is only executed at i-time i dict dict_new \"sf\" , 0 , \"foo\" , 10 , \"bar\" , 20 , \"baz\" , 30 k baz dict_get i dict , \"baz\" k bar dict_get i dict , \"bar\" k xx dict_get i dict , \"xx\" , 99 printf \"baz: %f bar: %f xx: %f \\n \" , 1 , k baz , k bar , k xx turnoff endin instr 8 ; get all the keys as an array i dict1 dict_new \"sf\" , 0 , \"keyA\" , 1 , \"keyB\" , 2 , \"keyC\" , 3 S Keys [] dict_query i dict1 , \"keys\" printarray S Keys i dict2 dict_new \"if\" , 0 , 1 , 100 , 10 , 1000 , 2 , 200 k Keys [] dict_query i dict2 , \"keys\" printarray k Keys , 1 , \" %.0f \" ; get values as an array i dict3 dict_new \"is\" , 0 , 10 , \"foo\" , 20 , \"bar\" , 30 , \"baz\" S vals [] dict_query i dict3 , \"values\" printarray S vals k Vals [] dict_query i dict2 , \"values\" printarray k Vals turnoff endin ; One convenient use of dicts is to pass arguments to an instr instr 100 ; create our communication dict, set initial values i dict dict_new \"sf\" , 0 , \"amp\" , 0.1 , \"freq\" , 1000 ; the launched instr will last longer, so will have to deal with ; this dict ceasing to exist event_i \"i\" , 101 , 0 , p3 + 1 , i dict ; now we can control the synth with the dict dict_set i dict , \"freq\" , linseg : k ( 440 , p3 , 455 ) a 0 oscili 0.1 , 440 outch 1 , a 0 endin ; a variation on dict_get where we either get the value corresponding to a key, ; or the last value, if the dict does not exist opcode dict_receive , k , iSi i dict , S key , i val0 xin k last init i val0 if ( dict_size ( i dict ) > 0 ) then k val dict_get i dict , S key , i val0 k last = k val else k val = k last endif xout k val endop instr 101 i dict = p4 ; get the value for a given key. when the dict does not exist, just ; outputs the last value k amp dict_receive i dict , \"amp\" , 0.1 k freq dict_receive i dict , \"freq\" , 1000 a 0 oscili k amp , k freq outch 2 , a 0 endin </ CsInstruments > < CsScore > ; i 1 0 0.01 ; i 2 0 0.01 i 8 0 0.1 i 100 0 10 f 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_get.html#see-also","text":"dict_new dict_set","title":"See also"},{"location":"opcodes/dict_get.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_iter.html","text":"dict_iter Abstract Iterate over the key-value pairs of a dict Description Iterates over the key:value pairs. Whenever kreset is 1, iteration starts over If kreset is -1 (the default), iteration is autotriggered when it reaches the end of the collection. dict_loop executes only at Performance Time . Note dict_iter is meant to be used in a loop at k-time Syntax xkey, xvalue, kidx dict_iter idict [, kreset = -1] Arguments idict : the handle to the dict as returned by dict_new kreset : the reset policy kreset effect 0 no reset, iteration stops at the end of the collection. There will be at most 1 iteration 1 (default) Iteration starts over at every k-cycle 2 Reset at the end of iteration (independent of k-cycle) Output xkey / xvalue : the key and value for this pair. The types are determined by the type of this dict, as defined via dict_new kidx : the index of this pair. It will be 0 for the first pair, 1 for the second, etc. When no more pairs, kidx will be -1. In this case, xkey and xvalue do not hold valid values Execution time Performance Usage There are two ways to use dict_iter , either in a while loop, or using gotos ; iterate in a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"key: %s value: %f \" , k idx , S key , k value od ; iterate with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"key: %s value: %f \" , k idx , S key , k value kgoto loop break : Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* # Example file for dict_iter opcode */ instr 1 /* dict_iter xkey, xvalue, kidx dict_iter ihandle [,kreset=1] kidx: holds the number of pairs yielded since last reset. It is set to -1 when iteration has stopped (in this case, xkey and xvalue are invalid and should not be used) kreset = 0 -> after iterating over all pairs iteration stops In this mode, iteration happens at most once 1 -> iteration starts over every k-cycle 2 -> iteration restarts after stopping */ i dict dict_new \"str:float\" , 0 , \"foo\" , 1 , \"bar\" , 2 , \"baz\" , 15 , \"bee\" , 9 k t timeinstk ; iterate with a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"while) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value od ; the same but with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"loop) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value kgoto loop break : endin </ CsInstruments > < CsScore > i 1 0 0.05 </ CsScore > </ CsoundSynthesizer > See also dict_new dict_size Credits Eduardo Moguillansky, 2019","title":"dict_iter"},{"location":"opcodes/dict_iter.html#dict_iter","text":"","title":"dict_iter"},{"location":"opcodes/dict_iter.html#abstract","text":"Iterate over the key-value pairs of a dict","title":"Abstract"},{"location":"opcodes/dict_iter.html#description","text":"Iterates over the key:value pairs. Whenever kreset is 1, iteration starts over If kreset is -1 (the default), iteration is autotriggered when it reaches the end of the collection. dict_loop executes only at Performance Time . Note dict_iter is meant to be used in a loop at k-time","title":"Description"},{"location":"opcodes/dict_iter.html#syntax","text":"xkey, xvalue, kidx dict_iter idict [, kreset = -1]","title":"Syntax"},{"location":"opcodes/dict_iter.html#arguments","text":"idict : the handle to the dict as returned by dict_new kreset : the reset policy kreset effect 0 no reset, iteration stops at the end of the collection. There will be at most 1 iteration 1 (default) Iteration starts over at every k-cycle 2 Reset at the end of iteration (independent of k-cycle)","title":"Arguments"},{"location":"opcodes/dict_iter.html#output","text":"xkey / xvalue : the key and value for this pair. The types are determined by the type of this dict, as defined via dict_new kidx : the index of this pair. It will be 0 for the first pair, 1 for the second, etc. When no more pairs, kidx will be -1. In this case, xkey and xvalue do not hold valid values","title":"Output"},{"location":"opcodes/dict_iter.html#execution-time","text":"Performance","title":"Execution time"},{"location":"opcodes/dict_iter.html#usage","text":"There are two ways to use dict_iter , either in a while loop, or using gotos ; iterate in a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"key: %s value: %f \" , k idx , S key , k value od ; iterate with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"key: %s value: %f \" , k idx , S key , k value kgoto loop break :","title":"Usage"},{"location":"opcodes/dict_iter.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* # Example file for dict_iter opcode */ instr 1 /* dict_iter xkey, xvalue, kidx dict_iter ihandle [,kreset=1] kidx: holds the number of pairs yielded since last reset. It is set to -1 when iteration has stopped (in this case, xkey and xvalue are invalid and should not be used) kreset = 0 -> after iterating over all pairs iteration stops In this mode, iteration happens at most once 1 -> iteration starts over every k-cycle 2 -> iteration restarts after stopping */ i dict dict_new \"str:float\" , 0 , \"foo\" , 1 , \"bar\" , 2 , \"baz\" , 15 , \"bee\" , 9 k t timeinstk ; iterate with a while loop k idx = 0 while k idx < dict_size ( i dict ) - 1 do S key , k value , k idx dict_iter i dict printf \"while) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value od ; the same but with goto loop : S key , k value , k idx dict_iter i dict if k idx == - 1 goto break printf \"loop) %s -> %f \\n \" , k idx + k t * 1000 , S key , k value kgoto loop break : endin </ CsInstruments > < CsScore > i 1 0 0.05 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_iter.html#see-also","text":"dict_new dict_size","title":"See also"},{"location":"opcodes/dict_iter.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_new.html","text":"dict_new Abstract Create a hashtable Description A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. A hashtable can be either local, in which case its lifespan is fixed to the lifespan of the note it was created in; or it can be global, in which case it is not deallocated when the note is released and is kept alive until either the end of the performance, or until freed via dict_free dict_new runs only at i-time Syntax idict dict_new Stype [, isglobal=0] idict dict_new Stype, isglobal, key0, value0, key1, value1, ... dict_new executes only at init time . NB : With the second variant it is possible to create a dict and give it initial values at init-time. Arguments Stype : a string describing the type of the key and the value. Possible values are: \"sf\" or \"str:float\": string \u2192 float \"ss\" or \"str:str\": string \u2192 string \"is\" or \"\u00ecnt:str\": int \u2192 string \"if\" or \"int:float\": int \u2192 float isglobal : if 1, the dict will outlive the instrument it was created in and will stay active until either the end of the performance or if destroyed via dict_free . Default is 0 (local) key0 , value0 , etc: initial pairs can be set at creation time, matching the types declared with Stype Output idict : identifies this dict with an integer. This integer can be passed around to another instrument and will always resolve to the same dict, as long as this dict is still alive. This can be checked via dict_query idict, \"exists\" Execution Time Init Examples < CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > See also dict_free dict_set Credits","title":"dict_new"},{"location":"opcodes/dict_new.html#dict_new","text":"","title":"dict_new"},{"location":"opcodes/dict_new.html#abstract","text":"Create a hashtable","title":"Abstract"},{"location":"opcodes/dict_new.html#description","text":"A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. A hashtable can be either local, in which case its lifespan is fixed to the lifespan of the note it was created in; or it can be global, in which case it is not deallocated when the note is released and is kept alive until either the end of the performance, or until freed via dict_free dict_new runs only at i-time","title":"Description"},{"location":"opcodes/dict_new.html#syntax","text":"idict dict_new Stype [, isglobal=0] idict dict_new Stype, isglobal, key0, value0, key1, value1, ... dict_new executes only at init time . NB : With the second variant it is possible to create a dict and give it initial values at init-time.","title":"Syntax"},{"location":"opcodes/dict_new.html#arguments","text":"Stype : a string describing the type of the key and the value. Possible values are: \"sf\" or \"str:float\": string \u2192 float \"ss\" or \"str:str\": string \u2192 string \"is\" or \"\u00ecnt:str\": int \u2192 string \"if\" or \"int:float\": int \u2192 float isglobal : if 1, the dict will outlive the instrument it was created in and will stay active until either the end of the performance or if destroyed via dict_free . Default is 0 (local) key0 , value0 , etc: initial pairs can be set at creation time, matching the types declared with Stype","title":"Arguments"},{"location":"opcodes/dict_new.html#output","text":"idict : identifies this dict with an integer. This integer can be passed around to another instrument and will always resolve to the same dict, as long as this dict is still alive. This can be checked via dict_query idict, \"exists\"","title":"Output"},{"location":"opcodes/dict_new.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/dict_new.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_new.html#see-also","text":"dict_free dict_set","title":"See also"},{"location":"opcodes/dict_new.html#credits","text":"","title":"Credits"},{"location":"opcodes/dict_print.html","text":"dict_print Abstract Prints the contents of a dict Description dict_print can be used to print the contents of a dict, mostly for debugging purposes dict_print can print both at i-time or k-time Syntax dict_print idict [, ktrig=1] Arguments \u00ecdict : the handle of the dict, as returned by dict_new ktrig : when to print the dict. Printing will take place whenever ktrig is -1 or if ktrig is a positive and higher than the last trig Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" , \"foo\" , 10 , \"bar\" , 20 , \"baz\" , 30 print_dict i dict , 1 ; print with a metro i dict2 dict_new \"ss\" , \"foo\" , \"foofoo\" , \"bar\" , \"barbar\" , \"baz\" , \"bazbaz\" k trig metro 2 print_dict i dict2 , k trig turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer > See also dict_iter dict_set dict_query Credits Eduardo Moguillansky, 2019","title":"dict_print"},{"location":"opcodes/dict_print.html#dict_print","text":"","title":"dict_print"},{"location":"opcodes/dict_print.html#abstract","text":"Prints the contents of a dict","title":"Abstract"},{"location":"opcodes/dict_print.html#description","text":"dict_print can be used to print the contents of a dict, mostly for debugging purposes dict_print can print both at i-time or k-time","title":"Description"},{"location":"opcodes/dict_print.html#syntax","text":"dict_print idict [, ktrig=1]","title":"Syntax"},{"location":"opcodes/dict_print.html#arguments","text":"\u00ecdict : the handle of the dict, as returned by dict_new ktrig : when to print the dict. Printing will take place whenever ktrig is -1 or if ktrig is a positive and higher than the last trig","title":"Arguments"},{"location":"opcodes/dict_print.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/dict_print.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" , \"foo\" , 10 , \"bar\" , 20 , \"baz\" , 30 print_dict i dict , 1 ; print with a metro i dict2 dict_new \"ss\" , \"foo\" , \"foofoo\" , \"bar\" , \"barbar\" , \"baz\" , \"bazbaz\" k trig metro 2 print_dict i dict2 , k trig turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_print.html#see-also","text":"dict_iter dict_set dict_query","title":"See also"},{"location":"opcodes/dict_print.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_query.html","text":"dict_query Abstract Query different properties of a dict Description Properties of a dict which do not need a separate opcode (because they are not used very frequently) are merged togehter in this opcode. Possible properties are: exists : return 1 if the handle points to a valid dict size : returns the size of this dict (similar to dict_size) type : returns an integer identifying the type of this dict 11 : number -> number 12 : number -> string 21 : string -> number 22 : string -> string keys : returns an array with all the keys defined in this dict (the type of the returned array depends on the type of the keys) values : returns an array with all the values (the type of the returned array depends on the type of the values). NB : the order in which keys and values are returned represents the corresponding pairs, so keys[i] and values[i] belong to the same pair. dict_query executes at k-time . Syntax kexists dict_query idict, \"exists\" ksize dict_query idict, \"size\" ktype dict_query idict, \"type\" SKeys[] dict_query idict, \"keys\" kKeys[] dict_query idict, \"keys\" kValues[] dict_query idict, \"values\" SValues[] dict_query idict, \"values\" Arguments idict : the handle of the dict, as returned by dict_new Output NB : the arrays returned from keys and values can have either an S- or a k-type, depending on the type definition of the array Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for dict_query ... dict_query idict, Scmd where Scmd can be: 'size', 'type', 'exists', 'keys', 'values' */ instr 1 ; get all the keys as an array i dict1 dict_new \"sf\" , 0 , \"keyA\" , 1 , \"keyB\" , 2 , \"keyC\" , 3 ; check that the dict exists k exists dict_query i dict1 , \"exists\" k type dict_query i dict1 , \"type\" printf \"dict exists = %d , type = %d \\n \" , 1 , k exists , k type S Keys [] dict_query i dict1 , \"keys\" printarray S Keys ; now check a bogus handle k exists999 dict_query 999 , \"exists\" printf \"dict 999 exists = %d \\n \" , 1 , k exists999 ; get the keys from a different dict i dict2 dict_new \"if\" , 0 , 1 , 100 , 10 , 1000 , 2 , 200 k Keys [] dict_query i dict2 , \"keys\" printarray k Keys , 1 , \" %.0f \" printf \"idict2 has size= %d \\n \" , 1 , dict_query ( i dict2 , \"size\" ) ; get values as an array i dict3 dict_new \"is\" , 0 , 10 , \"foo\" , 20 , \"bar\" , 30 , \"baz\" S vals [] dict_query i dict3 , \"values\" printarray S vals k Vals [] dict_query i dict2 , \"values\" printarray k Vals ; query the type of the dict k type dict_query i dict2 , \"type\" printf \"the type of dict %d is %d \\n \" , 1 , i dict2 , k type turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 </ CsScore > </ CsoundSynthesizer > See also dict_iter dict_size Credits Eduardo Moguillansky, 2019","title":"dict_query"},{"location":"opcodes/dict_query.html#dict_query","text":"","title":"dict_query"},{"location":"opcodes/dict_query.html#abstract","text":"Query different properties of a dict","title":"Abstract"},{"location":"opcodes/dict_query.html#description","text":"Properties of a dict which do not need a separate opcode (because they are not used very frequently) are merged togehter in this opcode. Possible properties are: exists : return 1 if the handle points to a valid dict size : returns the size of this dict (similar to dict_size) type : returns an integer identifying the type of this dict 11 : number -> number 12 : number -> string 21 : string -> number 22 : string -> string keys : returns an array with all the keys defined in this dict (the type of the returned array depends on the type of the keys) values : returns an array with all the values (the type of the returned array depends on the type of the values). NB : the order in which keys and values are returned represents the corresponding pairs, so keys[i] and values[i] belong to the same pair. dict_query executes at k-time .","title":"Description"},{"location":"opcodes/dict_query.html#syntax","text":"kexists dict_query idict, \"exists\" ksize dict_query idict, \"size\" ktype dict_query idict, \"type\" SKeys[] dict_query idict, \"keys\" kKeys[] dict_query idict, \"keys\" kValues[] dict_query idict, \"values\" SValues[] dict_query idict, \"values\"","title":"Syntax"},{"location":"opcodes/dict_query.html#arguments","text":"idict : the handle of the dict, as returned by dict_new","title":"Arguments"},{"location":"opcodes/dict_query.html#output","text":"NB : the arrays returned from keys and values can have either an S- or a k-type, depending on the type definition of the array","title":"Output"},{"location":"opcodes/dict_query.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/dict_query.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Example file for dict_query ... dict_query idict, Scmd where Scmd can be: 'size', 'type', 'exists', 'keys', 'values' */ instr 1 ; get all the keys as an array i dict1 dict_new \"sf\" , 0 , \"keyA\" , 1 , \"keyB\" , 2 , \"keyC\" , 3 ; check that the dict exists k exists dict_query i dict1 , \"exists\" k type dict_query i dict1 , \"type\" printf \"dict exists = %d , type = %d \\n \" , 1 , k exists , k type S Keys [] dict_query i dict1 , \"keys\" printarray S Keys ; now check a bogus handle k exists999 dict_query 999 , \"exists\" printf \"dict 999 exists = %d \\n \" , 1 , k exists999 ; get the keys from a different dict i dict2 dict_new \"if\" , 0 , 1 , 100 , 10 , 1000 , 2 , 200 k Keys [] dict_query i dict2 , \"keys\" printarray k Keys , 1 , \" %.0f \" printf \"idict2 has size= %d \\n \" , 1 , dict_query ( i dict2 , \"size\" ) ; get values as an array i dict3 dict_new \"is\" , 0 , 10 , \"foo\" , 20 , \"bar\" , 30 , \"baz\" S vals [] dict_query i dict3 , \"values\" printarray S vals k Vals [] dict_query i dict2 , \"values\" printarray k Vals ; query the type of the dict k type dict_query i dict2 , \"type\" printf \"the type of dict %d is %d \\n \" , 1 , i dict2 , k type turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_query.html#see-also","text":"dict_iter dict_size","title":"See also"},{"location":"opcodes/dict_query.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_set.html","text":"dict_set Abstract Set (or remove) a value from a hashtable Description A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_set sets the value corresponding to a key if the key is already present, or inserts a key:value pair otherwise. NB : Without a value, dict_set deletes the key:value pair from the dict. dict_set executes can execute at i-time and k-time . Tip It is possible to set multiple values at i-time directly with dict_new Syntax dict_set idict, xkey, xvalue dict_set idict, xkey Arguments idict : the handle of the dict, as returned by dict_new xkey : the key to set. Its type must match the type definition of the dict. (a string or a possitive integer) xvalue : the value to set. Its type must match the type definition of the dict (a str or a numeric value) Note If xvalue is not given, dict_set removes the key from the dict Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer > See also dict_new dict_get Credits Eduardo Moguillansky, 2019","title":"dict_set"},{"location":"opcodes/dict_set.html#dict_set","text":"","title":"dict_set"},{"location":"opcodes/dict_set.html#abstract","text":"Set (or remove) a value from a hashtable","title":"Abstract"},{"location":"opcodes/dict_set.html#description","text":"A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_set sets the value corresponding to a key if the key is already present, or inserts a key:value pair otherwise. NB : Without a value, dict_set deletes the key:value pair from the dict. dict_set executes can execute at i-time and k-time . Tip It is possible to set multiple values at i-time directly with dict_new","title":"Description"},{"location":"opcodes/dict_set.html#syntax","text":"dict_set idict, xkey, xvalue dict_set idict, xkey","title":"Syntax"},{"location":"opcodes/dict_set.html#arguments","text":"idict : the handle of the dict, as returned by dict_new xkey : the key to set. Its type must match the type definition of the dict. (a string or a possitive integer) xvalue : the value to set. Its type must match the type definition of the dict (a str or a numeric value) Note If xvalue is not given, dict_set removes the key from the dict","title":"Arguments"},{"location":"opcodes/dict_set.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/dict_set.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac -iadc ;;;RT audio out and in </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 ; retrieve the value k bar dict_get i dict , \"bar\" ; get a non-existent key, will output the default k foo dict_get i dict , \"foo\" , - 1 printf \">>>> bar: %f , foo: %f \\n \" , 1 , k bar , k foo ; now create another dict, this one will outlive this note i dict2 dict_new \"ss\" , 1 , \"baz\" , \"bazvalue\" , \"foo\" , \"foovalue\" ; schedule another inst, pass this dict event \"i\" , 2 , 0 , 1 , i dict2 turnoff endin instr 2 i dict = p4 S baz = dict_get ( i dict , \"baz\" ) printf \"instr 2, kbaz = %s \\n \" , 1 , S baz ; free dict at the end of this note dict_free i dict , 1 turnoff endin ; schedule 1, 0, 1 </ CsInstruments > < CsScore > i 1 0 2 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_set.html#see-also","text":"dict_new dict_get","title":"See also"},{"location":"opcodes/dict_set.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/dict_size.html","text":"dict_size Abstract Returns the number of key:value pairs in a dict Description A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_size returns the number of such key:value pairs inside a dict. If the handle passed does not point to a valid dict, dict_size returns -1. It is thus possible to use it to check that the passed handle is valid (similar to dict_query idict \"exists\" , see dict_query ) dict_size can be used together with dict_iter to iterate over the key:value pairs Syntax isize dict_size idict ksize dict_size idict dict_size executes both at i-time and k-time . Arguments \u00ecdict : the handle of the dict, as returned by dict_new Output ksize : the number of key:value pairs in the dict Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size dict_set i dict , \"foo\" , 4 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size ; size does not change now dict_set i dict , \"foo\" , 10 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size ; we delete a key, size is reduced dict_set i dict , \"foo\" k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer > See also dict_iter dict_set Credits Eduardo Moguillansky, 2019","title":"dict_size"},{"location":"opcodes/dict_size.html#dict_size","text":"","title":"dict_size"},{"location":"opcodes/dict_size.html#abstract","text":"Returns the number of key:value pairs in a dict","title":"Abstract"},{"location":"opcodes/dict_size.html#description","text":"A hashtable is a mapping from a key to a value. The dict_ family of opcodes implement a hashtable mapping either strings or integers to strings or floats. dict_size returns the number of such key:value pairs inside a dict. If the handle passed does not point to a valid dict, dict_size returns -1. It is thus possible to use it to check that the passed handle is valid (similar to dict_query idict \"exists\" , see dict_query ) dict_size can be used together with dict_iter to iterate over the key:value pairs","title":"Description"},{"location":"opcodes/dict_size.html#syntax","text":"isize dict_size idict ksize dict_size idict dict_size executes both at i-time and k-time .","title":"Syntax"},{"location":"opcodes/dict_size.html#arguments","text":"\u00ecdict : the handle of the dict, as returned by dict_new","title":"Arguments"},{"location":"opcodes/dict_size.html#output","text":"ksize : the number of key:value pairs in the dict","title":"Output"},{"location":"opcodes/dict_size.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/dict_size.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 instr 1 ; create a local dict, mapping strings to numbers i dict dict_new \"sf\" ; set key a key:value pair dict_set i dict , \"bar\" , 123 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size dict_set i dict , \"foo\" , 4 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size ; size does not change now dict_set i dict , \"foo\" , 10 k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size ; we delete a key, size is reduced dict_set i dict , \"foo\" k size = dict_size ( i dict ) printf \"size: %d \" , 1 , k size turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/dict_size.html#see-also","text":"dict_iter dict_set","title":"See also"},{"location":"opcodes/dict_size.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/lfnoise.html","text":"lfnoise Abstract low frequency, band-limited noise Description Generates random values at a rate given by the nearest integer division of the sample rate by the freq argument. If kinterp==0, between generated values 0 is output. Otherwise the output is the result of interpolating between the generated values. Output is always band limited. Syntax aout lfnoise krate, kinterp=0 Arguments krate : the frequency to generate new values kinterp : if 1, the output is the result of linear interpolation between the generated values Output aout : if kinterp==0, then this is the output random values at the given frequency, or 0. If kinterp==1, then output is the result of interpolation between two generated values. Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 FLpanel \"lfnoise\" , 400 , 200 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 322 , 20 i disp2 FLvalue \"\" , 30 , 30 , 52 , 80 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk freq , i h1 FLslider \"freq\" , 0 , 200 , 0 , 3 , i disp1 , 300 , 30 , 20 , 20 gk interp , i h2 FLslider \"interp\" , 0 , 1 , 0 , 3 , i disp2 , 30 , 30 , 20 , 80 gk gain , i h3 FLslider \"gain\" , 0 , 1 , 0 , 3 , - 1 , 300 , 30 , 20 , 140 FLpanelEnd FLrun instr 1 a out lfnoise gk freq , gk interp a out *= interp ( gk gain ) outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer > See also dust2 crackle Credits Eduardo Moguillansky, 2019 (port of pd/else's lfnoise , which is itself a merge of supercollider's LFNoise0 and LFNoise1 )","title":"lfnoise"},{"location":"opcodes/lfnoise.html#lfnoise","text":"","title":"lfnoise"},{"location":"opcodes/lfnoise.html#abstract","text":"low frequency, band-limited noise","title":"Abstract"},{"location":"opcodes/lfnoise.html#description","text":"Generates random values at a rate given by the nearest integer division of the sample rate by the freq argument. If kinterp==0, between generated values 0 is output. Otherwise the output is the result of interpolating between the generated values. Output is always band limited.","title":"Description"},{"location":"opcodes/lfnoise.html#syntax","text":"aout lfnoise krate, kinterp=0","title":"Syntax"},{"location":"opcodes/lfnoise.html#arguments","text":"krate : the frequency to generate new values kinterp : if 1, the output is the result of linear interpolation between the generated values","title":"Arguments"},{"location":"opcodes/lfnoise.html#output","text":"aout : if kinterp==0, then this is the output random values at the given frequency, or 0. If kinterp==1, then output is the result of interpolation between two generated values.","title":"Output"},{"location":"opcodes/lfnoise.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/lfnoise.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 FLpanel \"lfnoise\" , 400 , 200 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 322 , 20 i disp2 FLvalue \"\" , 30 , 30 , 52 , 80 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk freq , i h1 FLslider \"freq\" , 0 , 200 , 0 , 3 , i disp1 , 300 , 30 , 20 , 20 gk interp , i h2 FLslider \"interp\" , 0 , 1 , 0 , 3 , i disp2 , 30 , 30 , 20 , 80 gk gain , i h3 FLslider \"gain\" , 0 , 1 , 0 , 3 , - 1 , 300 , 30 , 20 , 140 FLpanelEnd FLrun instr 1 a out lfnoise gk freq , gk interp a out *= interp ( gk gain ) outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/lfnoise.html#see-also","text":"dust2 crackle","title":"See also"},{"location":"opcodes/lfnoise.html#credits","text":"Eduardo Moguillansky, 2019 (port of pd/else's lfnoise , which is itself a merge of supercollider's LFNoise0 and LFNoise1 )","title":"Credits"},{"location":"opcodes/poly.html","text":"poly Abstract poly creates and controls multiple parallel version of an opcode Description poly creates a user given number of instances of an opcode, each with its own state, inputs and outputs. The resulting output is an array where each element holds the output of the corresponding instance. In general, an opcode has a signature, given by the number and types of its output and input arguments. For example, the opcode oscili as used like aout oscili kamp, kfreq has a signature a / kk ( a as output, kk as input). To follow this example, to create 10 parallel versions of this opcode (an oscillator bank) it is possible to use poly like this: k Freqs [] fillarray 100 , 110 , 200 , 220 , 300 , 330 , 400 , 440 , 500 , 550 a Out [] poly 10 , \"oscili\" , 0.1 , k Freqs Notice that it is possible to set one value for each instance, as given by kFreqs , or one value to be shared by all instances, as given by the amplitude 0.1 . By changing the array kFreqs it is possible to modify the frequency of each oscillator. It is of course possible to chain multiple poly s to generate complex effect chains, and poly can also be used with k-values. NB : At the moment poly works only with builtin opcodes . This might change in the future Syntax out1[], [ out2[], ... ] poly inuminstances, Sopcode, xarg0, [xarg1, ...] Arguments inuminstances : the number of instances of Sopcode to instantiate Sopcode : the name of the opcode xargs : any number of arguments, either i-, k- or a-rate, either scalar or arrays, or strings, as needed by the given opcode. String arrays are not yet supported The number and type of the input arguments depend on the arguments passed to the given opcode. The same applies for the output arguments NB : output arguments are always arrays, input arguments can be arrays, in which case they must be at least the size of inuminstances , or scalars, in which case the same value is shared by multiple instances Output The output is one or more arrays of k- or a-type, corresponding to the opcode. For instance, an opcode like aout oscili 0.1, kfreq will output an array of audio channels. An opcode like pan2 will output two audio arrays. Examples LISTEN < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 0dbfs = 1 ; create an array of random values between 0-1 ; inum: number of elements in the array opcode rndarr , i[] , i i num xin i Out [] init i num i 0 = 0 while i 0 < i num do i Out [ i 0 ] = unirand ( 1 ) i 0 += 1 od xout i Out endop ; multiple oscillators, mixed down to mono instr 1 ; number of oscillators i num = 100 ; fundamental k midi = line ( ntom : i ( \"2G\" ), p3 , ntom : i ( \"1C\" )) k f0 = mtof ( k midi ) ; each oscillator is an overtone of f0 k Ratios [] genarray_i 1 , i num ; harmonicity over time k exp line 1 , p3 , 1.32 ; the freq. of each oscillator k Freqs [] = ( k Ratios ^ k exp ) * k f0 ; array of random phases, to avoid synchronous start i Phs [] rndarr i num ; generate the oscillators. a Oscils [] poly i num , \"oscili\" , 1 / i num , k Freqs , - 1 , i Phs a mono sumarray a Oscils a mono *= linsegr : a ( 0 , 0.05 , 1 , 0.05 , 0 ) outs a mono , a mono endin ; poly instances stacked as a processing pipe instr 2 ; amount of polyphony i num = 30 i Freqs [] rndarr i num ; the ratios of the overtones k Ratios [] genarray_i 1 , i num ; a down gliss k m0 linseg ntom : i ( \"2C\" ), p3 * 0.8 , ntom : i ( \"1C\" ) k f0 = mtof ( k m0 ) ; harmonicity curve k p linsegb 1 , p3 * 0.8 , 1.68 ; calculate actual freqs. k Freqs [] = ( k Ratios ^ k p ) * k f0 ; lfo freqs. used for AM and panning k f linsegb 0.1 , p3 * 0.62 , 0.8 , p3 * 0.8 , 0.8 , p3 * 0.96 , 12 , p3 , 60 k LfoFreqs [] = i Freqs * k f ; multiple noise instances, amplitude modulated a A [] poly i num , \"noise\" , 0.5 , 0.3 a Amps [] poly i num , \"oscili\" , 1 , k LfoFreqs * 0.6 a A *= a Amps ; filter noise with bandpass k Q linsegb 0.5 , p3 * 0.5 , 0.02 , p3 , 0.0001 k Bands [] = k Freqs * k Q a B [] poly i num , \"resonr\" , a A , k Freqs , k Bands ; panning. poly works also with k-rate and with ; opcodes producing multiple outputs, like pan2 k PanPos [] poly i num , \"lfo\" , 0.5 , k LfoFreqs k PanPos += 0.5 ; lfo in the range 0-1 for panning a L [], a R [] poly i num , \"pan2\" , a B , k PanPos a left sumarray a L a right sumarray a R ; compress / fade a ref init 1 a sig = 0.707 * ( a left + a right ) a gain compress2 a ref , a sig , - 90 , - 48 , - 24 , 2.5 , 0.05 , 0.2 , 0.05 a left *= a gain a right *= a gain a gain2 compress2 a ref , ( a left + a right ) * 0.707 , - 90 , - 6 , - 3 , 20 , 0.002 , 0.010 , 0.02 a env = a gain2 * cossegr : a ( 0 , 1 , 1 , 0.1 , 0 ) outs a left * a env , a right * a env endin opcode test , a , k k freq xin a out oscili 0.1 , k freq xout a out endop instr 3 ; test udo k freqs [] fillarray 440 , 443 a A [] poly 2 , \"test\" , k freqs a 0 sumarray a A outs a 0 , a 0 endin </ CsInstruments > < CsScore > i 1 0 8 i 2 9 50 ; i 3 0 1 </ CsScore > </ CsoundSynthesizer > See also maparray polyseq Credits Eduardo Moguillansky, 2019","title":"poly"},{"location":"opcodes/poly.html#poly","text":"","title":"poly"},{"location":"opcodes/poly.html#abstract","text":"poly creates and controls multiple parallel version of an opcode","title":"Abstract"},{"location":"opcodes/poly.html#description","text":"poly creates a user given number of instances of an opcode, each with its own state, inputs and outputs. The resulting output is an array where each element holds the output of the corresponding instance. In general, an opcode has a signature, given by the number and types of its output and input arguments. For example, the opcode oscili as used like aout oscili kamp, kfreq has a signature a / kk ( a as output, kk as input). To follow this example, to create 10 parallel versions of this opcode (an oscillator bank) it is possible to use poly like this: k Freqs [] fillarray 100 , 110 , 200 , 220 , 300 , 330 , 400 , 440 , 500 , 550 a Out [] poly 10 , \"oscili\" , 0.1 , k Freqs Notice that it is possible to set one value for each instance, as given by kFreqs , or one value to be shared by all instances, as given by the amplitude 0.1 . By changing the array kFreqs it is possible to modify the frequency of each oscillator. It is of course possible to chain multiple poly s to generate complex effect chains, and poly can also be used with k-values. NB : At the moment poly works only with builtin opcodes . This might change in the future","title":"Description"},{"location":"opcodes/poly.html#syntax","text":"out1[], [ out2[], ... ] poly inuminstances, Sopcode, xarg0, [xarg1, ...]","title":"Syntax"},{"location":"opcodes/poly.html#arguments","text":"inuminstances : the number of instances of Sopcode to instantiate Sopcode : the name of the opcode xargs : any number of arguments, either i-, k- or a-rate, either scalar or arrays, or strings, as needed by the given opcode. String arrays are not yet supported The number and type of the input arguments depend on the arguments passed to the given opcode. The same applies for the output arguments NB : output arguments are always arrays, input arguments can be arrays, in which case they must be at least the size of inuminstances , or scalars, in which case the same value is shared by multiple instances","title":"Arguments"},{"location":"opcodes/poly.html#output","text":"The output is one or more arrays of k- or a-type, corresponding to the opcode. For instance, an opcode like aout oscili 0.1, kfreq will output an array of audio channels. An opcode like pan2 will output two audio arrays.","title":"Output"},{"location":"opcodes/poly.html#examples","text":"LISTEN < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 0dbfs = 1 ; create an array of random values between 0-1 ; inum: number of elements in the array opcode rndarr , i[] , i i num xin i Out [] init i num i 0 = 0 while i 0 < i num do i Out [ i 0 ] = unirand ( 1 ) i 0 += 1 od xout i Out endop ; multiple oscillators, mixed down to mono instr 1 ; number of oscillators i num = 100 ; fundamental k midi = line ( ntom : i ( \"2G\" ), p3 , ntom : i ( \"1C\" )) k f0 = mtof ( k midi ) ; each oscillator is an overtone of f0 k Ratios [] genarray_i 1 , i num ; harmonicity over time k exp line 1 , p3 , 1.32 ; the freq. of each oscillator k Freqs [] = ( k Ratios ^ k exp ) * k f0 ; array of random phases, to avoid synchronous start i Phs [] rndarr i num ; generate the oscillators. a Oscils [] poly i num , \"oscili\" , 1 / i num , k Freqs , - 1 , i Phs a mono sumarray a Oscils a mono *= linsegr : a ( 0 , 0.05 , 1 , 0.05 , 0 ) outs a mono , a mono endin ; poly instances stacked as a processing pipe instr 2 ; amount of polyphony i num = 30 i Freqs [] rndarr i num ; the ratios of the overtones k Ratios [] genarray_i 1 , i num ; a down gliss k m0 linseg ntom : i ( \"2C\" ), p3 * 0.8 , ntom : i ( \"1C\" ) k f0 = mtof ( k m0 ) ; harmonicity curve k p linsegb 1 , p3 * 0.8 , 1.68 ; calculate actual freqs. k Freqs [] = ( k Ratios ^ k p ) * k f0 ; lfo freqs. used for AM and panning k f linsegb 0.1 , p3 * 0.62 , 0.8 , p3 * 0.8 , 0.8 , p3 * 0.96 , 12 , p3 , 60 k LfoFreqs [] = i Freqs * k f ; multiple noise instances, amplitude modulated a A [] poly i num , \"noise\" , 0.5 , 0.3 a Amps [] poly i num , \"oscili\" , 1 , k LfoFreqs * 0.6 a A *= a Amps ; filter noise with bandpass k Q linsegb 0.5 , p3 * 0.5 , 0.02 , p3 , 0.0001 k Bands [] = k Freqs * k Q a B [] poly i num , \"resonr\" , a A , k Freqs , k Bands ; panning. poly works also with k-rate and with ; opcodes producing multiple outputs, like pan2 k PanPos [] poly i num , \"lfo\" , 0.5 , k LfoFreqs k PanPos += 0.5 ; lfo in the range 0-1 for panning a L [], a R [] poly i num , \"pan2\" , a B , k PanPos a left sumarray a L a right sumarray a R ; compress / fade a ref init 1 a sig = 0.707 * ( a left + a right ) a gain compress2 a ref , a sig , - 90 , - 48 , - 24 , 2.5 , 0.05 , 0.2 , 0.05 a left *= a gain a right *= a gain a gain2 compress2 a ref , ( a left + a right ) * 0.707 , - 90 , - 6 , - 3 , 20 , 0.002 , 0.010 , 0.02 a env = a gain2 * cossegr : a ( 0 , 1 , 1 , 0.1 , 0 ) outs a left * a env , a right * a env endin opcode test , a , k k freq xin a out oscili 0.1 , k freq xout a out endop instr 3 ; test udo k freqs [] fillarray 440 , 443 a A [] poly 2 , \"test\" , k freqs a 0 sumarray a A outs a 0 , a 0 endin </ CsInstruments > < CsScore > i 1 0 8 i 2 9 50 ; i 3 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/poly.html#see-also","text":"maparray polyseq","title":"See also"},{"location":"opcodes/poly.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/polyseq.html","text":"polyseq Abstract polyseq creates and controls multiple sequential version of an opcode Description polyseq creates a user given number of instances of an opcode, each with its own state. The output of an instance is routed to the input of the next instance, forming a chain. Each instance can be controlled individually. We differentiate between chained and multiplexed arguments. chained arguments are the ones which are mapped from one opcode instance to the next, so that the output of one instance is routed to the input of the next. multiplexed are passed after the chained arguments and work as they do with poly : if an array is passed, then each instance is delivered one element of this array, and if a scalar value is passed, then all instances share the same argument. Example All this is best explained with an example: ; these two signal chains produce the same result a 0 pinker k Freqs [] fillarray 100 , 150 , 300 , 330 a eq rbjeq a 0 , k Freqs [ 0 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 1 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 2 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 3 ], 2 , 10 , 1 , 8 a seq polyseq 4 , \"rbjeq\" , a 0 , k Freqs , 2 , 10 , 1 , 8 Syntax xouts polyseq numinstances:i, opcodename:s, xins, params ... polyseq can have any number of inputs and outputs, as long as the opcode used has matching inputs and outputs. Arguments inuminstances : the number of instances of Sopcode to instantiate Sopcode : the name of the opcode xins : any number of arguments, either k- or a-rate, which should correspond to the outputs of the opcode The number and type of the input arguments depend on the arguments passed to the given opcode. The same applies for the output arguments Output xouts : any number of arguments of type k or a , as output by the opcode Examples LISTEN < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 0dbfs = 1 ; Example file for polyseq instr 1 ; A simple parametric eq. ; On the left channel, the reference signal, ; on the right, the polyseq implementation. ; These should be the same a 0 pinker a 0 *= ampdb ( - 12 ) k Freqs [] fillarray 400 , 1400 , 3000 , 4400 , 8000 , 12000 k Qs [] fillarray 10 , 20 , 10 , 20 , 10 , 20 k V = ampdb ( 18 ) a ref = a 0 a ref rbjeq a ref , k Freqs [ 0 ], k V , k Qs [ 0 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 1 ], k V , k Qs [ 1 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 2 ], k V , k Qs [ 2 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 3 ], k V , k Qs [ 3 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 4 ], k V , k Qs [ 4 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 5 ], k V , k Qs [ 5 ], 1 , 8 a seq polyseq lenarray ( k Freqs ), \"rbjeq\" , a 0 , k Freqs , k V , k Qs , 1 , 8 outs a ref , a seq endin opcode rndarr , i[] , iii i num , i min , i max xin i Out [] init i num i 0 = 0 i delta = i max - i min while i 0 < i num do i Out [ i 0 ] = i min + unirand ( i delta ) i 0 += 1 od xout i Out endop instr 2 ; two varying eqs a 0 = pinker () * ampdb ( - 8 ) k Freqs0 [] fillarray 50 , 130 , 400 , 500 , 1400 , 3000 , 4400 , 5000 , 8000 i num lenarray k Freqs0 i Freqslfo [] rndarr i num , 0.05 , 0.4 k Lfos [] poly i num , \"lfo\" , 0.1 , i Freqslfo k FreqsL [] = k Freqs0 * ( 1 + k Lfos ) k FreqsR [] = k Freqs0 * ( 1 + k Lfos * 1.62 ) k Qs [] poly i num , \"lfo\" , 5 , i Freqslfo * 1.5 k Qs += 7.5 a eqL polyseq i num , \"rbjeq\" , a 0 , k FreqsL , ampdb ( 10 ), k Qs , 1 , 8 a eqR polyseq i num , \"rbjeq\" , a 0 , k FreqsR , ampdb ( 12 ), k Qs * 1.5 , 1 , 8 ; declick a env = linsegr ( 0 , 0.5 , 1 , 0.5 , 0 ) outs a eqL * a env , a eqR * a env endin </ CsInstruments > < CsScore > i 1 0 5 i 2 5 20 </ CsScore > </ CsoundSynthesizer > See also maparray poly Credits Eduardo Moguillansky, 2019","title":"polyseq"},{"location":"opcodes/polyseq.html#polyseq","text":"","title":"polyseq"},{"location":"opcodes/polyseq.html#abstract","text":"polyseq creates and controls multiple sequential version of an opcode","title":"Abstract"},{"location":"opcodes/polyseq.html#description","text":"polyseq creates a user given number of instances of an opcode, each with its own state. The output of an instance is routed to the input of the next instance, forming a chain. Each instance can be controlled individually. We differentiate between chained and multiplexed arguments. chained arguments are the ones which are mapped from one opcode instance to the next, so that the output of one instance is routed to the input of the next. multiplexed are passed after the chained arguments and work as they do with poly : if an array is passed, then each instance is delivered one element of this array, and if a scalar value is passed, then all instances share the same argument.","title":"Description"},{"location":"opcodes/polyseq.html#example","text":"All this is best explained with an example: ; these two signal chains produce the same result a 0 pinker k Freqs [] fillarray 100 , 150 , 300 , 330 a eq rbjeq a 0 , k Freqs [ 0 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 1 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 2 ], 2 , 10 , 1 , 8 a eq rbjeq a eq , k Freqs [ 3 ], 2 , 10 , 1 , 8 a seq polyseq 4 , \"rbjeq\" , a 0 , k Freqs , 2 , 10 , 1 , 8","title":"Example"},{"location":"opcodes/polyseq.html#syntax","text":"xouts polyseq numinstances:i, opcodename:s, xins, params ... polyseq can have any number of inputs and outputs, as long as the opcode used has matching inputs and outputs.","title":"Syntax"},{"location":"opcodes/polyseq.html#arguments","text":"inuminstances : the number of instances of Sopcode to instantiate Sopcode : the name of the opcode xins : any number of arguments, either k- or a-rate, which should correspond to the outputs of the opcode The number and type of the input arguments depend on the arguments passed to the given opcode. The same applies for the output arguments","title":"Arguments"},{"location":"opcodes/polyseq.html#output","text":"xouts : any number of arguments of type k or a , as output by the opcode","title":"Output"},{"location":"opcodes/polyseq.html#examples","text":"LISTEN < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 32 nchnls = 2 0dbfs = 1 ; Example file for polyseq instr 1 ; A simple parametric eq. ; On the left channel, the reference signal, ; on the right, the polyseq implementation. ; These should be the same a 0 pinker a 0 *= ampdb ( - 12 ) k Freqs [] fillarray 400 , 1400 , 3000 , 4400 , 8000 , 12000 k Qs [] fillarray 10 , 20 , 10 , 20 , 10 , 20 k V = ampdb ( 18 ) a ref = a 0 a ref rbjeq a ref , k Freqs [ 0 ], k V , k Qs [ 0 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 1 ], k V , k Qs [ 1 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 2 ], k V , k Qs [ 2 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 3 ], k V , k Qs [ 3 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 4 ], k V , k Qs [ 4 ], 1 , 8 a ref rbjeq a ref , k Freqs [ 5 ], k V , k Qs [ 5 ], 1 , 8 a seq polyseq lenarray ( k Freqs ), \"rbjeq\" , a 0 , k Freqs , k V , k Qs , 1 , 8 outs a ref , a seq endin opcode rndarr , i[] , iii i num , i min , i max xin i Out [] init i num i 0 = 0 i delta = i max - i min while i 0 < i num do i Out [ i 0 ] = i min + unirand ( i delta ) i 0 += 1 od xout i Out endop instr 2 ; two varying eqs a 0 = pinker () * ampdb ( - 8 ) k Freqs0 [] fillarray 50 , 130 , 400 , 500 , 1400 , 3000 , 4400 , 5000 , 8000 i num lenarray k Freqs0 i Freqslfo [] rndarr i num , 0.05 , 0.4 k Lfos [] poly i num , \"lfo\" , 0.1 , i Freqslfo k FreqsL [] = k Freqs0 * ( 1 + k Lfos ) k FreqsR [] = k Freqs0 * ( 1 + k Lfos * 1.62 ) k Qs [] poly i num , \"lfo\" , 5 , i Freqslfo * 1.5 k Qs += 7.5 a eqL polyseq i num , \"rbjeq\" , a 0 , k FreqsL , ampdb ( 10 ), k Qs , 1 , 8 a eqR polyseq i num , \"rbjeq\" , a 0 , k FreqsR , ampdb ( 12 ), k Qs * 1.5 , 1 , 8 ; declick a env = linsegr ( 0 , 0.5 , 1 , 0.5 , 0 ) outs a eqL * a env , a eqR * a env endin </ CsInstruments > < CsScore > i 1 0 5 i 2 5 20 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/polyseq.html#see-also","text":"maparray poly","title":"See also"},{"location":"opcodes/polyseq.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/rampgate.html","text":"rampgate Abstract A triggerable envelope with sustain segment Description rampgate is similar to linsegr with an additional gate argument, allowing to retrigger it at will. One of the values can be defined as a sustain point, meaning that as long as the gate is held, the envelope enters a sustain state when reaching this point. When the gate is set to 0, the envelope traverses the rest of the defined points. Syntax xout rampgate kgate, isustindex, kval0, [ktime1, kval1, ktime2, kval2, ...], ktimen, kvaln Arguments kgate : whenever this switches from 0 to 1 a new envelope starts isustindex : the index of the sustain point. For example, if isustindex is 2, then when the envelope reaches kval2 (after ktime0+ktime1), it enters a sustain phase, where its value remains unmodified until the gate is set to 0. If no sustain point is desired, set isustindex to -1 kval0 , ktime1 , ...: a linear envelope, similar to linsegr . The release part can have as many segments as desired. ktimex values are defined as time interval between two values, not as absolute timestamps Output xout : value of the envelope (k- or a- rate) Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* This is the example file of rampgate rampgate is a triggerable envelope with a sustain segment aout rampgate kgate, isustidx, kval0, ktime1, kval1, ..., ktimen, kvaln NB: use isustidx=-1 if no sustain is desired NB: use xtratim if necessary to allow for release segment */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gk gate init 0 FLpanel \"rampgate\" , 240 , 100 , 100 , 100 gk gate , i h1 FLbutton \" Gate\" , 1 , 0 , 2 , 80 , 40 , 10 , 10 , - 1 FLpanelEnd FLrun instr 1 k gate = sc_trig : k ( metro ( 1 / 2 ), 0.5 ) k env rampgate k gate , 1 , 0 , 0.15 , 1 , 0.1 , 0 printf \"t: %f , kenv: %f \\n \" , timeinstk (), timeinsts (), k env k env *= 0.2 a sig = pinker () * interp ( k env ) outs a sig , a sig endin instr 2 i period = 2 i gatedur = 1 k gate = sc_trig : k ( metro ( 1 / i period ), i gatedur ) a env rampgate k gate , 1 , 0 , 0.2 , 1 , 0.1 , 0 a sig = oscili : a ( 0.2 , 1000 ) * a env outs a sig , a sig endin instr 3 a sig pinker a env rampgate gk gate , 2 , 0 , 0.05 , 1 , 0.1 , 0.2 , 0.5 , 0 a sig *= a env outs a sig , a sig endin </ CsInstruments > < CsScore > ; i1 0 10 ; i2 0 10 i 3 0 100 </ CsScore > </ CsoundSynthesizer > See also ramptrig linsegr bpf Credits Eduardo Moguillansky, 2019 (idea based on pd/else's envgen and supercollider's envgen )","title":"rampgate"},{"location":"opcodes/rampgate.html#rampgate","text":"","title":"rampgate"},{"location":"opcodes/rampgate.html#abstract","text":"A triggerable envelope with sustain segment","title":"Abstract"},{"location":"opcodes/rampgate.html#description","text":"rampgate is similar to linsegr with an additional gate argument, allowing to retrigger it at will. One of the values can be defined as a sustain point, meaning that as long as the gate is held, the envelope enters a sustain state when reaching this point. When the gate is set to 0, the envelope traverses the rest of the defined points.","title":"Description"},{"location":"opcodes/rampgate.html#syntax","text":"xout rampgate kgate, isustindex, kval0, [ktime1, kval1, ktime2, kval2, ...], ktimen, kvaln","title":"Syntax"},{"location":"opcodes/rampgate.html#arguments","text":"kgate : whenever this switches from 0 to 1 a new envelope starts isustindex : the index of the sustain point. For example, if isustindex is 2, then when the envelope reaches kval2 (after ktime0+ktime1), it enters a sustain phase, where its value remains unmodified until the gate is set to 0. If no sustain point is desired, set isustindex to -1 kval0 , ktime1 , ...: a linear envelope, similar to linsegr . The release part can have as many segments as desired. ktimex values are defined as time interval between two values, not as absolute timestamps","title":"Arguments"},{"location":"opcodes/rampgate.html#output","text":"xout : value of the envelope (k- or a- rate)","title":"Output"},{"location":"opcodes/rampgate.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/rampgate.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* This is the example file of rampgate rampgate is a triggerable envelope with a sustain segment aout rampgate kgate, isustidx, kval0, ktime1, kval1, ..., ktimen, kvaln NB: use isustidx=-1 if no sustain is desired NB: use xtratim if necessary to allow for release segment */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gk gate init 0 FLpanel \"rampgate\" , 240 , 100 , 100 , 100 gk gate , i h1 FLbutton \" Gate\" , 1 , 0 , 2 , 80 , 40 , 10 , 10 , - 1 FLpanelEnd FLrun instr 1 k gate = sc_trig : k ( metro ( 1 / 2 ), 0.5 ) k env rampgate k gate , 1 , 0 , 0.15 , 1 , 0.1 , 0 printf \"t: %f , kenv: %f \\n \" , timeinstk (), timeinsts (), k env k env *= 0.2 a sig = pinker () * interp ( k env ) outs a sig , a sig endin instr 2 i period = 2 i gatedur = 1 k gate = sc_trig : k ( metro ( 1 / i period ), i gatedur ) a env rampgate k gate , 1 , 0 , 0.2 , 1 , 0.1 , 0 a sig = oscili : a ( 0.2 , 1000 ) * a env outs a sig , a sig endin instr 3 a sig pinker a env rampgate gk gate , 2 , 0 , 0.05 , 1 , 0.1 , 0.2 , 0.5 , 0 a sig *= a env outs a sig , a sig endin </ CsInstruments > < CsScore > ; i1 0 10 ; i2 0 10 i 3 0 100 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/rampgate.html#see-also","text":"ramptrig linsegr bpf","title":"See also"},{"location":"opcodes/rampgate.html#credits","text":"Eduardo Moguillansky, 2019 (idea based on pd/else's envgen and supercollider's envgen )","title":"Credits"},{"location":"opcodes/ramptrig.html","text":"ramptrig Abstract A triggerable ramp between 0 and 1 Description ramptrig is a phasor between 0 and 1, with the difference that it stops after reaching its end point. Whenever it is triggered it rewinds to 0 and starts ramping to 1 in the given duration. A trigger detected whenever the value is possitive and higher than the previous value. Usage as envelope generator Together with bpf this can be used to emulate supercollider's Env and EnvGen , where ramptrig is used as a triggerable phasor, passed as an argument to bpf , which generates the envelope. See examples Syntax kout ramptrig ktrig, kdur, ivaluepost=1, ivaluepre=0 kout, kfinished ramptrig ktrig, kdur, ivaluepost=1, ivaluepre=0 Arguments ktrig : whenever this is possitive and higher than last value, kout is rewinded to 0 kdur : the duration of the ramp ivaluepost : value when ramp reaches its end (default=1) ivaluepre : value previous to any trigger (default=0) Output kout : value of the ramp, between 0 and 1. It can also be ivaluepost or ivaluepre if these are set to any other value than the default kfinished : will be one whenever the ramp reaches its end value. Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; Use Case #1: An envelope which can be retriggered instr 1 ; Duration of envelope k dur = 1 ; This is the gate, could be any irregular signal, midi, osc, etc. k trig metro 0.5 ; Whenever ktrig is possitive and higher than previous value, ; kx ramps from 0 to 1 in kdur seconds k x ramptrig k trig , k dur ; actual envelope k env bpf k x * k dur , 0 , 0 , 0.02 , 1 , k dur , 0 a sig oscili 0.2 , 1000 ; asig pinker a sig *= interp ( k env ) outs a sig , a sig endin ; Use Case #2: Use finished trigger to signal something instr 2 k trig metro 1 / 4 k trig delayk k trig , 0.5 i dur = 2 k phase , k finished1 ramptrig k trig , 2 printf \"finished! \\n \" , k finished1 k env bpf k phase * i dur , 0 , 0 , 0.5 , 1 , 0.8 , 0.5 , 1 , 1 , i dur , 0 a sig = pinker () * interp ( k env ) outs a sig , a sig endin </ CsInstruments > < CsScore > ; i1 0 10 i 2 0 12 ; i3 0 20 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also rampgate sc_phasor bpf Credits Eduardo Moguillansky, 2019","title":"ramptrig"},{"location":"opcodes/ramptrig.html#ramptrig","text":"","title":"ramptrig"},{"location":"opcodes/ramptrig.html#abstract","text":"A triggerable ramp between 0 and 1","title":"Abstract"},{"location":"opcodes/ramptrig.html#description","text":"ramptrig is a phasor between 0 and 1, with the difference that it stops after reaching its end point. Whenever it is triggered it rewinds to 0 and starts ramping to 1 in the given duration. A trigger detected whenever the value is possitive and higher than the previous value. Usage as envelope generator Together with bpf this can be used to emulate supercollider's Env and EnvGen , where ramptrig is used as a triggerable phasor, passed as an argument to bpf , which generates the envelope. See examples","title":"Description"},{"location":"opcodes/ramptrig.html#syntax","text":"kout ramptrig ktrig, kdur, ivaluepost=1, ivaluepre=0 kout, kfinished ramptrig ktrig, kdur, ivaluepost=1, ivaluepre=0","title":"Syntax"},{"location":"opcodes/ramptrig.html#arguments","text":"ktrig : whenever this is possitive and higher than last value, kout is rewinded to 0 kdur : the duration of the ramp ivaluepost : value when ramp reaches its end (default=1) ivaluepre : value previous to any trigger (default=0)","title":"Arguments"},{"location":"opcodes/ramptrig.html#output","text":"kout : value of the ramp, between 0 and 1. It can also be ivaluepost or ivaluepre if these are set to any other value than the default kfinished : will be one whenever the ramp reaches its end value.","title":"Output"},{"location":"opcodes/ramptrig.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/ramptrig.html#examples","text":"< CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; Use Case #1: An envelope which can be retriggered instr 1 ; Duration of envelope k dur = 1 ; This is the gate, could be any irregular signal, midi, osc, etc. k trig metro 0.5 ; Whenever ktrig is possitive and higher than previous value, ; kx ramps from 0 to 1 in kdur seconds k x ramptrig k trig , k dur ; actual envelope k env bpf k x * k dur , 0 , 0 , 0.02 , 1 , k dur , 0 a sig oscili 0.2 , 1000 ; asig pinker a sig *= interp ( k env ) outs a sig , a sig endin ; Use Case #2: Use finished trigger to signal something instr 2 k trig metro 1 / 4 k trig delayk k trig , 0.5 i dur = 2 k phase , k finished1 ramptrig k trig , 2 printf \"finished! \\n \" , k finished1 k env bpf k phase * i dur , 0 , 0 , 0.5 , 1 , 0.8 , 0.5 , 1 , 1 , i dur , 0 a sig = pinker () * interp ( k env ) outs a sig , a sig endin </ CsInstruments > < CsScore > ; i1 0 10 i 2 0 12 ; i3 0 20 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/ramptrig.html#see-also","text":"rampgate sc_phasor bpf","title":"See also"},{"location":"opcodes/ramptrig.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/sigmdrive.html","text":"sigmdrive Abstract Analog \"soft clipping\" distortion by applying non-linear transfer functions. Description sigmdrive simulates analog \"soft clipping\" by applying non-linear transfer functions. Two different sigmoid equations are implemented. In mode 0, out = tanh(in * drivefactor) In mode 1: if in > 0 then out = 1.0 - pow(1. - in, drivefactor) if in <= 0 then out = pow(1. + x, drivefactor) - 1.0 Syntax aout sigmdrive ain, xdrivefactor, kmode=0 Arguments ain : the input audio signal xdrivefactor : a k- or a- value, normally greater than 1. A higher value implies more distortion kmode : the distortion mode. 0=tanh, 1=pow (see above) Output aout : the distorted audio Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 FLpanel \"sigmdrive\" , 400 , 200 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 322 , 20 i disp2 FLvalue \"\" , 30 , 30 , 52 , 80 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk drive , i drivehandle1 FLslider \"drive\" , 0 , 10 , 0 , 3 , i disp1 , 300 , 30 , 20 , 20 gk mode , i drivehandle2 FLslider \"mode\" , 0 , 1 , 0 , 3 , i disp2 , 30 , 30 , 20 , 80 FLpanelEnd FLrun instr 1 a in oscili 0.2 , 440 a out sigmdrive a in , port : k ( gk drive , 0.2 ), gk mode outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer > See also distort1 tanh powershape Credits Eduardo Moguillansky, 2019 (based on pd/else's drive~ - https://github.com/porres/pd-else)","title":"sigmdrive"},{"location":"opcodes/sigmdrive.html#sigmdrive","text":"","title":"sigmdrive"},{"location":"opcodes/sigmdrive.html#abstract","text":"Analog \"soft clipping\" distortion by applying non-linear transfer functions.","title":"Abstract"},{"location":"opcodes/sigmdrive.html#description","text":"sigmdrive simulates analog \"soft clipping\" by applying non-linear transfer functions. Two different sigmoid equations are implemented. In mode 0, out = tanh(in * drivefactor) In mode 1: if in > 0 then out = 1.0 - pow(1. - in, drivefactor) if in <= 0 then out = pow(1. + x, drivefactor) - 1.0","title":"Description"},{"location":"opcodes/sigmdrive.html#syntax","text":"aout sigmdrive ain, xdrivefactor, kmode=0","title":"Syntax"},{"location":"opcodes/sigmdrive.html#arguments","text":"ain : the input audio signal xdrivefactor : a k- or a- value, normally greater than 1. A higher value implies more distortion kmode : the distortion mode. 0=tanh, 1=pow (see above)","title":"Arguments"},{"location":"opcodes/sigmdrive.html#output","text":"aout : the distorted audio","title":"Output"},{"location":"opcodes/sigmdrive.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/sigmdrive.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 FLpanel \"sigmdrive\" , 400 , 200 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 322 , 20 i disp2 FLvalue \"\" , 30 , 30 , 52 , 80 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk drive , i drivehandle1 FLslider \"drive\" , 0 , 10 , 0 , 3 , i disp1 , 300 , 30 , 20 , 20 gk mode , i drivehandle2 FLslider \"mode\" , 0 , 1 , 0 , 3 , i disp2 , 30 , 30 , 20 , 80 FLpanelEnd FLrun instr 1 a in oscili 0.2 , 440 a out sigmdrive a in , port : k ( gk drive , 0.2 ), gk mode outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/sigmdrive.html#see-also","text":"distort1 tanh powershape","title":"See also"},{"location":"opcodes/sigmdrive.html#credits","text":"Eduardo Moguillansky, 2019 (based on pd/else's drive~ - https://github.com/porres/pd-else)","title":"Credits"},{"location":"opcodes/standardchaos.html","text":"standardchaos Abstract Standard map chaotic generator Description standardchaos is a chaotic generator, the sound is generated with the following difference equations; y[n] = (y[n-1] + k * sin(x[n-1])) % 2pi; x[n] = (x[n-1] + y[n]) % 2pi; out = (x[n] - pi) / pi Syntax aout standardchaos krate, kk=1, ix=0.5, iy=0 Arguments krate : from 0 to nyquist kk : a value for k in the above equation ix : initial value for x iy : initial value for y Output aout : audio output of the chaotic generator Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 /* Example file for standardchaos opcode aout standardchaos krate, kk, ix=0.5, iy=0 Standard map chaotic generator, the sound is generated with the difference equations; y[n] = (y[n-1] + k * sin(x[n-1])) % 2pi; x[n] = (x[n-1] + y[n]) % 2pi; out = (x[n] - pi) / pi; */ FLpanel \"standardchaos\" , 600 , 300 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 522 , 20 i disp2 FLvalue \"\" , 50 , 30 , 522 , 80 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk rate , gi h1 FLslider \"rate\" , 0 , 20000 , 0 , 3 , i disp1 , 500 , 30 , 20 , 20 gk k , gi h2 FLslider \"k\" , 0 , 10 , 0 , 3 , i disp2 , 500 , 30 , 20 , 80 FLpanelEnd FLrun FLsetVal_i 1618 , gi h1 FLsetVal_i 1 , gi h2 instr 1 i x = 0.5 i y = 1 i gain = 0.3 a out standardchaos gk rate , gk k , i x , i y a out *= i gain outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer > See also crackle chuap dust2 Credits Eduardo Moguillansky, 2019 (based on pd/else's standard~ - https://github.com/porres/pd-else)","title":"standardchaos"},{"location":"opcodes/standardchaos.html#standardchaos","text":"","title":"standardchaos"},{"location":"opcodes/standardchaos.html#abstract","text":"Standard map chaotic generator","title":"Abstract"},{"location":"opcodes/standardchaos.html#description","text":"standardchaos is a chaotic generator, the sound is generated with the following difference equations; y[n] = (y[n-1] + k * sin(x[n-1])) % 2pi; x[n] = (x[n-1] + y[n]) % 2pi; out = (x[n] - pi) / pi","title":"Description"},{"location":"opcodes/standardchaos.html#syntax","text":"aout standardchaos krate, kk=1, ix=0.5, iy=0","title":"Syntax"},{"location":"opcodes/standardchaos.html#arguments","text":"krate : from 0 to nyquist kk : a value for k in the above equation ix : initial value for x iy : initial value for y","title":"Arguments"},{"location":"opcodes/standardchaos.html#output","text":"aout : audio output of the chaotic generator","title":"Output"},{"location":"opcodes/standardchaos.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/standardchaos.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 /* Example file for standardchaos opcode aout standardchaos krate, kk, ix=0.5, iy=0 Standard map chaotic generator, the sound is generated with the difference equations; y[n] = (y[n-1] + k * sin(x[n-1])) % 2pi; x[n] = (x[n-1] + y[n]) % 2pi; out = (x[n] - pi) / pi; */ FLpanel \"standardchaos\" , 600 , 300 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 522 , 20 i disp2 FLvalue \"\" , 50 , 30 , 522 , 80 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk rate , gi h1 FLslider \"rate\" , 0 , 20000 , 0 , 3 , i disp1 , 500 , 30 , 20 , 20 gk k , gi h2 FLslider \"k\" , 0 , 10 , 0 , 3 , i disp2 , 500 , 30 , 20 , 80 FLpanelEnd FLrun FLsetVal_i 1618 , gi h1 FLsetVal_i 1 , gi h2 instr 1 i x = 0.5 i y = 1 i gain = 0.3 a out standardchaos gk rate , gk k , i x , i y a out *= i gain outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/standardchaos.html#see-also","text":"crackle chuap dust2","title":"See also"},{"location":"opcodes/standardchaos.html#credits","text":"Eduardo Moguillansky, 2019 (based on pd/else's standard~ - https://github.com/porres/pd-else)","title":"Credits"}]}